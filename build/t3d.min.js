/**
 * @license
 * Copyright 2021-present uino
 * SPDX-License-Identifier: BSD-3-Clause
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).t3d={})}(this,(function(t){"use strict";class e{static generateUUID(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,i=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(n[255&t]+n[t>>8&255]+n[t>>16&255]+n[t>>24&255]+"-"+n[255&e]+n[e>>8&255]+"-"+n[e>>16&15|64]+n[e>>24&255]+"-"+n[63&i|128]+n[i>>8&255]+"-"+n[i>>16&255]+n[i>>24&255]+n[255&r]+n[r>>8&255]+n[r>>16&255]+n[r>>24&255]).toUpperCase()}static lerp(t,e,n){return t+(e-t)*n}static clamp(t,e,n){return Math.max(e,Math.min(n,t))}static euclideanModulo(t,e){return(t%e+e)%e}static isPowerOfTwo(t){return!(t&t-1)&&0!==t}static nearestPowerOfTwo(t){return Math.pow(2,Math.round(Math.log(t)/Math.LN2))}static nextPowerOfTwo(t){return t--,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,++t}static nextPowerOfTwoSquareSize(t){return this.nextPowerOfTwo(Math.ceil(Math.sqrt(t)))}static denormalize(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}static normalize(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}static toHalfFloat(t){Math.abs(t)>65504&&(console.warn("MathUtils.toHalfFloat(): Value out of range."),t=this.clamp(t,-65504,65504)),i.floatView[0]=t;const e=i.uint32View[0],n=e>>23&511;return i.baseTable[n]+((8388607&e)>>i.shiftTable[n])}static fromHalfFloat(t){const e=t>>10;return i.uint32View[0]=i.mantissaTable[i.offsetTable[e]+(1023&t)]+i.exponentTable[e],i.floatView[0]}}const n=[];for(let t=0;t<256;t++)n[t]=(t<16?"0":"")+t.toString(16);const i=function(){const t=new ArrayBuffer(4),e=new Float32Array(t),n=new Uint32Array(t),i=new Uint32Array(512),r=new Uint32Array(512);for(let t=0;t<256;++t){const e=t-127;e<-27?(i[t]=0,i[256|t]=32768,r[t]=24,r[256|t]=24):e<-14?(i[t]=1024>>-e-14,i[256|t]=1024>>-e-14|32768,r[t]=-e-1,r[256|t]=-e-1):e<=15?(i[t]=e+15<<10,i[256|t]=e+15<<10|32768,r[t]=13,r[256|t]=13):e<128?(i[t]=31744,i[256|t]=64512,r[t]=24,r[256|t]=24):(i[t]=31744,i[256|t]=64512,r[t]=13,r[256|t]=13)}const s=new Uint32Array(2048),a=new Uint32Array(64),o=new Uint32Array(64);for(let t=1;t<1024;++t){let e=t<<13,n=0;for(;!(8388608&e);)e<<=1,n-=8388608;e&=-8388609,n+=947912704,s[t]=e|n}for(let t=1024;t<2048;++t)s[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)a[t]=t<<23;a[31]=1199570944,a[32]=2147483648;for(let t=33;t<63;++t)a[t]=2147483648+(t-32<<23);a[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(o[t]=1024);return{floatView:e,uint32View:n,baseTable:i,shiftTable:r,mantissaTable:s,exponentTable:a,offsetTable:o}}();class r{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}lerpVectors(t,e,n){return this.subVectors(e,t).multiplyScalar(n).add(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}set(t=0,e=0,n=0){return this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}getLength(){return Math.sqrt(this.getLengthSquared())}getLengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}normalize(t=1){const e=t/(this.getLength()||1);return this.x*=e,this.y*=e,this.z*=e,this}subtract(t,e=new r){return e.set(this.x-t.x,this.y-t.y,this.z-t.z)}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}crossVectors(t,e){const n=t.x,i=t.y,r=t.z,s=e.x,a=e.y,o=e.z;return this.x=i*o-r*a,this.y=r*s-n*o,this.z=n*a-i*s,this}cross(t){return this.crossVectors(this,t)}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,r=t._x,s=t._y,a=t._z,o=t._w,l=o*e+s*i-a*n,h=o*n+a*e-r*i,c=o*i+r*n-s*e,u=-r*e-s*n-a*i;return this.x=l*o+u*-r+h*-a-c*-s,this.y=h*o+u*-s+c*-r-l*-a,this.z=c*o+u*-a+l*-s-h*-r,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=t.elements,s=1/(r[3]*e+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*e+r[4]*n+r[8]*i+r[12])*s,this.y=(r[1]*e+r[5]*n+r[9]*i+r[13])*s,this.z=(r[2]*e+r[6]*n+r[10]*i+r[14])*s,this}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6]*i,this.y=r[1]*e+r[4]*n+r[7]*i,this.z=r[2]*e+r[5]*n+r[8]*i,this}transformDirection(t){const e=this.x,n=this.y,i=this.z,r=t.elements;return this.x=r[0]*e+r[4]*n+r[8]*i,this.y=r[1]*e+r[5]*n+r[9]*i,this.z=r[2]*e+r[6]*n+r[10]*i,this.normalize()}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).getLength(),n=this.setFromMatrixColumn(t,1).getLength(),i=this.setFromMatrixColumn(t,2).getLength();return this.set(e,n,i)}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}fromArray(t,n=0,i=!1){let r=t[n],s=t[n+1],a=t[n+2];return i&&(r=e.denormalize(r,t),s=e.denormalize(s,t),a=e.denormalize(a,t)),this.x=r,this.y=s,this.z=a,this}toArray(t=[],n=0,i=!1){let r=this.x,s=this.y,a=this.z;return i&&(r=e.normalize(r,t),s=e.normalize(s,t),a=e.normalize(a,t)),t[n]=r,t[n+1]=s,t[n+2]=a,t}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}setFromSpherical(t){const e=Math.sin(t.phi)*t.radius;return this.x=e*Math.sin(t.theta),this.y=Math.cos(t.phi)*t.radius,this.z=e*Math.cos(t.theta),this}project(t){return this.applyMatrix4(t.projectionViewMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.worldMatrix)}reflect(t){return this.sub(s.copy(t).multiplyScalar(2*this.dot(t)))}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}clone(){return new r(this.x,this.y,this.z)}}const s=new r;class a{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}isIdentity(){const t=this.elements;return 1===t[0]&&0===t[4]&&0===t[8]&&0===t[12]&&0===t[1]&&1===t[5]&&0===t[9]&&0===t[13]&&0===t[2]&&0===t[6]&&1===t[10]&&0===t[14]&&0===t[3]&&0===t[7]&&0===t[11]&&1===t[15]}set(t,e,n,i,r,s,a,o,l,h,c,u,d,p,f,_){const m=this.elements;return m[0]=t,m[4]=e,m[8]=n,m[12]=i,m[1]=r,m[5]=s,m[9]=a,m[13]=o,m[2]=l,m[6]=h,m[10]=c,m[14]=u,m[3]=d,m[7]=p,m[11]=f,m[15]=_,this}clone(){return(new a).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1)}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1)}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1)}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],a=n[4],o=n[8],l=n[12],h=n[1],c=n[5],u=n[9],d=n[13],p=n[2],f=n[6],_=n[10],m=n[14],g=n[3],v=n[7],T=n[11],S=n[15],E=i[0],x=i[4],M=i[8],A=i[12],y=i[1],w=i[5],R=i[9],L=i[13],C=i[2],b=i[6],P=i[10],N=i[14],D=i[3],F=i[7],I=i[11],O=i[15];return r[0]=s*E+a*y+o*C+l*D,r[4]=s*x+a*w+o*b+l*F,r[8]=s*M+a*R+o*P+l*I,r[12]=s*A+a*L+o*N+l*O,r[1]=h*E+c*y+u*C+d*D,r[5]=h*x+c*w+u*b+d*F,r[9]=h*M+c*R+u*P+d*I,r[13]=h*A+c*L+u*N+d*O,r[2]=p*E+f*y+_*C+m*D,r[6]=p*x+f*w+_*b+m*F,r[10]=p*M+f*R+_*P+m*I,r[14]=p*A+f*L+_*N+m*O,r[3]=g*E+v*y+T*C+S*D,r[7]=g*x+v*w+T*b+S*F,r[11]=g*M+v*R+T*P+S*I,r[15]=g*A+v*L+T*N+S*O,this}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}inverse(){return this.getInverse(this)}getInverse(t){const e=this.elements,n=t.elements,i=n[0],r=n[1],s=n[2],a=n[3],o=n[4],l=n[5],h=n[6],c=n[7],u=n[8],d=n[9],p=n[10],f=n[11],_=n[12],m=n[13],g=n[14],v=n[15],T=d*g*c-m*p*c+m*h*f-l*g*f-d*h*v+l*p*v,S=_*p*c-u*g*c-_*h*f+o*g*f+u*h*v-o*p*v,E=u*m*c-_*d*c+_*l*f-o*m*f-u*l*v+o*d*v,x=_*d*h-u*m*h-_*l*p+o*m*p+u*l*g-o*d*g,M=i*T+r*S+s*E+a*x;if(0===M)return console.warn("Matrix4: can not invert matrix, determinant is 0"),this.identity();const A=1/M;return e[0]=T*A,e[1]=(m*p*a-d*g*a-m*s*f+r*g*f+d*s*v-r*p*v)*A,e[2]=(l*g*a-m*h*a+m*s*c-r*g*c-l*s*v+r*h*v)*A,e[3]=(d*h*a-l*p*a-d*s*c+r*p*c+l*s*f-r*h*f)*A,e[4]=S*A,e[5]=(u*g*a-_*p*a+_*s*f-i*g*f-u*s*v+i*p*v)*A,e[6]=(_*h*a-o*g*a-_*s*c+i*g*c+o*s*v-i*h*v)*A,e[7]=(o*p*a-u*h*a+u*s*c-i*p*c-o*s*f+i*h*f)*A,e[8]=E*A,e[9]=(_*d*a-u*m*a-_*r*f+i*m*f+u*r*v-i*d*v)*A,e[10]=(o*m*a-_*l*a+_*r*c-i*m*c-o*r*v+i*l*v)*A,e[11]=(u*l*a-o*d*a-u*r*c+i*d*c+o*r*f-i*l*f)*A,e[12]=x*A,e[13]=(u*m*s-_*d*s+_*r*p-i*m*p-u*r*g+i*d*g)*A,e[14]=(_*l*s-o*m*s-_*r*h+i*m*h+o*r*g-i*l*g)*A,e[15]=(o*d*s-u*l*s+u*r*h-i*d*h-o*r*p+i*l*p)*A,this}transform(t,e,n){const i=this.elements,r=n._x,s=n._y,a=n._z,o=n._w,l=r+r,h=s+s,c=a+a,u=r*l,d=r*h,p=r*c,f=s*h,_=s*c,m=a*c,g=o*l,v=o*h,T=o*c,S=e.x,E=e.y,x=e.z;return i[0]=(1-(f+m))*S,i[1]=(d+T)*S,i[2]=(p-v)*S,i[3]=0,i[4]=(d-T)*E,i[5]=(1-(u+m))*E,i[6]=(_+g)*E,i[7]=0,i[8]=(p+v)*x,i[9]=(_-g)*x,i[10]=(1-(u+f))*x,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}makeRotationFromQuaternion(t){const e=this.elements,n=t.x,i=t.y,r=t.z,s=t.w,a=n+n,o=i+i,l=r+r,h=n*a,c=n*o,u=n*l,d=i*o,p=i*l,f=r*l,_=s*a,m=s*o,g=s*l;return e[0]=1-(d+f),e[4]=c-g,e[8]=u+m,e[1]=c+g,e[5]=1-(h+f),e[9]=p-_,e[2]=u-m,e[6]=p+_,e[10]=1-(h+d),e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}extractRotation(t){const e=this.elements,n=t.elements,i=1/o.setFromMatrixColumn(t,0).getLength(),r=1/o.setFromMatrixColumn(t,1).getLength(),s=1/o.setFromMatrixColumn(t,2).getLength();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*r,e[5]=n[5]*r,e[6]=n[6]*r,e[7]=0,e[8]=n[8]*s,e[9]=n[9]*s,e[10]=n[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}lookAtRH(t,e,n){const i=this.elements;return u.subVectors(t,e),0===u.getLengthSquared()&&(u.z=1),u.normalize(),h.crossVectors(n,u),0===h.getLengthSquared()&&(1===Math.abs(n.z)?u.x+=1e-4:u.z+=1e-4,u.normalize(),h.crossVectors(n,u)),h.normalize(),c.crossVectors(u,h),i[0]=h.x,i[4]=c.x,i[8]=u.x,i[1]=h.y,i[5]=c.y,i[9]=u.y,i[2]=h.z,i[6]=c.z,i[10]=u.z,this}decompose(t,e,n){const i=this.elements;let r=o.set(i[0],i[1],i[2]).getLength();const s=o.set(i[4],i[5],i[6]).getLength(),a=o.set(i[8],i[9],i[10]).getLength();this.determinant()<0&&(r=-r),t.x=i[12],t.y=i[13],t.z=i[14],l.copy(this);const h=1/r,c=1/s,u=1/a;return l.elements[0]*=h,l.elements[1]*=h,l.elements[2]*=h,l.elements[4]*=c,l.elements[5]*=c,l.elements[6]*=c,l.elements[8]*=u,l.elements[9]*=u,l.elements[10]*=u,e.setFromRotationMatrix(l),n.x=r,n.y=s,n.z=a,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],r=t[12],s=t[1],a=t[5],o=t[9],l=t[13],h=t[2],c=t[6],u=t[10],d=t[14],p=t[3],f=t[7],_=t[11],m=e*a-n*s,g=e*o-i*s,v=n*o-i*a,T=h*f-c*p,S=h*_-u*p,E=c*_-u*f;return l*(e*E-n*S+i*T)-r*(s*E-a*S+o*T)+t[15]*(h*v-c*g+u*m)-d*(p*v-f*g+_*m)}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),r=1-n,s=t.x,a=t.y,o=t.z,l=r*s,h=r*a;return this.set(l*s+n,l*a-i*o,l*o+i*a,0,l*a+i*o,h*a+n,h*o-i*s,0,l*o-i*a,h*o+i*s,r*o*o+n,0,0,0,0,1)}lerpMatrices(t,e,n){if(0===n)return this.copy(t);if(1===n)return this.copy(e);const i=this.elements,r=t.elements,s=e.elements;for(let t=0;t<16;t++)i[t]=r[t]*(1-n)+s[t]*n;return this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<16;t++)if(e[t]!==n[t])return!1;return!0}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}const o=new r,l=new a,h=new r,c=new r,u=new r;class d{constructor(t=0,e=0,n=0,i=1){this._x=t,this._y=e,this._z=n,this._w=i}static slerpFlat(t,e,n,i,r,s,a){let o=n[i+0],l=n[i+1],h=n[i+2],c=n[i+3];const u=r[s+0],d=r[s+1],p=r[s+2],f=r[s+3];if(0===a)return t[e]=o,t[e+1]=l,t[e+2]=h,void(t[e+3]=c);if(1===a)return t[e]=u,t[e+1]=d,t[e+2]=p,void(t[e+3]=f);if(c!==f||o!==u||l!==d||h!==p){let t=1-a;const e=o*u+l*d+h*p+c*f,n=e>=0?1:-1,i=1-e*e;if(i>Number.EPSILON){const r=Math.sqrt(i),s=Math.atan2(r,e*n);t=Math.sin(t*s)/r,a=Math.sin(a*s)/r}const r=a*n;if(o=o*t+u*r,l=l*t+d*r,h=h*t+p*r,c=c*t+f*r,t===1-a){const t=1/Math.sqrt(o*o+l*l+h*h+c*c);o*=t,l*=t,h*=t,c*=t}}t[e]=o,t[e+1]=l,t[e+2]=h,t[e+3]=c}static multiplyQuaternionsFlat(t,e,n,i,r,s){const a=n[i],o=n[i+1],l=n[i+2],h=n[i+3],c=r[s],u=r[s+1],d=r[s+2],p=r[s+3];return t[e]=a*p+h*c+o*d-l*u,t[e+1]=o*p+h*u+l*c-a*d,t[e+2]=l*p+h*d+a*u-o*c,t[e+3]=h*p-a*c-o*u-l*d,t}get x(){return this._x}set x(t){this._x=t,this.onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this.onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this.onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this.onChangeCallback()}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this.onChangeCallback(),this}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}lerpQuaternions(t,e,n){if(0===n)return this.copy(t);if(1===n)return this.copy(e);const i=t._w,r=t._x,s=t._y,a=t._z;let o=e._w,l=e._x,h=e._y,c=e._z;i*o+r*l+s*h+a*c<0&&(o=-o,l=-l,h=-h,c=-c),this._w=i+n*(o-i),this._x=r+n*(l-r),this._y=s+n*(h-s),this._z=a+n*(c-a);const u=1/Math.sqrt(this._w*this._w+this._x*this._x+this._y*this._y+this._z*this._z);return this._w*=u,this._x*=u,this._y*=u,this._z*=u,this.onChangeCallback(),this}slerpQuaternions(t,e,n){if(0===n)return this.copy(t);if(1===n)return this.copy(e);const i=t._w,r=t._x,s=t._y,a=t._z;let o=e._w,l=e._x,h=e._y,c=e._z,u=i*o+r*l+s*h+a*c;if(u<0&&(u=-u,o=-o,l=-l,h=-h,c=-c),u<.95){const t=Math.acos(u),e=1/Math.sin(t),d=Math.sin(t*(1-n))*e,p=Math.sin(t*n)*e;this._w=i*d+o*p,this._x=r*d+l*p,this._y=s*d+h*p,this._z=a*d+c*p}else{this._w=i+n*(o-i),this._x=r+n*(l-r),this._y=s+n*(h-s),this._z=a+n*(c-a);const t=1/Math.sqrt(this._w*this._w+this._x*this._x+this._y*this._y+this._z*this._z);this._w*=t,this._x*=t,this._y*=t,this._z*=t}return this.onChangeCallback(),this}set(t=0,e=0,n=0,i=1){return this._x=t,this._y=e,this._z=n,this._w=i,this.onChangeCallback(),this}clone(){return new d(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=void 0!==t.w?t.w:1,this.onChangeCallback(),this}setFromEuler(t,e=!0){const n=Math.cos(t._x/2),i=Math.cos(t._y/2),r=Math.cos(t._z/2),s=Math.sin(t._x/2),a=Math.sin(t._y/2),o=Math.sin(t._z/2),l=t._order;return"XYZ"===l?(this._x=s*i*r+n*a*o,this._y=n*a*r-s*i*o,this._z=n*i*o+s*a*r,this._w=n*i*r-s*a*o):"YXZ"===l?(this._x=s*i*r+n*a*o,this._y=n*a*r-s*i*o,this._z=n*i*o-s*a*r,this._w=n*i*r+s*a*o):"ZXY"===l?(this._x=s*i*r-n*a*o,this._y=n*a*r+s*i*o,this._z=n*i*o+s*a*r,this._w=n*i*r-s*a*o):"ZYX"===l?(this._x=s*i*r-n*a*o,this._y=n*a*r+s*i*o,this._z=n*i*o-s*a*r,this._w=n*i*r+s*a*o):"YZX"===l?(this._x=s*i*r+n*a*o,this._y=n*a*r+s*i*o,this._z=n*i*o-s*a*r,this._w=n*i*r-s*a*o):"XZY"===l&&(this._x=s*i*r-n*a*o,this._y=n*a*r-s*i*o,this._z=n*i*o+s*a*r,this._w=n*i*r+s*a*o),!0===e&&this.onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],r=e[8],s=e[1],a=e[5],o=e[9],l=e[2],h=e[6],c=e[10],u=n+a+c;let d;return u>0?(d=.5/Math.sqrt(u+1),this._w=.25/d,this._x=(h-o)*d,this._y=(r-l)*d,this._z=(s-i)*d):n>a&&n>c?(d=2*Math.sqrt(1+n-a-c),this._w=(h-o)/d,this._x=.25*d,this._y=(i+s)/d,this._z=(r+l)/d):a>c?(d=2*Math.sqrt(1+a-n-c),this._w=(r-l)/d,this._x=(i+s)/d,this._y=.25*d,this._z=(o+h)/d):(d=2*Math.sqrt(1+c-n-a),this._w=(s-i)/d,this._x=(r+l)/d,this._y=(o+h)/d,this._z=.25*d),this.onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,r=t._z,s=t._w,a=e._x,o=e._y,l=e._z,h=e._w;return this._x=n*h+s*a+i*l-r*o,this._y=i*h+s*o+r*a-n*l,this._z=r*h+s*l+n*o-i*a,this._w=s*h-n*a-i*o-r*l,this.onChangeCallback(),this}toMatrix4(t=new a){const e=t.elements,n=2*this._x*this._y,i=2*this._x*this._z,r=2*this._x*this._w,s=2*this._y*this._z,o=2*this._y*this._w,l=2*this._z*this._w,h=this._x*this._x,c=this._y*this._y,u=this._z*this._z,d=this._w*this._w;return e[0]=h-c-u+d,e[4]=n-l,e[8]=i+o,e[12]=0,e[1]=n+l,e[5]=-h+c-u+d,e[9]=s-r,e[13]=0,e[2]=i-o,e[6]=s+r,e[10]=-h-c+u+d,e[14]=0,e[3]=0,e[7]=0,e[11]=0,e[15]=1,t}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this.onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this.onChangeCallback(),this}fromArray(t,n=0,i=!1){let r=t[n],s=t[n+1],a=t[n+2],o=t[n+3];return i&&(r=e.denormalize(r,t),s=e.denormalize(s,t),a=e.denormalize(a,t),o=e.denormalize(o,t)),this._x=r,this._y=s,this._z=a,this._w=o,this.onChangeCallback(),this}toArray(t=[],n=0,i=!1){let r=this._x,s=this._y,a=this._z,o=this._w;return i&&(r=e.normalize(r,t),s=e.normalize(s,t),a=e.normalize(a,t),o=e.normalize(o,t)),t[n]=r,t[n+1]=s,t[n+2]=a,t[n+3]=o,t}onChange(t){return this.onChangeCallback=t,this}onChangeCallback(){}}class p{static getValueSize(){return this.values.length/this.times.length}static interpolate(t,e,n,i){throw new Error("Interpolant: call to abstract method")}static copyValue(t,e){const n=this.values,i=this.valueSize,r=i*t;for(let t=0;t<i;t++)e[t]=n[r+t];return e}}class f extends p{static interpolate(t,e,n,i){const r=this.values,s=this.valueSize,a=s*t;for(let t=0;t<s;t++)i[t]=r[a+t];return i}}class _ extends p{static interpolate(t,e,n,i){const r=this.values,s=this.valueSize,a=t*s,o=(t+1)*s;let l,h;for(let t=0;t<s;t++)l=r[a+t],h=r[o+t],i[t]=void 0!==l&&void 0!==h?l*(1-e)+h*e:l;return i}}class m extends p{static interpolate(t,e,n,i){const r=this.values,s=this.valueSize;return d.slerpFlat(i,0,r,t*s,r,(t+1)*s,e),i}}class g extends p{static getValueSize(){return this.values.length/this.times.length/3}static interpolate(t,e,n,i){const r=this.values,s=this.valueSize,a=2*s,o=3*s,l=e*e,h=l*e,c=t*o,u=c+o,d=-2*h+3*l,p=h-l,f=1-d,_=p-l+e;for(let t=0;t<s;t++){const e=r[c+t+s],o=r[c+t+a]*n,l=r[u+t+s],h=r[u+t]*n;i[t]=f*e+_*o+d*l+p*h}return i}static copyValue(t,e){const n=this.values,i=this.valueSize,r=i*t*3+i;for(let t=0;t<i;t++)e[t]=n[r+t];return e}}const v=new d;class T{constructor(t,e,n,i,r=_){this.target=t,this.propertyPath=e,this.name=this.target.uuid+"."+e,this.times=n,this.values=i,this.valueSize=0,this.interpolant=null,!0===r?r=_:!1===r&&(r=f),this.setInterpolant(r)}setInterpolant(t){return this.valueSize=t.getValueSize.call(this),this.interpolant=t,this}getValue(t,e){const n=this.interpolant,i=this.times,r=i.length;if(t<=i[0])return n.copyValue.call(this,0,e);if(t>=i[r-1])return n.copyValue.call(this,r-1,e);let s=r-1;for(;t<i[s]&&s>0;)s--;const a=i[s+1]-i[s],o=(t-i[s])/a;return n.interpolate.call(this,s,o,a,e)}}class S extends T{constructor(t,e,n,i,r=f){!0===r&&(r=f),super(t,e,n,i,r)}}S.prototype.valueTypeName="bool";class E extends T{constructor(t,e,n,i,r){super(t,e,n,i,r)}}E.prototype.valueTypeName="color";class x extends T{constructor(t,e,n,i,r){super(t,e,n,i,r)}}x.prototype.valueTypeName="number";class M extends T{constructor(t,e,n,i,r=m){!0===r&&(r=m),super(t,e,n,i,r)}}M.prototype.valueTypeName="quaternion";class A extends T{constructor(t,e,n,i,r=f){!0===r&&(r=f),super(t,e,n,i,r)}}A.prototype.valueTypeName="string";class y extends T{constructor(t,e,n,i,r){super(t,e,n,i,r)}}y.prototype.valueTypeName="vector";const w={BASIC:"basic",LAMBERT:"lambert",PHONG:"phong",PBR:"pbr",PBR2:"pbr2",POINT:"point",LINE:"line",SHADER:"shader",DEPTH:"depth",DISTANCE:"distance"},R={NONE:"none",NORMAL:"normal",ADD:"add",SUB:"sub",MUL:"mul",CUSTOM:"custom"},L={ADD:100,SUBTRACT:101,REVERSE_SUBTRACT:102,MIN:103,MAX:104},C={ZERO:200,ONE:201,SRC_COLOR:202,SRC_ALPHA:203,SRC_ALPHA_SATURATE:204,DST_COLOR:205,DST_ALPHA:206,ONE_MINUS_SRC_COLOR:207,ONE_MINUS_SRC_ALPHA:208,ONE_MINUS_DST_COLOR:209,ONE_MINUS_DST_ALPHA:210},b={NONE:"none",FRONT:"front",BACK:"back",FRONT_AND_BACK:"front_and_back"},P={FRONT:"front",BACK:"back",DOUBLE:"double"},N={SMOOTH_SHADING:"smooth_shading",FLAT_SHADING:"flat_shading"},D={DEPTH_COMPONENT:1e3,DEPTH_STENCIL:1001,STENCIL_INDEX8:1002,ALPHA:1003,RED:1004,RGB:1005,RGBA:1006,LUMINANCE:1007,LUMINANCE_ALPHA:1008,RED_INTEGER:1010,RG:1011,RG_INTEGER:1012,RGB_INTEGER:1013,RGBA_INTEGER:1014,R32F:1100,R16F:1101,R8:1102,RG32F:1103,RG16F:1104,RG8:1105,RGB32F:1106,RGB16F:1107,RGB8:1108,RGBA32F:1109,RGBA16F:1110,RGBA8:1111,RGBA4:1112,RGB5_A1:1113,DEPTH_COMPONENT32F:1114,DEPTH_COMPONENT24:1115,DEPTH_COMPONENT16:1116,DEPTH24_STENCIL8:1117,DEPTH32F_STENCIL8:1118,R11F_G11F_B10F:1119,RGB_S3TC_DXT1:1200,RGBA_S3TC_DXT1:1201,RGBA_S3TC_DXT3:1202,RGBA_S3TC_DXT5:1203,RGB_PVRTC_4BPPV1:1204,RGB_PVRTC_2BPPV1:1205,RGBA_PVRTC_4BPPV1:1206,RGBA_PVRTC_2BPPV1:1207,RGB_ETC1:1208,RGBA_ASTC_4x4:1209,RGBA_BPTC:1210},F={UNSIGNED_BYTE:1500,UNSIGNED_SHORT_5_6_5:1501,UNSIGNED_SHORT_4_4_4_4:1502,UNSIGNED_SHORT_5_5_5_1:1503,UNSIGNED_SHORT:1504,UNSIGNED_INT:1505,UNSIGNED_INT_24_8:1506,FLOAT:1507,HALF_FLOAT:1508,FLOAT_32_UNSIGNED_INT_24_8_REV:1509,BYTE:1510,SHORT:1511,INT:1512},I={NEAREST:1600,LINEAR:1601,NEAREST_MIPMAP_NEAREST:1602,LINEAR_MIPMAP_NEAREST:1603,NEAREST_MIPMAP_LINEAR:1604,LINEAR_MIPMAP_LINEAR:1605},O={REPEAT:1700,CLAMP_TO_EDGE:1701,MIRRORED_REPEAT:1702},U={LEQUAL:515,GEQUAL:518,LESS:513,GREATER:516,EQUAL:514,NOTEQUAL:517,ALWAYS:519,NEVER:512},B={KEEP:7680,REPLACE:7681,INCR:7682,DECR:7683,INVERT:5386,INCR_WRAP:34055,DECR_WRAP:34056},z={HARD:"hard",POISSON_SOFT:"poisson_soft",PCF3_SOFT:"pcf3_soft",PCF5_SOFT:"pcf5_soft",PCSS16_SOFT:"pcss16_soft",PCSS32_SOFT:"pcss32_soft",PCSS64_SOFT:"pcss64_soft"},G={LINEAR:"linear",SRGB:"sRGB",GAMMA:"Gamma"},H={MULTIPLY:"ENVMAP_BLENDING_MULTIPLY",MIX:"ENVMAP_BLENDING_MIX",ADD:"ENVMAP_BLENDING_ADD"},V={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},k={NONE:0,RGB:1,RGBA:2},W={COLOR_ATTACHMENT0:2e3,COLOR_ATTACHMENT1:2001,COLOR_ATTACHMENT2:2002,COLOR_ATTACHMENT3:2003,COLOR_ATTACHMENT4:2004,COLOR_ATTACHMENT5:2005,COLOR_ATTACHMENT6:2006,COLOR_ATTACHMENT7:2007,COLOR_ATTACHMENT8:2008,COLOR_ATTACHMENT9:2009,COLOR_ATTACHMENT10:2010,COLOR_ATTACHMENT11:2011,COLOR_ATTACHMENT12:2012,COLOR_ATTACHMENT13:2013,COLOR_ATTACHMENT14:2014,COLOR_ATTACHMENT15:2015,DEPTH_ATTACHMENT:2020,STENCIL_ATTACHMENT:2021,DEPTH_STENCIL_ATTACHMENT:2030},X={STREAM_DRAW:35040,STREAM_READ:35041,STREAM_COPY:35042,STATIC_DRAW:35044,STATIC_READ:35045,STATIC_COPY:35046,DYNAMIC_DRAW:35048,DYNAMIC_READ:35049,DYNAMIC_COPY:35050},q={ANY_SAMPLES_PASSED:7e3,ANY_SAMPLES_PASSED_CONSERVATIVE:7001,TIME_ELAPSED:7002};class j{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[t]&&(n[t]=[]),-1===n[t].indexOf(e)&&n[t].push(e)}removeEventListener(t,e){const n=this._listeners;if(void 0===n)return;const i=n[t];if(void 0!==i){const t=i.indexOf(e);-1!==t&&i.splice(t,1)}}dispatchEvent(t){const e=this._listeners;if(void 0===e)return;const n=e[t.type];if(void 0!==n){t.target=this;const e=n.slice(0);for(let n=0,i=e.length;n<i;n++)e[n].call(this,t);t.target=null}}}class Y{constructor(t,e,n,i){this.target=null,this.property="",this.parseBinding(t,e),this.valueSize=i;let r,s,a,o=Float64Array;switch(n){case"quaternion":r=Z,s=$,a=nt;break;case"string":case"bool":o=Array,r=Q,s=Q,a=it;break;default:r=J,s=tt,a=et}this.buffer=new o(4*i),this._mixBufferFunction=r,this._mixBufferFunctionAdditive=s,this._setIdentity=a,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}parseBinding(t,e){if((e=e.split(".")).length>1){let n=t[e[0]];for(let t=1;t<e.length-1;t++)n=n[e[t]];this.property=e[e.length-1],this.target=n}else this.property=e[0],this.target=t}saveOriginalState(){const t=this.buffer,e=this.valueSize,n=2*e;this.valueSize>1?this.target[this.property].toArray?this.target[this.property].toArray(t,n):function(t,e,n,i){for(let r=0;r<i;r++)t[n+r]=e[r]}(t,this.target[this.property],n,this.valueSize):this.target[this.property]=t[n];for(let i=e,r=n;i!==r;++i)t[i]=t[n+i%e];this._setIdentity(t,3*e,e,n),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.buffer,e=this.valueSize,n=2*e;for(let i=e,r=n;i!==r;++i)t[i]=t[n+i%e];this.apply()}accumulate(t){const e=this.buffer,n=this.valueSize,i=n;let r=this.cumulativeWeight;if(0===r){for(let t=0;t!==n;++t)e[i+t]=e[t];r=t}else{r+=t;const s=t/r;this._mixBufferFunction(e,i,0,s,n)}this.cumulativeWeight=r}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,i=3*n;0===this.cumulativeWeightAdditive&&this._setIdentity(e,i,n,2*n),this._mixBufferFunctionAdditive(e,i,0,t,n),this.cumulativeWeightAdditive+=t}apply(){const t=this.buffer,e=this.valueSize,n=this.cumulativeWeight,i=this.cumulativeWeightAdditive;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,n<1){const i=2*e;this._mixBufferFunction(t,e,i,1-n,e)}i>0&&this._mixBufferFunctionAdditive(t,e,3*e,1,e),this.valueSize>1?this.target[this.property].fromArray?this.target[this.property].fromArray(t,e):function(t,e,n,i){for(let r=0;r<i;r++)t[r]=e[n+r]}(this.target[this.property],t,e,this.valueSize):this.target[this.property]=t[e],this.target.isTransformUV&&(this.target.needsUpdate=!0)}}function Q(t,e,n,i,r){if(i>=.5)for(let i=0;i!==r;++i)t[e+i]=t[n+i]}function Z(t,e,n,i){d.slerpFlat(t,e,t,e,t,n,i)}const K=new Float64Array(4);function $(t,e,n,i){d.multiplyQuaternionsFlat(K,0,t,e,t,n),d.slerpFlat(t,e,t,e,K,0,i)}function J(t,e,n,i,r){const s=1-i;for(let a=0;a!==r;++a){const r=e+a;t[r]=t[r]*s+t[n+a]*i}}function tt(t,e,n,i,r){for(let s=0;s!==r;++s){const r=e+s;t[r]=t[r]+t[n+s]*i}}function et(t,e,n){for(let i=0;i<n;i++)t[e+i]=0}function nt(t,e){et(t,e,3),t[e+3]=1}function it(t,e,n,i){for(let r=0;r<n;r++)t[e+r]=t[i+r]}class rt{constructor(t,e,n){this.isLoading=!1,this.itemsLoaded=0,this.itemsTotal=0,this.urlModifier=void 0,this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n}itemStart(t){this.itemsTotal++,!1===this.isLoading&&void 0!==this.onStart&&this.onStart(t,this.itemsLoaded,this.itemsTotal),this.isLoading=!0}itemEnd(t){this.itemsLoaded++,void 0!==this.onProgress&&this.onProgress(t,this.itemsLoaded,this.itemsTotal),this.itemsLoaded===this.itemsTotal&&(this.isLoading=!1,void 0!==this.onLoad&&this.onLoad())}itemError(t){void 0!==this.onError&&this.onError(t)}resolveURL(t){return this.urlModifier?this.urlModifier(t):t}setURLModifier(t){return this.urlModifier=t,this}}const st=new rt;class at{constructor(t){this.manager=void 0!==t?t:st,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.requestHeader={}}load(t,e,n,i){}loadAsync(t,e){const n=this;return new Promise((function(i,r){n.load(t,i,e,r)}))}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setRequestHeader(t){return this.requestHeader=t,this}}class ot extends Error{constructor(t,e){super(t),this.response=e}}class lt{constructor(t=0,e=0){this.x=t,this.y=e}set(t=0,e=0){return this.x=t,this.y=e,this}lerpVectors(t,e,n){return this.subVectors(e,t).multiplyScalar(n).add(t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}getLength(){return Math.sqrt(this.getLengthSquared())}getLengthSquared(){return this.x*this.x+this.y*this.y}normalize(t=1){const e=t/(this.getLength()||1);return this.x*=e,this.y*=e,this}subtract(t,e=new lt){return e.set(this.x-t.x,this.y-t.y)}sub(t){return this.x-=t.x,this.y-=t.y,this}copy(t){return this.x=t.x,this.y=t.y,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}fromArray(t,n=0,i=!1){let r=t[n],s=t[n+1];return i&&(r=e.denormalize(r,t),s=e.denormalize(s,t)),this.x=r,this.y=s,this}toArray(t=[],n=0,i=!1){let r=this.x,s=this.y;return i&&(r=e.normalize(r,t),s=e.normalize(s,t)),t[n]=r,t[n+1]=s,t}add(t){return this.x+=t.x,this.y+=t.y,this}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}equals(t){return t.x===this.x&&t.y===this.y}clone(){return new lt(this.x,this.y)}}class ht{constructor(t,e){this.min=void 0!==t?t:new lt(1/0,1/0),this.max=void 0!==e?e:new lt(-1/0,-1/0)}set(t,e,n,i){this.min.set(t,e),this.max.set(n,i)}clone(){return(new ht).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}}class ct{constructor(t,e){this.min=void 0!==t?t:new r(1/0,1/0,1/0),this.max=void 0!==e?e:new r(-1/0,-1/0,-1/0)}set(t,e){this.min.copy(t),this.max.copy(e)}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByBox3(t){return this.min.min(t.min),this.max.max(t.max),this}setFromArray(t,e=3,n=0){let i=1/0,r=1/0,s=1/0,a=-1/0,o=-1/0,l=-1/0;for(let h=0,c=t.length;h<c;h+=e){const e=t[h+n],c=t[h+n+1],u=t[h+n+2];e<i&&(i=e),c<r&&(r=c),u<s&&(s=u),e>a&&(a=e),c>o&&(o=c),u>l&&(l=u)}return this.min.set(i,r,s),this.max.set(a,o,l),this}clampPoint(t,e){return e.copy(t).min(this.max).max(this.min)}distanceToPoint(t){return this.clampPoint(t,dt).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=.5*this.getSize(dt).getLength()),t}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}getCenter(t=new r){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t=new r){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}getPoints(t){const e=this.min.x,n=this.min.y,i=this.min.z,r=this.max.x,s=this.max.y,a=this.max.z;return t[0].set(r,s,a),t[1].set(r,n,a),t[2].set(r,n,i),t[3].set(r,s,i),t[4].set(e,s,a),t[5].set(e,n,a),t[6].set(e,n,i),t[7].set(e,s,i),t}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(ut[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),ut[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),ut[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),ut[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),ut[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),ut[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),ut[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),ut[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(ut)),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Tt),St.subVectors(this.max,Tt),pt.subVectors(t.a,Tt),ft.subVectors(t.b,Tt),_t.subVectors(t.c,Tt),mt.subVectors(ft,pt),gt.subVectors(_t,ft),vt.subVectors(pt,_t);let e=[0,-mt.z,mt.y,0,-gt.z,gt.y,0,-vt.z,vt.y,mt.z,0,-mt.x,gt.z,0,-gt.x,vt.z,0,-vt.x,-mt.y,mt.x,0,-gt.y,gt.x,0,-vt.y,vt.x,0];return!!Mt(e,pt,ft,_t,St)&&(e=[1,0,0,0,1,0,0,0,1],!!Mt(e,pt,ft,_t,St)&&(Et.crossVectors(mt,gt),e=[Et.x,Et.y,Et.z],Mt(e,pt,ft,_t,St)))}clone(){return(new ct).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}}const ut=[new r,new r,new r,new r,new r,new r,new r,new r],dt=new r,pt=new r,ft=new r,_t=new r,mt=new r,gt=new r,vt=new r,Tt=new r,St=new r,Et=new r,xt=new r;function Mt(t,e,n,i,r){for(let s=0,a=t.length-3;s<=a;s+=3){xt.fromArray(t,s);const a=r.x*Math.abs(xt.x)+r.y*Math.abs(xt.y)+r.z*Math.abs(xt.z),o=e.dot(xt),l=n.dot(xt),h=i.dot(xt);if(Math.max(-Math.max(o,l,h),Math.min(o,l,h))>a)return!1}return!0}class At{constructor(t,e,n){this.r=0,this.g=0,this.b=0,void 0===e&&void 0===n?this.setHex(t):this.setRGB(t,e,n)}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,n,i){if(t=e.euclideanModulo(t,1),n=e.clamp(n,0,1),i=e.clamp(i,0,1),0===n)this.r=this.g=this.b=i;else{const e=i<=.5?i*(1+n):i+n-i*n,r=2*i-e;this.r=yt(r,e,t+1/3),this.g=yt(r,e,t),this.b=yt(r,e,t-1/3)}return this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}convertSRGBToLinear(){return this.r=wt(this.r),this.g=wt(this.g),this.b=wt(this.b),this}convertLinearToSRGB(){return this.r=Rt(this.r),this.g=Rt(this.g),this.b=Rt(this.b),this}getHex(){return e.clamp(255*this.r,0,255)<<16^e.clamp(255*this.g,0,255)<<8^e.clamp(255*this.b,0,255)}lerp(t,e){return this.lerpColors(this,t,e)}lerpColors(t,n,i){return this.r=e.lerp(t.r,n.r,i),this.g=e.lerp(t.g,n.g,i),this.b=e.lerp(t.b,n.b,i),this}fromArray(t,n=0,i=!1){let r=t[n],s=t[n+1],a=t[n+2];return i&&(r=e.denormalize(r,t),s=e.denormalize(s,t),a=e.denormalize(a,t)),this.r=r,this.g=s,this.b=a,this}toArray(t=[],n=0,i=!1){let r=this.r,s=this.g,a=this.b;return i&&(r=e.normalize(r,t),s=e.normalize(s,t),a=e.normalize(a,t)),t[n]=r,t[n+1]=s,t[n+2]=a,t}}function yt(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+6*(e-t)*(2/3-n):t}function wt(t){return t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}function Rt(t){return t<.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class Lt{constructor(t=0,e=0,n=0,i=1){this.r=t,this.g=e,this.b=n,this.a=i}setRGBA(t,e,n,i){return this.r=t,this.g=e,this.b=n,this.a=i,this}clone(){return new Lt(this.r,this.g,this.b,this.a)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}fromArray(t,n=0,i=!1){let r=t[n],s=t[n+1],a=t[n+2],o=t[n+3];return i&&(r=e.denormalize(r,t),s=e.denormalize(s,t),a=e.denormalize(a,t),o=e.denormalize(o,t)),this.r=r,this.g=s,this.b=a,this.a=o,this}toArray(t=[],n=0,i=!1){let r=this.r,s=this.g,a=this.b,o=this.a;return i&&(r=e.normalize(r,t),s=e.normalize(s,t),a=e.normalize(a,t),o=e.normalize(o,t)),t[n]=r,t[n+1]=s,t[n+2]=a,t[n+3]=o,t}}const Ct=new a;class bt{constructor(t=0,e=0,n=0,i=bt.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this.onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this.onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this.onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this.onChangeCallback()}clone(){return new bt(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this.onChangeCallback(),this}set(t=0,e=0,n=0,i=this._order){return this._x=t,this._y=e,this._z=n,this._order=i,this.onChangeCallback(),this}setFromRotationMatrix(t,n=this._order,i=!0){const r=t.elements,s=r[0],a=r[4],o=r[8],l=r[1],h=r[5],c=r[9],u=r[2],d=r[6],p=r[10];return"XYZ"===n?(this._y=Math.asin(e.clamp(o,-1,1)),Math.abs(o)<.99999?(this._x=Math.atan2(-c,p),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(d,h),this._z=0)):"YXZ"===n?(this._x=Math.asin(-e.clamp(c,-1,1)),Math.abs(c)<.99999?(this._y=Math.atan2(o,p),this._z=Math.atan2(l,h)):(this._y=Math.atan2(-u,s),this._z=0)):"ZXY"===n?(this._x=Math.asin(e.clamp(d,-1,1)),Math.abs(d)<.99999?(this._y=Math.atan2(-u,p),this._z=Math.atan2(-a,h)):(this._y=0,this._z=Math.atan2(l,s))):"ZYX"===n?(this._y=Math.asin(-e.clamp(u,-1,1)),Math.abs(u)<.99999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-a,h))):"YZX"===n?(this._z=Math.asin(e.clamp(l,-1,1)),Math.abs(l)<.99999?(this._x=Math.atan2(-c,h),this._y=Math.atan2(-u,s)):(this._x=0,this._y=Math.atan2(o,p))):"XZY"===n?(this._z=Math.asin(-e.clamp(a,-1,1)),Math.abs(a)<.99999?(this._x=Math.atan2(d,h),this._y=Math.atan2(o,s)):(this._x=Math.atan2(-c,p),this._y=0)):console.warn("given unsupported order: "+n),this._order=n,!0===i&&this.onChangeCallback(),this}setFromQuaternion(t,e,n){return t.toMatrix4(Ct),this.setFromRotationMatrix(Ct,e,n)}onChange(t){return this.onChangeCallback=t,this}onChangeCallback(){}}bt.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"],bt.DefaultOrder="XYZ";class Pt{constructor(){this.elements=[1,0,0,0,1,0,0,0,1]}set(t,e,n,i,r,s,a,o,l){const h=this.elements;return h[0]=t,h[3]=e,h[6]=n,h[1]=i,h[4]=r,h[7]=s,h[2]=a,h[5]=o,h[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1)}isIdentity(){const t=this.elements;return 1===t[0]&&0===t[3]&&0===t[6]&&0===t[1]&&1===t[4]&&0===t[7]&&0===t[2]&&0===t[5]&&1===t[8]}inverse(){return this.getInverse(this)}getInverse(t){const e=t.elements,n=this.elements,i=e[0],r=e[1],s=e[2],a=e[3],o=e[4],l=e[5],h=e[6],c=e[7],u=e[8],d=u*o-l*c,p=l*h-u*a,f=c*a-o*h,_=i*d+r*p+s*f;if(0===_)return console.warn("Matrix3: .getInverse() can not invert matrix, determinant is 0"),this.identity();const m=1/_;return n[0]=d*m,n[1]=(s*c-u*r)*m,n[2]=(l*r-s*o)*m,n[3]=p*m,n[4]=(u*i-s*h)*m,n[5]=(s*a-l*i)*m,n[6]=f*m,n[7]=(r*h-c*i)*m,n[8]=(o*i-r*a)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}equals(t){const e=this.elements,n=t.elements;for(let t=0;t<9;t++)if(e[t]!==n[t])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return(new Pt).fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,r=this.elements,s=n[0],a=n[3],o=n[6],l=n[1],h=n[4],c=n[7],u=n[2],d=n[5],p=n[8],f=i[0],_=i[3],m=i[6],g=i[1],v=i[4],T=i[7],S=i[2],E=i[5],x=i[8];return r[0]=s*f+a*g+o*S,r[3]=s*_+a*v+o*E,r[6]=s*m+a*T+o*x,r[1]=l*f+h*g+c*S,r[4]=l*_+h*v+c*E,r[7]=l*m+h*T+c*x,r[2]=u*f+d*g+p*S,r[5]=u*_+d*v+p*E,r[8]=u*m+d*T+p*x,this}transform(t,e,n,i,r,s,a){const o=this.elements,l=Math.cos(r),h=Math.sin(r);return o[0]=l*n,o[3]=-h*i,o[6]=t,o[1]=h*n,o[4]=l*i,o[7]=e,o[2]=0,o[5]=0,o[8]=1,(s||a)&&(o[6]-=s*o[0]+a*o[3],o[7]-=s*o[1]+a*o[4]),this}setUvTransform(t,e,n,i,r,s,a){const o=Math.cos(r),l=Math.sin(r);return this.set(n*o,n*l,-n*(o*s+l*a)+s+t,-i*l,i*o,-i*(-l*s+o*a)+a+e,0,0,1)}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10])}extractBasis(t,e,n){const i=this.elements;return t.fromArray(i),e.fromArray(i,3),n.fromArray(i,6),this}}const Nt=new r,Dt=new r,Ft=new Pt;class It{constructor(t=new r(1,0,0),e=0){this.normal=t,this.constant=e}static intersectPlanes(t,e,n,i){return Ft.set(t.normal.x,t.normal.y,t.normal.z,e.normal.x,e.normal.y,e.normal.z,n.normal.x,n.normal.y,n.normal.z),i.set(-t.constant,-e.constant,-n.constant),i.applyMatrix3(Ft.inverse()),i}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=Nt.subVectors(n,e).cross(Dt.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}normalize(){const t=1/this.normal.getLength();return this.normal.multiplyScalar(t),this.constant*=t,this}distanceToPoint(t){return this.normal.dot(t)+this.constant}projectPoint(t,e=new r){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}mirrorPoint(t,e=new r){const n=this.distanceToPoint(t);return e.copy(t).addScaledVector(this.normal,-2*n)}coplanarPoint(t=new r){return t.copy(this.normal).multiplyScalar(-this.constant)}clone(){return(new It).copy(this)}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}applyMatrix4(t,e){const n=e||Ft.setFromMatrix4(t).inverse().transpose(),i=this.coplanarPoint(Nt).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}}const Ot=new r,Ut=new Pt;class Bt{constructor(t=new It,e=new It,n=new It,i=new It,r=new It,s=new It){this.planes=[t,e,n,i,r,s]}set(t,e,n,i,r,s){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(n),a[3].copy(i),a[4].copy(r),a[5].copy(s),this}setFromMatrix(t){const e=this.planes,n=t.elements,i=n[0],r=n[1],s=n[2],a=n[3],o=n[4],l=n[5],h=n[6],c=n[7],u=n[8],d=n[9],p=n[10],f=n[11],_=n[12],m=n[13],g=n[14],v=n[15];return e[0].setComponents(a-i,c-o,f-u,v-_).normalize(),e[1].setComponents(a+i,c+o,f+u,v+_).normalize(),e[2].setComponents(a+r,c+l,f+d,v+m).normalize(),e[3].setComponents(a-r,c-l,f-d,v-m).normalize(),e[4].setComponents(a-s,c-h,f-p,v-g).normalize(),e[5].setComponents(a+s,c+h,f+p,v+g).normalize(),this}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let t=0;t<6;t++){if(e[t].distanceToPoint(n)<i)return!1}return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(Ot.x=i.normal.x>0?t.max.x:t.min.x,Ot.y=i.normal.y>0?t.max.y:t.min.y,Ot.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(Ot)<0)return!1}return!0}applyMatrix4(t){const e=this.planes,n=Ut.setFromMatrix4(t).inverse().transpose();for(let i=0;i<6;i++)e[i].applyMatrix4(t,n);return this}clone(){return(new this.constructor).copy(this)}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}}const zt=new r,Gt=new r,Ht=new r,Vt=new r,kt=new r;class Wt{constructor(t=new r,e=new r(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}at(t,e=new r){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}distanceSqToPoint(t){const e=zt.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(zt.copy(this.direction).multiplyScalar(e).add(this.origin),zt.distanceToSquared(t))}distanceToPlane(t){const e=t.normal.dot(this.direction);if(0===e)return 0===t.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e=new r){const n=this.distanceToPlane(t);return null===n?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);if(0===e)return!0;return t.normal.dot(this.direction)*e<0}intersectsBox(t){return null!==this.intersectBox(t,zt)}intersectBox(t,e){let n,i,r,s,a,o;const l=1/this.direction.x,h=1/this.direction.y,c=1/this.direction.z,u=this.origin;return l>=0?(n=(t.min.x-u.x)*l,i=(t.max.x-u.x)*l):(n=(t.max.x-u.x)*l,i=(t.min.x-u.x)*l),h>=0?(r=(t.min.y-u.y)*h,s=(t.max.y-u.y)*h):(r=(t.max.y-u.y)*h,s=(t.min.y-u.y)*h),n>s||r>i?null:((r>n||n!=n)&&(n=r),(s<i||i!=i)&&(i=s),c>=0?(a=(t.min.z-u.z)*c,o=(t.max.z-u.z)*c):(a=(t.max.z-u.z)*c,o=(t.min.z-u.z)*c),n>o||a>i?null:((a>n||n!=n)&&(n=a),(o<i||i!=i)&&(i=o),i<0?null:this.at(n>=0?n:i,e)))}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}intersectSphere(t,e){zt.subVectors(t.center,this.origin);const n=zt.dot(this.direction),i=zt.dot(zt)-n*n,r=t.radius*t.radius;if(i>r)return null;const s=Math.sqrt(r-i),a=n-s,o=n+s;return a<0&&o<0?null:a<0?this.at(o,e):this.at(a,e)}intersectTriangle(t,e,n,i,r){Ht.subVectors(e,t),Vt.subVectors(n,t),kt.crossVectors(Ht,Vt);let s,a=this.direction.dot(kt);if(a>0){if(i)return null;s=1}else{if(!(a<0))return null;s=-1,a=-a}Gt.subVectors(this.origin,t);const o=s*this.direction.dot(Vt.crossVectors(Gt,Vt));if(o<0)return null;const l=s*this.direction.dot(Ht.cross(Gt));if(l<0)return null;if(o+l>a)return null;const h=-s*Gt.dot(kt);return h<0?null:this.at(h/a,r)}}const Xt=new ct,qt=new r,jt=new r;class Yt{constructor(t=new r,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;void 0!==e?n.copy(e):Xt.setFromPoints(t).getCenter(n);let i=0;for(let e=0,r=t.length;e<r;e++)i=Math.max(i,n.distanceToSquared(t[e]));return this.radius=Math.sqrt(i),this}setFromArray(t,e=3,n=0){const i=this.center;Xt.setFromArray(t,e).getCenter(i);let r=0;for(let s=0,a=t.length;s<a;s+=e)qt.fromArray(t,s+n),r=Math.max(r,i.distanceToSquared(qt));return this.radius=Math.sqrt(r),this}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;qt.subVectors(t,this.center);const e=qt.getLengthSquared();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=.5*(t-this.radius);this.center.addScaledVector(qt,n/t),this.radius+=n}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)?this.radius=Math.max(this.radius,t.radius):(jt.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(qt.addVectors(t.center,jt)),this.expandByPoint(qt.addVectors(t.center,jt))),this)}clone(){return(new Yt).copy(this)}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}}class Qt{constructor(t=1,e=0,n=0){this.radius=t,this.phi=e,this.theta=n}set(t,e,n){return this.radius=t,this.phi=e,this.theta=n,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}clone(){return(new Qt).copy(this)}makeSafe(){const t=1e-6;return this.phi=e.clamp(this.phi,t,Math.PI-t),this}setFromVector3(t){return this.radius=t.getLength(),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t.x,t.z),this.phi=Math.acos(e.clamp(t.y/this.radius,-1,1))),this}}class Zt{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new r)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.282095),e.addScaledVector(s[1],.488603*i),e.addScaledVector(s[2],.488603*r),e.addScaledVector(s[3],.488603*n),e.addScaledVector(s[4],n*i*1.092548),e.addScaledVector(s[5],i*r*1.092548),e.addScaledVector(s[6],.315392*(3*r*r-1)),e.addScaledVector(s[7],n*r*1.092548),e.addScaledVector(s[8],.546274*(n*n-i*i)),e}getIrradianceAt(t,e){const n=t.x,i=t.y,r=t.z,s=this.coefficients;return e.copy(s[0]).multiplyScalar(.886227),e.addScaledVector(s[1],1.023328*i),e.addScaledVector(s[2],1.023328*r),e.addScaledVector(s[3],1.023328*n),e.addScaledVector(s[4],.858086*n*i),e.addScaledVector(s[5],.858086*i*r),e.addScaledVector(s[6],.743125*r*r-.247708),e.addScaledVector(s[7],.858086*n*r),e.addScaledVector(s[8],.429043*(n*n-i*i)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerpVectors(this.coefficients[n],t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(t,e+3*i);return this}toArray(t=[],e=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(t,e+3*i);return t}static getBasisAt(t,e){const n=t.x,i=t.y,r=t.z;e[0]=.282095,e[1]=.488603*i,e[2]=.488603*r,e[3]=.488603*n,e[4]=1.092548*n*i,e[5]=1.092548*i*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*n*r,e[8]=.546274*(n*n-i*i)}}const Kt=new r,$t=new r,Jt=new r,te=new r;class ee{constructor(t=new r,e=new r,n=new r){this.a=t,this.b=e,this.c=n}static normal(t,e,n,i){const s=i||new r;s.subVectors(n,e),Kt.subVectors(t,e),s.cross(Kt);const a=s.getLengthSquared();return a>0?s.multiplyScalar(1/Math.sqrt(a)):s.set(0,0,0)}static barycoordFromPoint(t,e,n,i,s){Kt.subVectors(i,e),$t.subVectors(n,e),Jt.subVectors(t,e);const a=Kt.dot(Kt),o=Kt.dot($t),l=Kt.dot(Jt),h=$t.dot($t),c=$t.dot(Jt),u=a*h-o*o,d=s||new r;if(0===u)return d.set(-2,-1,-1);const p=1/u,f=(h*l-o*c)*p,_=(a*c-o*l)*p;return d.set(1-f-_,_,f)}static containsPoint(t,e,n,i){return this.barycoordFromPoint(t,e,n,i,te),te.x>=0&&te.y>=0&&te.x+te.y<=1}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}}class ne{constructor(t=0,e=0,n=0,i=1){this.x=t,this.y=e,this.z=n,this.w=i}lerpVectors(t,e,n){return this.subVectors(e,t).multiplyScalar(n).add(t)}set(t=0,e=0,n=0,i=1){return this.x=t,this.y=e,this.z=n,this.w=i,this}normalize(){return this.multiplyScalar(1/(this.getLength()||1))}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}getLengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}getLength(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}getManhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,r=this.w,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*i+s[12]*r,this.y=s[1]*e+s[5]*n+s[9]*i+s[13]*r,this.z=s[2]*e+s[6]*n+s[10]*i+s[14]*r,this.w=s[3]*e+s[7]*n+s[11]*i+s[15]*r,this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}fromArray(t,n=0,i=!1){let r=t[n],s=t[n+1],a=t[n+2],o=t[n+3];return i&&(r=e.denormalize(r,t),s=e.denormalize(s,t),a=e.denormalize(a,t),o=e.denormalize(o,t)),this.x=r,this.y=s,this.z=a,this.w=o,this}toArray(t=[],n=0,i=!1){let r=this.x,s=this.y,a=this.z,o=this.w;return i&&(r=e.normalize(r,t),s=e.normalize(s,t),a=e.normalize(a,t),o=e.normalize(o,t)),t[n]=r,t[n+1]=s,t[n+2]=a,t[n+3]=o,t}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}clone(){return new ne(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=void 0!==t.w?t.w:1,this}}function ie(t){const e={};for(const n in t){const i=t[n];Array.isArray(i)||ArrayBuffer.isView(i)?e[n]=i.slice():e[n]=i}return e}function re(t){const e=Array.isArray(t)?[]:{};if(t&&"object"==typeof t)for(const n in t)t.hasOwnProperty(n)&&(e[n]=t[n]&&"object"==typeof t[n]?re(t[n]):t[n]);return e}let se=0;const ae=new a;class oe{constructor(){this.id=se++,this.uuid=e.generateUUID(),this.name="",this.position=new r,this.scale=new r(1,1,1),this.euler=new bt,this.quaternion=new d;const t=this.euler,n=this.quaternion;t.onChange((function(){n.setFromEuler(t,!1)})),n.onChange((function(){t.setFromQuaternion(n,void 0,!1)})),this.matrix=new a,this.worldMatrix=new a,this.children=new Array,this.parent=null,this.castShadow=!1,this.receiveShadow=!1,this.shadowType=z.PCF3_SOFT,this.frustumCulled=!0,this.visible=!0,this.renderOrder=0,this.renderLayer=0,this.renderable=!0,this.userData={},this.matrixAutoUpdate=!0,this.matrixNeedsUpdate=!0,this.worldMatrixNeedsUpdate=!0}onBeforeRender(){}onAfterRender(){}add(t){t!==this?(null!==t.parent&&t.parent.remove(t),t.parent=this,this.children.push(t),t.worldMatrixNeedsUpdate=!0):console.error("Object3D.add: object can't be added as a child of itself.",t)}remove(t){const e=this.children.indexOf(t);-1!==e&&(t.parent=null,this.children.splice(e,1),t.worldMatrixNeedsUpdate=!0)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const i=this.children[n].getObjectByProperty(t,e);if(void 0!==i)return i}}updateMatrix(t){if((this.matrixAutoUpdate||this.matrixNeedsUpdate)&&(this.matrix.transform(this.position,this.scale,this.quaternion),this.matrixNeedsUpdate=!1,this.worldMatrixNeedsUpdate=!0),this.worldMatrixNeedsUpdate||t){if(this.worldMatrix.copy(this.matrix),this.parent){const t=this.parent.worldMatrix;this.worldMatrix.premultiply(t)}this.worldMatrixNeedsUpdate=!1,t=!0}const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrix(t)}getWorldDirection(t=new r){const e=this.worldMatrix.elements;return t.set(e[8],e[9],e[10]).normalize()}lookAt(t,e){ae.lookAtRH(t,this.position,e),this.quaternion.setFromRotationMatrix(ae)}raycast(t,e){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}clone(t){return(new this.constructor).copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.position.copy(t.position),this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.worldMatrix.copy(t.worldMatrix),this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.shadowType=t.shadowType,this.frustumCulled=t.frustumCulled,this.visible=t.visible,this.renderOrder=t.renderOrder,this.renderLayer=t.renderLayer,this.renderable=t.renderable,this.userData=re(t.userData),!0===e)for(let e=0;e<t.children.length;e++){const n=t.children[e];this.add(n.clone())}return this}}class le extends oe{constructor(t=16777215,e=1){super(),this.color=new At(t),this.intensity=e,this.groupMask=1}lookAt(t,e){he.lookAtRH(this.position,t,e),this.quaternion.setFromRotationMatrix(he)}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this.groupMask=t.groupMask,this}}le.prototype.isLight=!0;const he=new a;class ce extends le{constructor(t,e,n=10,i=10){super(t,e),this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}}ce.prototype.isRectAreaLight=!0,ce.LTC1=null,ce.LTC2=null;class ue extends j{constructor(){super(),this.id=de++,this.lights=[],this.ambient=new Float32Array([0,0,0]),this.sh=new Float32Array(27),this.hemisphere=[],this.directional=[],this.directionalShadow=[],this.directionalShadowMap=[],this.directionalShadowDepthMap=[],this.directionalShadowMatrix=new Float32Array(0),this.point=[],this.pointShadow=[],this.pointShadowMap=[],this.pointShadowMatrix=new Float32Array(0),this.spot=[],this.spotShadow=[],this.spotShadowMap=[],this.spotShadowDepthMap=[],this.spotShadowMatrix=new Float32Array(0),this.rectArea=[],this.LTC1=null,this.LTC2=null,this.useAmbient=!1,this.useSphericalHarmonics=!1,this.hemisNum=0,this.directsNum=0,this.pointsNum=0,this.spotsNum=0,this.rectAreaNum=0,this.directShadowNum=0,this.pointShadowNum=0,this.spotShadowNum=0,this.totalNum=0,this.shadowsNum=0,this.version=0}begin(){this.totalNum=0,this.shadowsNum=0}push(t,e){this.lights[this.totalNum++]=t,e&&this.shadowsNum++}end(t){this.lights.length=this.totalNum,this._setupCache(t),this.version++}dispose(){this.dispatchEvent({type:"dispose"})}_setupCache(t){for(let t=0;t<3;t++)this.ambient[t]=0;for(let t=0;t<this.sh.length;t++)this.sh[t]=0;this.useAmbient=!1,this.useSphericalHarmonics=!1,this.hemisNum=0,this.directsNum=0,this.pointsNum=0,this.spotsNum=0,this.rectAreaNum=0,this.directShadowNum=0,this.pointShadowNum=0,this.spotShadowNum=0,this.LTC1=null,this.LTC2=null;for(let e=0,n=this.lights.length;e<n;e++){const n=this.lights[e];n.isAmbientLight?this._doAddAmbientLight(n):n.isHemisphereLight?this._doAddHemisphereLight(n,t):n.isDirectionalLight?this._doAddDirectLight(n,t):n.isPointLight?this._doAddPointLight(n,t):n.isSpotLight?this._doAddSpotLight(n,t):n.isSphericalHarmonicsLight?this._doAddSphericalHarmonicsLight(n):n.isRectAreaLight&&this._doAddRectAreaLight(n,t)}const e=this.directShadowNum;if(e>0){this.directionalShadowMap.length=e,this.directionalShadowDepthMap.length=e,_e.length=e,this.directionalShadowMatrix.length!==16*e&&(this.directionalShadowMatrix=new Float32Array(16*e));for(let t=0;t<e;t++)_e[t].toArray(this.directionalShadowMatrix,16*t)}const n=this.pointShadowNum;if(n>0){this.pointShadowMap.length=n,me.length=n,this.pointShadowMatrix.length!==16*n&&(this.pointShadowMatrix=new Float32Array(16*n));for(let t=0;t<n;t++)me[t].toArray(this.pointShadowMatrix,16*t)}const i=this.spotShadowNum;if(i>0){this.spotShadowMap.length=i,this.spotShadowDepthMap.length=i,ge.length=i,this.spotShadowMatrix.length!==16*i&&(this.spotShadowMatrix=new Float32Array(16*i));for(let t=0;t<i;t++)ge[t].toArray(this.spotShadowMatrix,16*t)}this.rectAreaNum>0&&(this.LTC1=ce.LTC1,this.LTC2=ce.LTC2)}_doAddAmbientLight(t){const e=t.intensity,n=t.color;this.ambient[0]+=n.r*e,this.ambient[1]+=n.g*e,this.ambient[2]+=n.b*e,this.useAmbient=!0}_doAddSphericalHarmonicsLight(t){const e=t.intensity,n=t.sh.coefficients;for(let t=0;t<n.length;t+=1)this.sh[3*t]+=n[t].x*e,this.sh[3*t+1]+=n[t].y*e,this.sh[3*t+2]+=n[t].z*e;this.useSphericalHarmonics=!0}_doAddHemisphereLight(t,e){const n=t.intensity,i=t.color,r=t.groundColor,s=e.useAnchorMatrix,a=Te(t);a.skyColor[0]=i.r*n,a.skyColor[1]=i.g*n,a.skyColor[2]=i.b*n,a.groundColor[0]=r.r*n,a.groundColor[1]=r.g*n,a.groundColor[2]=r.b*n;const o=t.worldMatrix.elements,l=pe.set(o[4],o[5],o[6]).normalize();s&&l.transformDirection(e.anchorMatrixInverse),l.toArray(a.direction),this.hemisphere[this.hemisNum++]=a}_doAddDirectLight(t,e){const n=t.intensity,i=t.color,r=e.useAnchorMatrix,s=Te(t);s.color[0]=i.r*n,s.color[1]=i.g*n,s.color[2]=i.b*n;const a=t.getWorldDirection(pe);if(r&&a.transformDirection(e.anchorMatrixInverse),a.multiplyScalar(-1).toArray(s.direction),t.castShadow){const n=t.shadow,i=Ee(t);i.shadowBias[0]=n.bias,i.shadowBias[1]=n.normalBias,i.shadowMapSize[0]=n.mapSize.x,i.shadowMapSize[1]=n.mapSize.y,i.shadowParams[0]=n.radius,i.shadowParams[1]=n.frustumEdgeFalloff,this.directionalShadow[this.directShadowNum++]=i,n.update(t),n.updateMatrix(),r&&n.matrix.multiply(e.anchorMatrix),this.directionalShadowMap[this.directsNum]=n.map,this.directionalShadowDepthMap[this.directsNum]=n.depthMap,_e[this.directsNum]=n.matrix}this.directional[this.directsNum++]=s}_doAddPointLight(t,e){const n=t.intensity,i=t.color,r=t.distance,s=t.decay,a=e.useAnchorMatrix,o=Te(t);o.color[0]=i.r*n,o.color[1]=i.g*n,o.color[2]=i.b*n,o.distance=r,o.decay=s;const l=pe.setFromMatrixPosition(t.worldMatrix);if(a&&l.applyMatrix4(e.anchorMatrixInverse),o.position[0]=l.x,o.position[1]=l.y,o.position[2]=l.z,t.castShadow){const e=t.shadow,n=Ee(t);n.shadowBias[0]=e.bias,n.shadowBias[1]=e.normalBias,n.shadowMapSize[0]=e.mapSize.x,n.shadowMapSize[1]=e.mapSize.y,n.shadowParams[0]=e.radius,n.shadowParams[1]=0,n.shadowCameraRange[0]=e.cameraNear,n.shadowCameraRange[1]=e.cameraFar,this.pointShadow[this.pointShadowNum++]=n,e.update(t,0),e.matrix.makeTranslation(-l.x,-l.y,-l.z),this.pointShadowMap[this.pointsNum]=e.map,me[this.pointsNum]=e.matrix}this.point[this.pointsNum++]=o}_doAddSpotLight(t,e){const n=t.intensity,i=t.color,r=t.distance,s=t.decay,a=e.useAnchorMatrix,o=Te(t);o.color[0]=i.r*n,o.color[1]=i.g*n,o.color[2]=i.b*n,o.distance=r,o.decay=s;const l=pe.setFromMatrixPosition(t.worldMatrix);a&&l.applyMatrix4(e.anchorMatrixInverse),o.position[0]=l.x,o.position[1]=l.y,o.position[2]=l.z;const h=t.getWorldDirection(pe);a&&h.transformDirection(e.anchorMatrixInverse),h.multiplyScalar(-1).toArray(o.direction);const c=Math.cos(t.angle),u=Math.cos(t.angle*(1-t.penumbra));if(o.coneCos=c,o.penumbraCos=u,t.castShadow){const n=t.shadow,i=Ee(t);i.shadowBias[0]=n.bias,i.shadowBias[1]=n.normalBias,i.shadowMapSize[0]=n.mapSize.x,i.shadowMapSize[1]=n.mapSize.y,i.shadowParams[0]=n.radius,i.shadowParams[1]=n.frustumEdgeFalloff,this.spotShadow[this.spotShadowNum++]=i,n.update(t),n.updateMatrix(),a&&n.matrix.multiply(e.anchorMatrix),this.spotShadowMap[this.spotsNum]=n.map,this.spotShadowDepthMap[this.spotsNum]=n.depthMap,ge[this.spotsNum]=n.matrix}this.spot[this.spotsNum++]=o}_doAddRectAreaLight(t,e){const n=t.intensity,i=t.color,r=t.height,s=t.width,a=e.useAnchorMatrix,o=Te(t);o.color[0]=i.r*n,o.color[1]=i.g*n,o.color[2]=i.b*n;const l=pe.setFromMatrixPosition(t.worldMatrix);a&&l.applyMatrix4(e.anchorMatrixInverse),o.position[0]=l.x,o.position[1]=l.y,o.position[2]=l.z,fe.copy(t.worldMatrix),a&&fe.premultiply(e.anchorMatrixInverse),fe.extractRotation(fe);const h=pe.set(.5*s,0,0);h.applyMatrix4(fe),o.halfWidth[0]=h.x,o.halfWidth[1]=h.y,o.halfWidth[2]=h.z;const c=pe.set(0,.5*r,0);c.applyMatrix4(fe),o.halfHeight[0]=c.x,o.halfHeight[1]=c.y,o.halfHeight[2]=c.z,this.rectArea[this.rectAreaNum++]=o}}let de=0;const pe=new r,fe=new a,_e=[],me=[],ge=[],ve=new WeakMap;function Te(t){if(ve.has(t))return ve.get(t);let e;return t.isHemisphereLight?e={direction:new Float32Array(3),skyColor:new Float32Array([0,0,0]),groundColor:new Float32Array([0,0,0])}:t.isDirectionalLight?e={direction:new Float32Array(3),color:new Float32Array([0,0,0])}:t.isPointLight?e={position:new Float32Array(3),color:new Float32Array([0,0,0]),distance:0,decay:0}:t.isSpotLight?e={position:new Float32Array(3),direction:new Float32Array(3),color:new Float32Array([0,0,0]),distance:0,coneCos:0,penumbraCos:0,decay:0}:t.isRectAreaLight&&(e={position:new Float32Array(3),color:new Float32Array([0,0,0]),halfWidth:new Float32Array(3),halfHeight:new Float32Array(3)}),ve.set(t,e),e}const Se=new WeakMap;function Ee(t){if(Se.has(t))return Se.get(t);let e;return t.isDirectionalLight?e={shadowBias:new Float32Array(2),shadowMapSize:new Float32Array(2),shadowParams:new Float32Array(2)}:t.isPointLight?e={shadowBias:new Float32Array(2),shadowMapSize:new Float32Array(2),shadowParams:new Float32Array(2),shadowCameraRange:new Float32Array(2)}:t.isSpotLight&&(e={shadowBias:new Float32Array(2),shadowMapSize:new Float32Array(2),shadowParams:new Float32Array(2)}),Se.set(t,e),e}class xe{constructor(){this.lightsArray=[],this.shadowsNum=0,this.groupList=[],this.groupList.push(new ue),this._locked=!1}getGroup(t){return this.groupList[t]}setMaxGroupCount(t){t=Math.max(1,t);const e=this.groupList,n=e.length;if(t<n){for(let i=t;i<n;i++)e[i].dispose();e.length=t}else if(t>n)for(let i=n;i<t;i++)e.push(new ue)}begin(t){this._locked=t,t||(this.lightsArray.length=0,this.shadowsNum=0)}collect(t){this._locked||(this.lightsArray.push(t),Ae(t)&&this.shadowsNum++)}end(t){if(this._locked)return;const e=this.lightsArray,n=this.shadowsNum,i=this.groupList;let r,s;for(e.sort(Me),r=0,s=i.length;r<s;r++)i[r].begin();for(r=0,s=e.length;r<s;r++)this._distribute(e[r],r<n);for(r=0,s=i.length;r<s;r++)i[r].end(t)}_distribute(t,e){const n=t.groupMask,i=this.groupList;if(1===i.length&&1&n)i[0].push(t,e);else for(let r=0,s=i.length;r<s;r++){const s=1<<r;if(n<s)break;n&s&&i[r].push(t,e)}}}function Me(t,e){const n=Ae(t)?1:0;return(Ae(e)?1:0)-n}function Ae(t){return t.shadow&&t.castShadow}class ye{constructor(t){this.id=t,this.opaque=[],this.opaqueCount=0,this.transparent=[],this.transparentCount=0,this._cache=[],this._cacheIndex=0,this._lastCacheIndex=0,this.opaqueSortCompareFn=we,this.transparentSortCompareFn=Re}begin(){this._cacheIndex=0,this.opaqueCount=0,this.transparentCount=0}end(){this.opaque.length=this.opaqueCount,this.transparent.length=this.transparentCount;const t=this._cacheIndex,e=this._lastCacheIndex;if(e>t){const n=this._cache;for(let i=t;i<e;i++){const t=n[i];t.object=null,t.geometry=null,t.material=null,t.group=null}}this._lastCacheIndex=t}addRenderable(t,e,n,i,r){const s=this._cache;let a=s[this._cacheIndex];void 0===a?(a={object:t,geometry:e,material:n,z:i,renderOrder:t.renderOrder,group:r},s[this._cacheIndex]=a):(a.object=t,a.geometry=e,a.material=n,a.z=i,a.renderOrder=t.renderOrder,a.group=r),n.transparent?(this.transparent[this.transparentCount]=a,this.transparentCount++):(this.opaque[this.opaqueCount]=a,this.opaqueCount++),this._cacheIndex++}sort(){this.opaque.sort(this.opaqueSortCompareFn),Le(this.transparent,0,this.transparent.length,this.transparentSortCompareFn)}}function we(t,e){return t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.id-e.id}function Re(t,e){return t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.material.id!==e.material.id?t.material.id-e.material.id:t.id-e.id}function Le(t,e,n,i){for(;;){if(n-e<=10)return void Ce(t,e,n,i);const r=e+n>>1;let s=t[e],a=t[n-1],o=t[r];if(i(s,a)>0){const t=s;s=a,a=t}if(i(s,o)>=0){const t=s;s=o,o=a,a=t}else{if(i(a,o)>0){const t=a;a=o,o=t}}t[e]=s,t[n-1]=o;const l=a;let h=e+1,c=n-1;t[r]=t[h],t[h]=l;t:for(let e=h+1;e<c;e++){let n=t[e],r=i(n,l);if(r<0)t[e]=t[h],t[h]=n,h++;else if(r>0){do{if(c--,c==e)break t;r=i(t[c],l)}while(r>0);t[e]=t[c],t[c]=n,r<0&&(n=t[e],t[e]=t[h],t[h]=n,h++)}}n-c<h-e?(Le(t,c,n,i),n=h):(Le(t,e,h,i),e=c)}}function Ce(t,e,n,i){for(let r=e+1;r<n;r++){let n;const s=t[r];for(n=r-1;n>=e;n--){const e=t[n];if(!(i(e,s)>0))break;t[n+1]=e}t[n+1]=s}}class be{constructor(){this.layerMap=new Map,this.layerList=[],this.skeletons=new Set,this._lastLayer=this.createLayer(0)}begin(){for(let t=0,e=this.layerList.length;t<e;t++)this.layerList[t].begin();this.skeletons.clear()}end(){for(let t=0,e=this.layerList.length;t<e;t++)this.layerList[t].end(),this.layerList[t].sort()}push(t,e){t.skeleton&&this.skeletons.add(t.skeleton),Pe.setFromMatrixPosition(t.worldMatrix).applyMatrix4(e.projectionViewMatrix);const n=Pe.z,i=t.renderLayer||0;let r=this._lastLayer;if(r.id!==i&&(r=this.layerMap.get(i),r||(r=this.createLayer(i)),this._lastLayer=r),Array.isArray(t.material)){const e=t.geometry.groups;for(let i=0;i<e.length;i++){const s=e[i],a=t.material[s.materialIndex];a&&r.addRenderable(t,t.geometry,a,n,s)}}else r.addRenderable(t,t.geometry,t.material,n)}setLayer(t,e){this.layerMap.set(t,e),this.layerList.push(e),this.layerList.sort(Ne)}createLayer(t){const e=new ye(t);return this.setLayer(t,e),e}getLayer(t){return this.layerMap.get(t)}removeLayer(t){const e=this.layerMap.get(t);if(e){this.layerMap.delete(t);const n=this.layerList.indexOf(e);-1!==n&&this.layerList.splice(n,1),this._lastLayer===t&&(this._lastLayer=null)}}}const Pe=new ne;function Ne(t,e){return t.id-e.id}const De=new It;let Fe=0;class Ie{constructor(){this.id=Fe++,this.version=0,this.useAnchorMatrix=!1,this.anchorMatrix=new a,this.anchorMatrixInverse=new a,this.disableShadowSampler=!1,this.logarithmicDepthBuffer=!1,this.fog=null,this.environment=null,this.envDiffuseIntensity=1,this.envSpecularIntensity=1,this.clippingPlanesData=new Float32Array([]),this.numClippingPlanes=0}update(t){this.useAnchorMatrix=!t.anchorMatrix.isIdentity(),this.anchorMatrix.copy(t.anchorMatrix),this.anchorMatrixInverse.getInverse(t.anchorMatrix),this.disableShadowSampler=t.disableShadowSampler,this.logarithmicDepthBuffer=t.logarithmicDepthBuffer,this.fog=t.fog,this.environment=t.environment,this.envDiffuseIntensity=t.envDiffuseIntensity,this.envSpecularIntensity=t.envSpecularIntensity,this.clippingPlanesData.length<4*t.clippingPlanes.length&&(this.clippingPlanesData=new Float32Array(4*t.clippingPlanes.length)),this.setClippingPlanesData(t.clippingPlanes,this.clippingPlanesData),this.numClippingPlanes=t.clippingPlanes.length,this.version++}setClippingPlanesData(t,e){for(let n=0;n<t.length;n++)De.copy(t[n]),this.useAnchorMatrix&&De.applyMatrix4(this.anchorMatrixInverse),e[4*n+0]=De.normal.x,e[4*n+1]=De.normal.y,e[4*n+2]=De.normal.z,e[4*n+3]=De.constant;return e}}let Oe=0;class Ue{constructor(t,e){this.scene=t,this.lighting=e,this.camera={id:Oe++,version:0,near:0,far:0,position:new r,logDepthCameraNear:0,logDepthBufFC:0,viewMatrix:new a,projectionMatrix:new a,projectionViewMatrix:new a,rect:new ne(0,0,1,1)},this.gammaFactor=2,this.outputEncoding=G.LINEAR}updateCamera(t){const e=this.scene,n=this.camera,i=t.projectionMatrix;let r=0,s=0;-1===i.elements[11]?(r=i.elements[14]/(i.elements[10]-1),s=i.elements[14]/(i.elements[10]+1)):(r=(i.elements[14]+1)/i.elements[10],s=(i.elements[14]-1)/i.elements[10]),n.near=r,n.far=s,e.logarithmicDepthBuffer?(n.logDepthCameraNear=r,n.logDepthBufFC=2/(Math.log(s-r+1)*Math.LOG2E)):(n.logDepthCameraNear=0,n.logDepthBufFC=0),n.position.setFromMatrixPosition(t.worldMatrix),e.useAnchorMatrix&&n.position.applyMatrix4(e.anchorMatrixInverse),n.viewMatrix.copy(t.viewMatrix),e.useAnchorMatrix&&n.viewMatrix.multiply(e.anchorMatrix),n.projectionMatrix.copy(i),n.projectionViewMatrix.copy(i).multiply(n.viewMatrix),n.rect.copy(t.rect),n.version++,this.gammaFactor=t.gammaFactor,this.outputEncoding=t.outputEncoding}}class Be extends oe{constructor(){super(),this.fog=null,this.environment=null,this.envDiffuseIntensity=1,this.envSpecularIntensity=1,this.clippingPlanes=[],this.disableShadowSampler=!1,this.logarithmicDepthBuffer=!1,this.anchorMatrix=new a,this._sceneData=new Ie,this._lightingData=new xe,this._renderQueueMap=new WeakMap,this._renderStatesMap=new WeakMap,this._skeletonVersion=0}set maxLightingGroups(t){this._lightingData.setMaxGroupCount(t)}get maxLightingGroups(){return this._lightingData.groupList.length}updateRenderStates(t,e=!0){this._renderStatesMap.has(t)||this._renderStatesMap.set(t,new Ue(this._sceneData,this._lightingData));const n=this._renderStatesMap.get(t);return e&&this._sceneData.update(this),n.updateCamera(t),n}getRenderStates(t){return this._renderStatesMap.get(t)}updateRenderQueue(t,e=!0,n=!0){this._renderQueueMap.has(t)||this._renderQueueMap.set(t,new be);const i=this._renderQueueMap.get(t),r=this._lightingData;r.begin(!e),i.begin(),this._pushToRenderQueue(this,t,i),i.end(),r.end(this._sceneData),n&&this._skeletonVersion++;for(const t of i.skeletons)t._version!==this._skeletonVersion&&(t.updateBones(this._sceneData),t._version=this._skeletonVersion);return i}getRenderQueue(t){return this._renderQueueMap.get(t)}_pushToRenderQueue(t,e,n){if(!t.visible)return;t.geometry&&t.material&&t.renderable?t.frustumCulled&&e.frustumCulled?(ze.copy(t.geometry.boundingSphere).applyMatrix4(t.worldMatrix),e.frustum.intersectsSphere(ze)&&n.push(t,e)):n.push(t,e):t.isLight&&this._lightingData.collect(t);const i=t.children;for(let t=0,r=i.length;t<r;t++)this._pushToRenderQueue(i[t],e,n)}}Be.prototype.isScene=!0;const ze=new Yt;class Ge extends oe{constructor(){super(),this.viewMatrix=new a,this.projectionMatrix=new a,this.projectionMatrixInverse=new a,this.projectionViewMatrix=new a,this.frustum=new Bt,this.gammaFactor=2,this.outputEncoding=G.LINEAR,this.rect=new ne(0,0,1,1),this.frustumCulled=!0}lookAt(t,e){He.lookAtRH(this.position,t,e),this.quaternion.setFromRotationMatrix(He)}setOrtho(t,e,n,i,r,s){this.projectionMatrix.set(2/(e-t),0,0,-(e+t)/(e-t),0,2/(i-n),0,-(i+n)/(i-n),0,0,-2/(s-r),-(s+r)/(s-r),0,0,0,1),this.projectionMatrixInverse.getInverse(this.projectionMatrix)}setPerspective(t,e,n,i){this.projectionMatrix.set(1/(e*Math.tan(t/2)),0,0,0,0,1/Math.tan(t/2),0,0,0,0,-(i+n)/(i-n),-2*i*n/(i-n),0,0,-1,0),this.projectionMatrixInverse.getInverse(this.projectionMatrix)}getWorldDirection(t=new r){return super.getWorldDirection(t).negate()}updateMatrix(t){oe.prototype.updateMatrix.call(this,t),this.viewMatrix.getInverse(this.worldMatrix),this.projectionViewMatrix.multiplyMatrices(this.projectionMatrix,this.viewMatrix),this.frustum.setFromMatrix(this.projectionViewMatrix)}copy(t,e){return oe.prototype.copy.call(this,t,e),this.viewMatrix.copy(t.viewMatrix),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.frustum.copy(t.frustum),this.gammaFactor=t.gammaFactor,this.outputEncoding=t.outputEncoding,this.rect.copy(t.rect),this.frustumCulled=t.frustumCulled,this}}Ge.prototype.isCamera=!0;const He=new a,Ve=new Yt,ke=new a,We=new Wt,Xe=new r,qe=new r,je=new r,Ye=new r,Qe=new r,Ze=new r,Ke=new lt,$e=new lt,Je=new lt,tn=new r,en=new r;class nn extends oe{constructor(t,e){super(),this.geometry=t,this.material=e,this.morphTargetInfluences=null}getVertexPosition(t,e){const n=this.geometry,i=n.getAttribute("a_Position"),r=n.morphAttributes.position;e.fromArray(i.buffer.array,t*i.buffer.stride+i.offset);const s=this.morphTargetInfluences;if(r&&s){Ze.set(0,0,0);for(let e=0,n=r.length;e<n;e++){const n=s[e],i=r[e];0!==n&&(Qe.fromArray(i.buffer.array,t*i.buffer.stride+i.offset),Ze.addScaledVector(Qe,n))}e.add(Ze)}return e}raycast(t,e){const n=this.geometry,i=this.material,r=this.worldMatrix;if(Ve.copy(n.boundingSphere),Ve.applyMatrix4(r),!t.intersectsSphere(Ve))return;if(ke.getInverse(r),We.copy(t).applyMatrix4(ke),!We.intersectsBox(n.boundingBox))return;const s=n.getAttribute("a_Position");if(!s)return;const a=n.getAttribute("a_Uv"),o=n.groups;let l;if(n.index){const r=n.index.buffer.array;if(Array.isArray(i))for(let n=0,s=o.length;n<s;n++){const s=o[n],h=i[s.materialIndex];for(let i=s.start,o=Math.min(r.length,s.start+s.count);i<o;i+=3){const o=r[i],c=r[i+1],u=r[i+2];l=rn(this,h,t,We,a,o,c,u),l&&(l.faceIndex=Math.floor(n/3),l.face.materialIndex=s.materialIndex,e.push(l))}}else for(let n=0,s=r.length;n<s;n+=3){const s=r[n],o=r[n+1],h=r[n+2];l=rn(this,i,t,We,a,s,o,h),l&&(l.faceIndex=Math.floor(n/3),e.push(l))}}else if(Array.isArray(i))for(let n=0,r=o.length;n<r;n++){const r=o[n],h=i[r.materialIndex];for(let i=r.start,o=Math.min(s.buffer.count,r.start+r.count);i<o;i+=3){l=rn(this,h,t,We,a,i,i+1,i+2),l&&(l.faceIndex=Math.floor(n/3),l.face.materialIndex=r.materialIndex,e.push(l))}}else for(let n=0,r=s.buffer.count;n<r;n+=3){l=rn(this,i,t,We,a,n,n+1,n+2),l&&(l.faceIndex=Math.floor(n/3),e.push(l))}}copy(t){return super.copy(t),t.morphTargetInfluences&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),this}clone(){return new this.constructor(this.geometry,this.material).copy(this)}}function rn(t,e,n,i,s,a,o,l){t.getVertexPosition(a,qe),t.getVertexPosition(o,je),t.getVertexPosition(l,Ye);const h=function(t,e,n,i,r,s,a,o){let l;l=e.side===P.BACK?i.intersectTriangle(a,s,r,!0,o):i.intersectTriangle(r,s,a,e.side!==P.DOUBLE,o);if(null===l)return null;en.copy(o),en.applyMatrix4(t.worldMatrix);const h=n.origin.distanceTo(en);return{distance:h,point:en.clone(),object:t}}(t,e,n,i,qe,je,Ye,tn);if(h){let t,e,n;s&&(t=s.buffer.array,e=s.buffer.stride,n=s.offset,Ke.fromArray(t,a*e+n),$e.fromArray(t,o*e+n),Je.fromArray(t,l*e+n),h.uv=(c=tn,u=qe,d=je,p=Ye,f=Ke,_=$e,m=Je,ee.barycoordFromPoint(c,u,d,p,Xe),f.multiplyScalar(Xe.x),_.multiplyScalar(Xe.y),m.multiplyScalar(Xe.z),f.add(_).add(m),f.clone()));const i={a:a,b:o,c:l,normal:new r};ee.normal(qe,je,Ye,i.normal),h.face=i}var c,u,d,p,f,_,m;return h}nn.prototype.isMesh=!0;class sn{constructor(t,e=t.stride,n=0,i=!1){this.buffer=t,this.size=e,this.offset=n,this.normalized=i,this.divisor=0}copy(t){return this.buffer=t.buffer,this.size=t.size,this.offset=t.offset,this.normalized=t.normalized,this.divisor=t.divisor,this}clone(t){let e;return t?(t.has(this.buffer)||t.set(this.buffer,this.buffer.clone()),e=new sn(t.get(this.buffer),this.size,this.offset,this.normalized),e.divisor=this.divisor,e):(console.warn("Attribute.clone(): now requires a WeakMap as an argument to save shared buffers."),e=new sn(this.buffer.clone(),this.size,this.offset,this.normalized),e.divisor=this.divisor,e)}}class an{constructor(t,e){this.array=t,this.stride=e,this.count=void 0!==t?t.length/e:0,this.usage=X.STATIC_DRAW,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}copy(t){return this.array=new t.array.constructor(t.array),this.stride=t.stride,this.count=t.array.length/this.stride,this.usage=t.usage,this}clone(){const t=new this.array.constructor(this.array),e=new an(t,this.stride);return e.usage=this.usage,e}}let on=0;const ln=new r,hn=new r,cn=new r,un=new ct,dn=new ct;class pn extends j{constructor(){super(),this.id=on++,this.uuid=e.generateUUID(),this.attributes={},this.morphAttributes={},this.index=null,this.boundingBox=new ct,this.boundingSphere=new Yt,this.groups=[],this.instanceCount=-1,this.version=0}addAttribute(t,e){this.attributes[t]=e}getAttribute(t){return this.attributes[t]}removeAttribute(t){delete this.attributes[t]}setIndex(t){if(Array.isArray(t)){const e=new(function(t){if(0===t.length)return-1/0;let e=t[0];for(let n=1,i=t.length;n<i;++n)t[n]>e&&(e=t[n]);return e}(t)>65535?Uint32Array:Uint16Array)(t);this.index=new sn(new an(e,1))}else this.index=t}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}computeBoundingBox(){const t=this.attributes.a_Position||this.attributes.position;t&&this.boundingBox.setFromArray(t.buffer.array,t.buffer.stride,t.offset);const e=this.morphAttributes.position;if(e)for(let t=0;t<e.length;t++){const n=e[t];un.setFromArray(n.buffer.array,n.buffer.stride,n.offset),ln.addVectors(this.boundingBox.min,un.min),this.boundingBox.expandByPoint(ln),ln.addVectors(this.boundingBox.max,un.max),this.boundingBox.expandByPoint(ln)}}computeBoundingSphere(){const t=this.attributes.a_Position||this.attributes.position,e=this.morphAttributes.position;if(!t)return;const n=t.buffer.stride,i=t.offset;if(e){un.setFromArray(t.buffer.array,n,i);for(let t=0;t<e.length;t++){const n=e[t];dn.setFromArray(n.buffer.array,n.buffer.stride,n.offset),ln.addVectors(un.min,dn.min),un.expandByPoint(ln),ln.addVectors(un.max,dn.max),un.expandByPoint(ln)}const r=this.boundingSphere.center;un.getCenter(r);let s=0;for(let a=0;a<t.buffer.count;a++){hn.fromArray(t.buffer.array,a*n+i),s=r.distanceToSquared(hn);for(let t=0;t<e.length;t++){const n=e[t];ln.fromArray(n.buffer.array,a*n.buffer.stride+n.offset),cn.addVectors(hn,ln);const i=r.distanceToSquared(cn);i>s&&(s=i,hn.add(ln))}}this.boundingSphere.radius=Math.sqrt(s)}else this.boundingSphere.setFromArray(t.buffer.array,n,i)}dispose(){this.dispatchEvent({type:"dispose"})}copy(t){let e,n,i;this.index=null,this.attributes={},this.morphAttributes={},this.groups=[];const r=new WeakMap,s=t.index;null!==s&&this.setIndex(s.clone(r));const a=t.attributes;for(e in a){const t=a[e];this.addAttribute(e,t.clone(r))}const o=t.morphAttributes;for(e in o){const t=[],s=o[e];for(n=0,i=s.length;n<i;n++)t.push(s[n].clone(r));this.morphAttributes[e]=t}const l=t.groups;for(n=0,i=l.length;n<i;n++){const t=l[n];this.addGroup(t.start,t.count,t.materialIndex)}return this.boundingBox.copy(t.boundingBox),this.boundingSphere.copy(t.boundingSphere),this.instanceCount=t.instanceCount,this}clone(){return(new pn).copy(this)}}class fn extends Pt{constructor(){super(),this.offset=new lt(0,0),this.scale=new lt(1,1),this.center=new lt(0,0),this.rotation=0,this.needsUpdate=!1}update(){return this.needsUpdate?(this.needsUpdate=!1,this.updateMatrix(),this):this}updateMatrix(){return this.setUvTransform(this.offset.x,this.offset.y,this.scale.x,this.scale.y,this.rotation,this.center.x,this.center.y)}copy(t){return super.copy(t),t.isTransformUV?(this.offset.copy(t.offset),this.scale.copy(t.scale),this.center.copy(t.center),this.rotation=t.rotation,this.needsUpdate=t.needsUpdate,this):this}clone(){return(new this.constructor).copy(this)}}fn.prototype.isTransformUV=!0;let _n=0;class mn extends j{constructor(){super(),this.id=_n++,this.uuid=e.generateUUID(),this.type=w.SHADER,this.shaderName="",this.defines={},this.uniforms={},this.vertexShader="",this.fragmentShader="",this.precision=null,this.extUvCoordMask=0,this.transparent=!1,this.blending=R.NORMAL,this.blendSrc=C.SRC_ALPHA,this.blendDst=C.ONE_MINUS_SRC_ALPHA,this.blendEquation=L.ADD,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.premultipliedAlpha=!1,this.vertexColors=k.NONE,this.vertexTangents=!1,this.opacity=1,this.diffuse=new At(16777215),this.diffuseMap=null,this.diffuseMapCoord=0,this.diffuseMapTransform=new fn,this.alphaMap=null,this.alphaMapCoord=0,this.alphaMapTransform=new fn,this.emissive=new At(0),this.emissiveMap=null,this.emissiveMapCoord=0,this.emissiveMapTransform=new fn,this.aoMap=null,this.aoMapIntensity=1,this.aoMapCoord=0,this.aoMapTransform=new fn,this.normalMap=null,this.normalScale=new lt(1,1),this.bumpMap=null,this.bumpScale=1,this.envMap=null,this.envMapIntensity=1,this.envMapCombine=H.MULTIPLY,this.depthFunc=U.LEQUAL,this.depthTest=!0,this.depthWrite=!0,this.colorWrite=!0,this.stencilTest=!1,this.stencilWriteMask=255,this.stencilFunc=U.ALWAYS,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=B.KEEP,this.stencilZFail=B.KEEP,this.stencilZPass=B.KEEP,this.stencilFuncBack=null,this.stencilRefBack=null,this.stencilFuncMaskBack=null,this.stencilFailBack=null,this.stencilZFailBack=null,this.stencilZPassBack=null,this.clippingPlanes=null,this.alphaTest=0,this.alphaToCoverage=!1,this.side=P.FRONT,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.shading=N.SMOOTH_SHADING,this.dithering=!1,this.acceptLight=!1,this.lightingGroup=0,this.fog=!0,this.drawMode=V.TRIANGLES,this.forceUpdateUniforms=!0,this.needsUpdate=!0}copy(t){return this.shaderName=t.shaderName,this.defines=Object.assign({},t.defines),this.uniforms=ie(t.uniforms),this.vertexShader=t.vertexShader,this.fragmentShader=t.fragmentShader,this.precision=t.precision,this.extUvCoordMask=t.extUvCoordMask,this.transparent=t.transparent,this.blending=t.blending,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.premultipliedAlpha=t.premultipliedAlpha,this.vertexColors=t.vertexColors,this.vertexTangents=t.vertexTangents,this.opacity=t.opacity,this.diffuse.copy(t.diffuse),this.diffuseMap=t.diffuseMap,this.diffuseMapCoord=t.diffuseMapCoord,this.diffuseMapTransform.copy(t.diffuseMapTransform),this.alphaMap=t.alphaMap,this.alphaMapCoord=t.alphaMapCoord,this.alphaMapTransform.copy(t.alphaMapTransform),this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveMapCoord=t.emissiveMapCoord,this.emissiveMapTransform.copy(t.emissiveMapTransform),this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.aoMapCoord=t.aoMapCoord,this.aoMapTransform.copy(t.aoMapTransform),this.normalMap=t.normalMap,this.normalScale.copy(t.normalScale),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.envMapCombine=t.envMapCombine,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.colorWrite=t.colorWrite,this.stencilTest=t.stencilTest,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilFuncBack=t.stencilFuncBack,this.stencilRefBack=t.stencilRefBack,this.stencilFuncMaskBack=t.stencilFuncMaskBack,this.stencilFailBack=t.stencilFailBack,this.stencilZFailBack=t.stencilZFailBack,this.stencilZPassBack=t.stencilZPassBack,this.clippingPlanes=t.clippingPlanes,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.side=t.side,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.shading=t.shading,this.dithering=t.dithering,this.acceptLight=t.acceptLight,this.lightingGroup=t.lightingGroup,this.fog=t.fog,this.drawMode=t.drawMode,this}clone(){return(new this.constructor).copy(this)}dispose(){this.dispatchEvent({type:"dispose"})}}class gn extends mn{constructor(t){super(),t&&(this.shaderName=t.name,Object.assign(this.defines,t.defines),this.uniforms=ie(t.uniforms),this.vertexShader=t.vertexShader,this.fragmentShader=t.fragmentShader)}}class vn extends mn{constructor(){super(),this.type=w.DEPTH,this.packToRGBA=!1}}class Tn extends mn{constructor(){super(),this.type=w.DISTANCE}}const Sn=new ne,En={front:P.BACK,back:P.FRONT,double:P.DOUBLE},xn={},Mn={};function An(t,e){const n=!!t.object.skeleton,i=t.geometry.morphAttributes.position&&t.geometry.morphAttributes.position.length>0,r=t.material.clippingPlanes,s=r&&r.length>0?r.length:0,a=i|n<<1;let o=xn[a];void 0===o&&(o={},xn[a]=o);let l=o[s];return void 0===l&&(l=new vn,l.packToRGBA=!0,o[s]=l),l.side=En[t.material.side],l.clippingPlanes=t.material.clippingPlanes,l.drawMode=t.material.drawMode,l}function yn(t,e){const n=!!t.object.skeleton,i=t.geometry.morphAttributes.position&&t.geometry.morphAttributes.position.length>0,r=t.material.clippingPlanes,s=r&&r.length>0?r.length:0,a=i|n<<1;let o=Mn[a];void 0===o&&(o={},Mn[a]=o);let l=o[s];return void 0===l&&(l=new Tn,o[s]=l),l.side=En[t.material.side],l.uniforms.nearDistance=e.shadow.cameraNear,l.uniforms.farDistance=e.shadow.cameraFar,l.clippingPlanes=t.material.clippingPlanes,l.drawMode=t.material.drawMode,l}class wn{constructor(t){this._key=t+"$",this._count=0}get(t){const e=this._key;let n=t[e];return void 0===n&&(n={},t[e]=n,this._count++),n}delete(t){const e=this._key;t[e]&&(this._count--,delete t[e])}size(){return this._count}}let Rn=0;class Ln{constructor(t){this.id=Rn++,this.context=t,this.capabilities={},this.shaderCompileOptions={checkErrors:!0,compileAsynchronously:!1,maxMaterialPrograms:5},this.lightingOptions={clustered:{enabled:!1,maxClusterLights:1024,useFloatPrecision:!1,gridDimensions:new r(16,8,32),maxLightsPerCell:256,zClip:new lt(-1,-1),version:0}},this.asyncReadPixel=!1,this._passInfo={enabled:!1,count:0}}beginRender(){this._passInfo.enabled=!0}endRender(){this._passInfo.enabled=!1,this._passInfo.count++}renderRenderableItem(t,e,n){}renderRenderableList(t,e,n={}){for(let i=0,r=t.length;i<r;i++)this.renderRenderableItem(t[i],e,n)}renderScene(t,e,n={}){const i=t.getRenderStates(e),r=t.getRenderQueue(e);let s;this.beginRender();for(let t=0,e=r.layerList.length;t<e;t++)s=r.layerList[t],this.renderRenderableList(s.opaque,i,n),this.renderRenderableList(s.transparent,i,n);this.endRender()}clear(t,e,n){}setClearColor(t,e,n,i,r){}getClearColor(){}setRenderTarget(t){}getRenderTarget(){}blitRenderTarget(t,e,n=!0,i=!0,r=!0){}readRenderTargetPixels(t,e,n,i,r){}updateRenderTargetMipmap(t){}setTextureExternal(t,e){}setRenderBufferExternal(t,e){}setBufferExternal(t,e){}resetVertexArrayBindings(t){}resetState(){}beginQuery(t,e){}endQuery(t){}queryCounter(t){}isTimerQueryDisjoint(t){}isQueryResultAvailable(t){}getQueryResult(t){}increaseId(){return this.id=Rn++,this.id}}class Cn{constructor(t=0,e=1,n=1e3){this.color=new At(t),this.near=e,this.far=n}}Cn.prototype.isFog=!0;class bn{constructor(t=0,e=25e-5){this.color=new At(t),this.density=e}}bn.prototype.isFogExp2=!0;class Pn extends pn{constructor(t=1,e=1,n=1,i=1,s=1,a=1){super();const o=this;i=Math.floor(i),s=Math.floor(s),a=Math.floor(a);const l=[],h=[],c=[],u=[];let d=0,p=0;function f(t,e,n,i,s,a,f,_,m,g,v){const T=a/m,S=f/g,E=a/2,x=f/2,M=_/2,A=m+1,y=g+1;let w=0,R=0;const L=new r;for(let r=0;r<y;r++){const a=r*S-x;for(let o=0;o<A;o++){const l=o*T-E;L[t]=l*i,L[e]=a*s,L[n]=M,h.push(L.x,L.y,L.z),L[t]=0,L[e]=0,L[n]=_>0?1:-1,c.push(L.x,L.y,L.z),u.push(o/m),u.push(1-r/g),w+=1}}for(let t=0;t<g;t++)for(let e=0;e<m;e++){const n=d+e+A*t,i=d+e+A*(t+1),r=d+(e+1)+A*(t+1),s=d+(e+1)+A*t;l.push(n,i,s),l.push(i,r,s),R+=6}o.addGroup(p,R,v),p+=R,d+=w}f("z","y","x",-1,-1,n,e,t,a,s,0),f("z","y","x",1,-1,n,e,-t,a,s,1),f("x","z","y",1,1,t,n,e,i,a,2),f("x","z","y",1,-1,t,n,-e,i,a,3),f("x","y","z",1,-1,t,e,n,i,s,4),f("x","y","z",-1,-1,t,e,-n,i,s,5),this.setIndex(new sn(new an(h.length/3>65536?new Uint32Array(l):new Uint16Array(l),1))),this.addAttribute("a_Position",new sn(new an(new Float32Array(h),3))),this.addAttribute("a_Normal",new sn(new an(new Float32Array(c),3))),this.addAttribute("a_Uv",new sn(new an(new Float32Array(u),2))),this.computeBoundingBox(),this.computeBoundingSphere()}}class Nn extends j{constructor(t,e){super(),this.width=t,this.height=e}resize(t,e){return(this.width!==t||this.height!==e)&&(this.width=t,this.height=e,!0)}dispose(){this.dispatchEvent({type:"dispose"})}}Nn.prototype.isRenderTarget=!0;class Dn extends j{constructor(t,e,n=D.RGBA8,i=0){super(),this.width=t,this.height=e,this.format=n,this.multipleSampling=i}resize(t,e){return(this.width!==t||this.height!==e)&&(this.dispose(),this.width=t,this.height=e,!0)}clone(){return(new this.constructor).copy(this)}copy(t){return this.format=t.format,this.multipleSampling=t.multipleSampling,this}dispose(){this.dispatchEvent({type:"dispose"})}}Dn.prototype.isRenderBuffer=!0;let Fn=0;class In extends j{constructor(){super(),this.id=Fn++,this.userData={},this.mipmaps=[],this.border=0,this.format=D.RGBA,this.internalformat=null,this.type=F.UNSIGNED_BYTE,this.magFilter=I.LINEAR,this.minFilter=I.LINEAR_MIPMAP_LINEAR,this.wrapS=O.CLAMP_TO_EDGE,this.wrapT=O.CLAMP_TO_EDGE,this.anisotropy=1,this.compare=void 0,this.generateMipmaps=!0,this.encoding=G.LINEAR,this.flipY=!0,this.premultiplyAlpha=!1,this.unpackAlignment=4,this.version=0}clone(){return(new this.constructor).copy(this)}copy(t){return this.userData=re(t.userData),this.mipmaps=t.mipmaps.slice(0),this.border=t.border,this.format=t.format,this.internalformat=t.internalformat,this.type=t.type,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.anisotropy=t.anisotropy,this.compare=t.compare,this.generateMipmaps=t.generateMipmaps,this.encoding=t.encoding,this.flipY=t.flipY,this.premultiplyAlpha=t.premultiplyAlpha,this.unpackAlignment=t.unpackAlignment,this.version=t.version,this}dispose(){this.dispatchEvent({type:"dispose"}),this.version=0}}In.prototype.isTexture=!0;class On extends In{constructor(){super(),this.image=null}copy(t){return super.copy(t),this.image=t.image,this}}On.prototype.isTexture2D=!0;class Un extends Nn{constructor(t,e){super(t,e),this._attachments={},this.attach(new On,W.COLOR_ATTACHMENT0),this.attach(new Dn(t,e,D.DEPTH_STENCIL),W.DEPTH_STENCIL_ATTACHMENT)}attach(t,e=W.COLOR_ATTACHMENT0){t.isTexture2D?t.image&&t.image.rtt?t.image.width===this.width&&t.image.height===this.height||(t.version++,t.image.width=this.width,t.image.height=this.height):(t.version++,t.image={rtt:!0,data:null,width:this.width,height:this.height}):t.resize(this.width,this.height),this._attachments[e]=t}detach(t=W.COLOR_ATTACHMENT0){delete this._attachments[t]}resize(t,e){const n=super.resize(t,e);if(n){this.dispose(!1);for(const n in this._attachments){const i=this._attachments[n];i.isTexture2D?(i.image={rtt:!0,data:null,width:this.width,height:this.height},i.version++):i.resize(t,e)}}return n}dispose(t=!0){if(super.dispose(),t)for(const t in this._attachments)this._attachments[t].dispose()}}Un.prototype.isRenderTarget2D=!0,Object.defineProperties(Un.prototype,{texture:{set:function(t){t?t.isTexture2D&&this.attach(t,W.COLOR_ATTACHMENT0):this.detach(W.COLOR_ATTACHMENT0)},get:function(){const t=this._attachments[W.COLOR_ATTACHMENT0];return t.isTexture2D?t:null}}});class Bn extends In{constructor(){super(),this.image={data:new Uint8Array([255,255,255,255,255,255,255,255]),width:2,height:2,depth:2},this.format=D.RED,this.magFilter=I.NEAREST,this.minFilter=I.NEAREST,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}copy(t){return super.copy(t),this.image=t.image,this}}Bn.prototype.isTexture2DArray=!0;class zn extends Nn{constructor(t,e,n){super(t,e),this.depth=n,this._attachments={},this.attach(new Bn,W.COLOR_ATTACHMENT0),this.activeLayer=0,this.activeMipmapLevel=0}attach(t,e=W.COLOR_ATTACHMENT0){t.isTexture2DArray?t.image&&t.image.rtt?t.image.width===this.width&&t.image.height===this.height&&t.image.depth===this.depth||(t.version++,t.image.width=this.width,t.image.height=this.height,t.image.depth=this.depth):(t.version++,t.image={rtt:!0,data:null,width:this.width,height:this.height,depth:this.depth}):t.resize(this.width,this.height),this._attachments[e]=t}detach(t=W.COLOR_ATTACHMENT0){delete this._attachments[t]}resize(t,e,n){let i=!1;if(this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,i=!0),i){this.dispose(!1);for(const n in this._attachments){const i=this._attachments[n];i.isTexture2DArray?(i.image={rtt:!0,data:null,width:this.width,height:this.height,depth:this.depth},i.version++):i.resize(t,e)}}return i}}zn.prototype.isRenderTarget2DArray=!0,Object.defineProperties(zn.prototype,{texture:{set:function(t){t?t.isTexture2DArray&&this.attach(t,W.COLOR_ATTACHMENT0):this.detach(W.COLOR_ATTACHMENT0)},get:function(){const t=this._attachments[W.COLOR_ATTACHMENT0];return t.isTexture2DArray?t:null}}});class Gn extends In{constructor(){super(),this.image={data:new Uint8Array([255,255,255,255,255,255,255,255]),width:2,height:2,depth:2},this.wrapR=O.CLAMP_TO_EDGE,this.format=D.RED,this.type=F.UNSIGNED_BYTE,this.magFilter=I.NEAREST,this.minFilter=I.NEAREST,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}copy(t){return super.copy(t),this.image=t.image,this}}Gn.prototype.isTexture3D=!0;class Hn extends Nn{constructor(t,e,n){super(t,e),this.depth=n,this._attachments={},this.attach(new Gn,W.COLOR_ATTACHMENT0),this.activeLayer=0,this.activeMipmapLevel=0}attach(t,e=W.COLOR_ATTACHMENT0){t.isTexture3D?t.image&&t.image.rtt?t.image.width===this.width&&t.image.height===this.height&&t.image.depth===this.depth||(t.version++,t.image.width=this.width,t.image.height=this.height,t.image.depth=this.depth):(t.version++,t.image={rtt:!0,data:null,width:this.width,height:this.height,depth:this.depth}):t.resize(this.width,this.height),this._attachments[e]=t}detach(t=W.COLOR_ATTACHMENT0){delete this._attachments[t]}resize(t,e,n){let i=!1;if(this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,i=!0),i){this.dispose(!1);for(const n in this._attachments){const i=this._attachments[n];i.isTexture3D?(i.image={rtt:!0,data:null,width:this.width,height:this.height,depth:this.depth},i.version++):i.resize(t,e)}}return i}dispose(t=!0){if(super.dispose(),t)for(const t in this._attachments)this._attachments[t].dispose()}}Hn.prototype.isRenderTarget3D=!0,Object.defineProperties(Hn.prototype,{texture:{set:function(t){t?t.isTexture3D&&this.attach(t,W.COLOR_ATTACHMENT0):this.detach(W.COLOR_ATTACHMENT0)},get:function(){const t=this._attachments[W.COLOR_ATTACHMENT0];return t.isTexture3D?t:null}}});class Vn extends Nn{constructor(t){super(t.width,t.height),this.view=t}resize(t,e){this.view.width=t,this.view.height=e,this.width=t,this.height=e}dispose(){}}Vn.prototype.isRenderTargetBack=!0;class kn extends In{constructor(){super(),this.images=[],this.flipY=!1}copy(t){return super.copy(t),this.images=t.images.slice(0),this}}kn.prototype.isTextureCube=!0;class Wn extends Nn{constructor(t,e){super(t,e),this._attachments={},this.attach(new kn,W.COLOR_ATTACHMENT0),this.attach(new Dn(t,e,D.DEPTH_STENCIL),W.DEPTH_STENCIL_ATTACHMENT),this.activeCubeFace=0,this.activeMipmapLevel=0}attach(t,e=W.COLOR_ATTACHMENT0){if(t.isTextureCube){let e=!1;for(let n=0;n<6;n++)t.images[n]&&t.images[n].rtt?t.images[n].width===this.width&&t.images[n].height===this.height||(t.images[n].width=this.width,t.images[n].height=this.height,e=!0):(t.images[n]={rtt:!0,data:null,width:this.width,height:this.height},e=!0);e&&t.version++}else t.resize(this.width,this.height);this._attachments[e]=t}detach(t=W.COLOR_ATTACHMENT0){delete this._attachments[t]}resize(t,e){if(super.resize(t,e)){this.dispose(!1);for(const n in this._attachments){const i=this._attachments[n];if(i.isTextureCube){for(let t=0;t<6;t++)i.images[t]={rtt:!0,data:null,width:this.width,height:this.height};i.version++}else i.resize(t,e)}}}dispose(t=!0){if(super.dispose(),t)for(const t in this._attachments)this._attachments[t].dispose()}}Wn.prototype.isRenderTargetCube=!0,Object.defineProperties(Wn.prototype,{texture:{set:function(t){t?t.isTextureCube&&this.attach(t,W.COLOR_ATTACHMENT0):this.detach(W.COLOR_ATTACHMENT0)},get:function(){const t=this._attachments[W.COLOR_ATTACHMENT0];return t.isTextureCube?t:null}}});let Xn=0;const qn=new a;class jn{constructor(t,e){this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=new Float32Array(16*this.bones.length),this.boneTexture=void 0,this._version=0}pose(){const t=this.boneInverses;for(let e=0;e<this.bones.length;e++){this.bones[e].worldMatrix.getInverse(t[e])}for(let t=0;t<this.bones.length;t++){const e=this.bones[t];e.parent&&e.parent.isBone?(e.matrix.getInverse(e.parent.worldMatrix),e.matrix.multiply(e.worldMatrix)):e.matrix.copy(e.worldMatrix),e.matrix.decompose(e.position,e.quaternion,e.scale)}}clone(){return new jn(this.bones,this.boneInverses)}updateBones(t){const e=t.useAnchorMatrix,n=t.anchorMatrixInverse,i=this.boneInverses;for(let t=0;t<this.bones.length;t++){const r=this.bones[t];qn.multiplyMatrices(r.worldMatrix,i[t]),e&&qn.premultiply(n),qn.toArray(this.boneMatrices,16*t)}void 0!==this.boneTexture&&this.boneTexture.version++}generateBoneTexture(){let t=e.nextPowerOfTwoSquareSize(4*this.bones.length);t=Math.max(t,4);const n=new Float32Array(t*t*4);n.set(this.boneMatrices);const i=new On;i.image={data:n,width:t,height:t},i.format=D.RGBA,i.type=F.FLOAT,i.magFilter=I.NEAREST,i.minFilter=I.NEAREST,i.generateMipmaps=!1,i.flipY=!1,this.boneMatrices=n,this.boneTexture=i}}class Yn extends le{constructor(t,e){super(t,e)}}Yn.prototype.isAmbientLight=!0;class Qn{constructor(){this.camera=new Ge,this.matrix=new a,this.bias=0,this.normalBias=0,this.radius=1,this.cameraNear=1,this.cameraFar=500,this.mapSize=new lt(512,512),this.autoUpdate=!0,this.needsUpdate=!1,this.renderTarget=null,this.map=null,this.depthMap=null}update(t,e){}updateMatrix(){const t=this.matrix,e=this.camera;t.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),t.multiply(e.projectionMatrix),t.multiply(e.viewMatrix)}copy(t){return this.camera.copy(t.camera),this.matrix.copy(t.matrix),this.bias=t.bias,this.normalBias=t.normalBias,this.radius=t.radius,this.cameraNear=t.cameraNear,this.cameraFar=t.cameraFar,this.mapSize.copy(t.mapSize),this}clone(){return(new this.constructor).copy(this)}prepareDepthMap(t,e){}}class Zn extends Qn{constructor(){super(),this.windowSize=500,this.frustumEdgeFalloff=0,this.renderTarget=new Un(this.mapSize.x,this.mapSize.y);const t=this.renderTarget.texture;t.generateMipmaps=!1,t.minFilter=I.NEAREST,t.magFilter=I.NEAREST;const e=new On;e.type=F.UNSIGNED_INT,e.format=D.DEPTH_COMPONENT,e.magFilter=I.LINEAR,e.minFilter=I.LINEAR,e.compare=U.LESS,e.generateMipmaps=!1;const n=new Dn(this.mapSize.x,this.mapSize.y,D.DEPTH_COMPONENT16);this.renderTarget.detach(W.DEPTH_STENCIL_ATTACHMENT),this.renderTarget.attach(n,W.DEPTH_ATTACHMENT),this.map=t,this.depthMap=e,this._depthBuffer=n}update(t){this._updateCamera(t),this.mapSize.x===this.renderTarget.width&&this.mapSize.y===this.renderTarget.height||this.renderTarget.resize(this.mapSize.x,this.mapSize.y)}_updateCamera(t){const e=this.camera;e.matrix.copy(t.worldMatrix),e.matrix.decompose(e.position,e.quaternion,e.scale),e.updateMatrix();const n=this.windowSize/2;e.setOrtho(-n,n,-n,n,this.cameraNear,this.cameraFar)}copy(t){return super.copy(t),this.windowSize=t.windowSize,this.frustumEdgeFalloff=t.frustumEdgeFalloff,this}prepareDepthMap(t,e){const n=t&&e.version>=2,i=this.renderTarget;n!==(i._attachments[W.DEPTH_ATTACHMENT]===this.depthMap)&&(n?(e.getExtension("OES_texture_float_linear")&&(this.depthMap.type=F.FLOAT),i.dispose(),i.attach(this.depthMap,W.DEPTH_ATTACHMENT)):(i.dispose(),i.attach(this._depthBuffer,W.DEPTH_ATTACHMENT)))}}class Kn extends le{constructor(t,e){super(t,e),this.shadow=new Zn}copy(t){return super.copy(t),this.shadow.copy(t.shadow),this}}Kn.prototype.isDirectionalLight=!0;class $n extends le{constructor(t,e,n){super(t,n),this.groundColor=new At(void 0!==e?e:16777215)}copy(t){super.copy(t),this.groundColor.copy(t.groundColor)}}$n.prototype.isHemisphereLight=!0;class Jn extends Qn{constructor(){super(),this.renderTarget=new Wn(this.mapSize.x,this.mapSize.y);const t=this.renderTarget.texture;t.generateMipmaps=!1,t.minFilter=I.NEAREST,t.magFilter=I.NEAREST,this.map=t,this._targets=[new r(1,0,0),new r(-1,0,0),new r(0,1,0),new r(0,-1,0),new r(0,0,1),new r(0,0,-1)],this._ups=[new r(0,-1,0),new r(0,-1,0),new r(0,0,1),new r(0,0,-1),new r(0,-1,0),new r(0,-1,0)],this._lookTarget=new r}update(t,e){this._updateCamera(t,e),this.mapSize.x===this.renderTarget.width&&this.mapSize.y===this.renderTarget.height||this.renderTarget.resize(this.mapSize.x,this.mapSize.y)}_updateCamera(t,e){const n=this.camera,i=this._lookTarget,r=this._targets,s=this._ups;n.position.setFromMatrixPosition(t.worldMatrix),i.set(r[e].x+n.position.x,r[e].y+n.position.y,r[e].z+n.position.z),n.lookAt(i,s[e]),n.updateMatrix(),n.setPerspective(.5*Math.PI,1,this.cameraNear,this.cameraFar)}}class ti extends le{constructor(t,e,n,i){super(t,e),this.decay=void 0!==i?i:1,this.distance=void 0!==n?n:200,this.shadow=new Jn}copy(t){return super.copy(t),this.shadow.copy(t.shadow),this}}ti.prototype.isPointLight=!0;class ei extends le{constructor(t=new Zt,e=1){super(void 0,e),this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}}ei.prototype.isSphericalHarmonicsLight=!0;class ni extends Qn{constructor(){super(),this.frustumEdgeFalloff=0,this.renderTarget=new Un(this.mapSize.x,this.mapSize.y);const t=this.renderTarget.texture;t.generateMipmaps=!1,t.minFilter=I.NEAREST,t.magFilter=I.NEAREST;const e=new On;e.type=F.UNSIGNED_INT,e.format=D.DEPTH_COMPONENT,e.magFilter=I.LINEAR,e.minFilter=I.LINEAR,e.compare=U.LESS,e.generateMipmaps=!1;const n=new Dn(this.mapSize.x,this.mapSize.y,D.DEPTH_COMPONENT16);this.renderTarget.detach(W.DEPTH_STENCIL_ATTACHMENT),this.renderTarget.attach(n,W.DEPTH_ATTACHMENT),this.map=t,this.depthMap=e,this._depthBuffer=n}update(t){this._updateCamera(t),this.mapSize.x===this.renderTarget.width&&this.mapSize.y===this.renderTarget.height||this.renderTarget.resize(this.mapSize.x,this.mapSize.y)}_updateCamera(t){const e=this.camera;e.matrix.copy(t.worldMatrix),e.matrix.decompose(e.position,e.quaternion,e.scale),e.updateMatrix(),e.setPerspective(2*t.angle,1,this.cameraNear,this.cameraFar)}copy(t){return super.copy(t),this.frustumEdgeFalloff=t.frustumEdgeFalloff,this}prepareDepthMap(t,e){const n=t&&e.version>=2,i=this.renderTarget;n!==(i._attachments[W.DEPTH_ATTACHMENT]===this.depthMap)&&(n?(e.getExtension("OES_texture_float_linear")&&(this.depthMap.type=F.FLOAT),i.dispose(),i.attach(this.depthMap,W.DEPTH_ATTACHMENT)):(i.dispose(),i.attach(this._depthBuffer,W.DEPTH_ATTACHMENT)))}}class ii extends le{constructor(t,e,n,i,r,s){super(t,e),this.decay=void 0!==s?s:1,this.distance=void 0!==n?n:200,this.penumbra=void 0!==r?r:0,this.angle=void 0!==i?i:Math.PI/6,this.shadow=new ni}copy(t){return super.copy(t),this.shadow.copy(t.shadow),this}}ii.prototype.isSpotLight=!0;class ri extends oe{constructor(){super()}}ri.prototype.isBone=!0;class si extends nn{constructor(t,e){super(t,e),this.skeleton=void 0,this.bindMode="attached",this.bindMatrix=new a,this.bindMatrixInverse=new a}bind(t,e){this.skeleton=t,void 0===e&&(this.updateMatrix(),e=this.worldMatrix),this.bindMatrix.copy(e),this.bindMatrixInverse.getInverse(e)}updateMatrix(t){super.updateMatrix(t),"attached"===this.bindMode?this.bindMatrixInverse.getInverse(this.worldMatrix):"detached"===this.bindMode?this.bindMatrixInverse.getInverse(this.bindMatrix):console.warn("SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}getVertexPosition(t,e){return super.getVertexPosition(t,e),this.applyBoneTransform(t,e),e}applyBoneTransform(t,e){const n=this.skeleton,i=this.geometry,r=i.attributes.skinIndex,s=i.attributes.skinWeight;oi.fromArray(r.buffer.array,t*r.size),li.fromArray(s.buffer.array,t*s.size),ai.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let t=0;t<4;t++){const i=ui(li,t);if(i<Number.EPSILON)continue;const r=ui(oi,t);n.bones[r]&&(ci.multiplyMatrices(n.bones[r].worldMatrix,n.boneInverses[r]),e.addScaledVector(hi.copy(ai).applyMatrix4(ci),i))}return e.applyMatrix4(this.bindMatrixInverse)}}si.prototype.isSkinnedMesh=!0;const ai=new r,oi=new ne,li=new ne,hi=new r,ci=new a;function ui(t,e){switch(e){case 0:return t.x;case 1:return t.y;case 2:return t.z;case 3:return t.w;default:throw new Error("index is out of range: "+e)}}const di={alphaTest_frag:"#ifdef ALPHATEST\n\tif (outColor.a < u_AlphaTest) discard;\n\toutColor.a = u_Opacity;\n#endif",alphaTest_pars_frag:"#ifdef ALPHATEST\n\tuniform float u_AlphaTest;\n#endif",aoMap_pars_frag:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\tvarying vec2 vAOMapUV;\n#endif",aoMap_pars_vert:"#ifdef USE_AOMAP\n\tuniform mat3 aoMapUVTransform;\n\tvarying vec2 vAOMapUV;\n#endif",aoMap_vert:"#ifdef USE_AOMAP\n\tvAOMapUV = (aoMapUVTransform * vec3(AOMAP_UV, 1.)).xy;\n#endif",aoMap_frag:"\n#ifdef USE_AOMAP\n\t\tfloat ambientOcclusion = (texture2D(aoMap, vAOMapUV).r - 1.0) * aoMapIntensity + 1.0;\n\t\t\n\t\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t\t#if defined(USE_ENV_MAP) && defined(USE_PBR)\n\t\t\t\tfloat dotNV = saturate(dot(N, V));\n\t\t\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, roughness);\n\t\t#endif\n#endif",begin_frag:"vec4 outColor = vec4(u_Color, u_Opacity);",begin_vert:"vec3 transformed = vec3(a_Position);\nvec3 objectNormal = vec3(a_Normal);\n#ifdef USE_TANGENT\n\t\tvec3 objectTangent = vec3(a_Tangent.xyz);\n#endif",bsdfs:"\nvec3 BRDF_Diffuse_Lambert(vec3 diffuseColor) {\n\t\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {\n\tfloat fresnel = exp2((-5.55473 * dotLH - 6.98316) * dotLH);\n\treturn (1.0 - specularColor) * fresnel + specularColor;\n}\nfloat D_BlinnPhong(const in float shininess, const in float dotNH) {\n\treturn RECIPROCAL_PI * (shininess * 0.5 + 1.0) * pow(dotNH, shininess);\n}\nfloat G_BlinnPhong_Implicit() {\n\treturn 0.25;\n}\nvec3 BRDF_Specular_BlinnPhong(vec3 specularColor, vec3 N, vec3 L, vec3 V, float shininess) {\n\t\tvec3 H = normalize(L + V);\n\t\tfloat dotNH = saturate(dot(N, H));\n\t\tfloat dotLH = saturate(dot(L, H));\n\t\tvec3 F = F_Schlick(specularColor, dotLH);\n\t\tfloat G = G_BlinnPhong_Implicit();\n\t\tfloat D = D_BlinnPhong(shininess, dotNH);\n\t\treturn F * G * D;\n}\nfloat D_GGX(const in float alpha, const in float dotNH) {\n\tfloat a2 = pow2(alpha);\n\tfloat denom = pow2(dotNH) * (a2 - 1.0) + 1.0;\treturn RECIPROCAL_PI * a2 / pow2(denom);\n}\nfloat G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {\n\tfloat a2 = pow2(alpha);\n\tfloat gv = dotNL * sqrt(a2 + (1.0 - a2) * pow2(dotNV));\n\tfloat gl = dotNV * sqrt(a2 + (1.0 - a2) * pow2(dotNL));\n\treturn 0.5 / max(gv + gl, EPSILON);\n}\nvec3 BRDF_Specular_GGX(vec3 specularColor, vec3 N, vec3 L, vec3 V, float roughness) {\n\tfloat alpha = pow2(roughness);\n\tvec3 H = normalize(L + V);\n\tfloat dotNL = saturate(dot(N, L));\n\tfloat dotNV = saturate(dot(N, V));\n\tfloat dotNH = saturate(dot(N, H));\n\tfloat dotLH = saturate(dot(L, H));\n\tvec3 F = F_Schlick(specularColor, dotLH);\n\tfloat G = G_GGX_SmithCorrelated(alpha, dotNL, dotNV);\n\tfloat D = D_GGX(alpha, dotNH);\n\treturn F * G * D;\n}\nvec2 integrateSpecularBRDF(const in float dotNV, const in float roughness) {\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;\n\treturn vec2(-1.04, 1.04) * a004 + r.zw;\n}\nvec3 F_Schlick_RoughnessDependent(const in vec3 F0, const in float dotNV, const in float roughness) {\n\tfloat fresnel = exp2((-5.55473 * dotNV - 6.98316) * dotNV);\n\tvec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n\treturn Fr * fresnel + F0;\n}\nvec3 BRDF_Specular_GGX_Environment(const in vec3 N, const in vec3 V, const in vec3 specularColor, const in float roughness) {\n\tfloat dotNV = saturate(dot(N, V));\n\tvec2 brdf = integrateSpecularBRDF(dotNV, roughness);\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment(const in vec3 N, const in vec3 V, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter) {\n\tfloat dotNV = saturate(dot(N, V));\n\tvec3 F = F_Schlick_RoughnessDependent(specularColor, dotNV, roughness);\n\tvec2 brdf = integrateSpecularBRDF(dotNV, roughness);\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + (1.0 - specularColor) * 0.047619;\tvec3 Fms = FssEss * Favg / (1.0 - Ems * Favg);\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}",bumpMap_pars_frag:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd(vec2 uv) {\n\t\tvec2 dSTdx = dFdx( uv );\n\t\tvec2 dSTdy = dFdy( uv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, uv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, uv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, uv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clippingPlanes_frag:"\n#if NUM_CLIPPING_PLANES > 0\n\t\tvec4 plane;\n\t\t#pragma unroll_loop_start\n\t\tfor (int i = 0; i < NUM_CLIPPING_PLANES; i++) {\n\t\t\t\tplane = clippingPlanes[i];\n\t\t\t\tif ( dot( -v_modelPos, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n#endif",clippingPlanes_pars_frag:"#if NUM_CLIPPING_PLANES > 0\n\t\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",color_frag:"#ifdef USE_VCOLOR_RGB\n\t\toutColor.rgb *= v_Color;\n#endif\n#ifdef USE_VCOLOR_RGBA\n\t\toutColor *= v_Color;\n#endif",color_pars_frag:"#ifdef USE_VCOLOR_RGB\n\t\tvarying vec3 v_Color;\n#endif\n#ifdef USE_VCOLOR_RGBA\n\t\tvarying vec4 v_Color;\n#endif",color_pars_vert:"#ifdef USE_VCOLOR_RGB\n\t\tattribute vec3 a_Color;\n\t\tvarying vec3 v_Color;\n#endif\n#ifdef USE_VCOLOR_RGBA\n\t\tattribute vec4 a_Color;\n\t\tvarying vec4 v_Color;\n#endif",color_vert:"#if defined(USE_VCOLOR_RGB) || defined(USE_VCOLOR_RGBA)\n\t\tv_Color = a_Color;\n#endif",common_frag:"uniform mat4 u_View;\nuniform float u_Opacity;\nuniform vec3 u_Color;\nuniform vec3 u_CameraPosition;\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};",common_vert:"attribute vec3 a_Position;\nattribute vec3 a_Normal;\n#ifdef USE_TANGENT\n\tattribute vec4 a_Tangent;\n#endif\n#include <transpose>\n#include <inverse>\nuniform mat4 u_Projection;\nuniform mat4 u_View;\nuniform mat4 u_Model;\nuniform mat4 u_ProjectionView;\nuniform vec3 u_CameraPosition;\n#define EPSILON 1e-6\n#ifdef USE_MORPHTARGETS\n\t\tattribute vec3 morphTarget0;\n\t\tattribute vec3 morphTarget1;\n\t\tattribute vec3 morphTarget2;\n\t\tattribute vec3 morphTarget3;\n\t\t#ifdef USE_MORPHNORMALS\n\t\t\tattribute vec3 morphNormal0;\n\t\t\tattribute vec3 morphNormal1;\n\t\t\tattribute vec3 morphNormal2;\n\t\t\tattribute vec3 morphNormal3;\n\t\t#else\n\t\t\tattribute vec3 morphTarget4;\n\t\t\tattribute vec3 morphTarget5;\n\t\t\tattribute vec3 morphTarget6;\n\t\t\tattribute vec3 morphTarget7;\n\t\t#endif\n#endif\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}",diffuseMap_frag:"#ifdef USE_DIFFUSE_MAP\n\t\toutColor *= mapTexelToLinear(texture2D(diffuseMap, vDiffuseMapUV));\n#endif",diffuseMap_pars_frag:"#ifdef USE_DIFFUSE_MAP\n\t\tuniform sampler2D diffuseMap;\n\t\tvarying vec2 vDiffuseMapUV;\n#endif",diffuseMap_vert:"#ifdef USE_DIFFUSE_MAP\n\t\tvDiffuseMapUV = (uvTransform * vec3(DIFFUSEMAP_UV, 1.)).xy;\n#endif",diffuseMap_pars_vert:"#ifdef USE_DIFFUSE_MAP\n\t\tvarying vec2 vDiffuseMapUV;\n#endif",emissiveMap_frag:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = emissiveMapTexelToLinear(texture2D(emissiveMap, vEmissiveMapUV));\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissiveMap_pars_frag:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n\tvarying vec2 vEmissiveMapUV;\n#endif",emissiveMap_vert:"#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUV = (emissiveMapUVTransform * vec3(EMISSIVEMAP_UV, 1.)).xy;\n#endif",emissiveMap_pars_vert:"#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapUVTransform;\n\tvarying vec2 vEmissiveMapUV;\n#endif",encodings_frag:"gl_FragColor = linearToOutputTexel(gl_FragColor);",encodings_pars_frag:"vec4 LinearToLinear(in vec4 value) {\n\treturn value;\n}\nvec4 GammaToLinear(in vec4 value, in float gammaFactor) {\n\treturn vec4(pow(value.xyz, vec3(gammaFactor)), value.w);\n}\nvec4 LinearToGamma(in vec4 value, in float gammaFactor) {\n\treturn vec4(pow(value.xyz, vec3(1.0 / gammaFactor)), value.w);\n}\nvec4 sRGBToLinear(in vec4 value) {\n\treturn vec4(mix(pow(value.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), value.rgb * 0.0773993808, vec3(lessThanEqual(value.rgb, vec3(0.04045)))), value.w);\n}\nvec4 LinearTosRGB(in vec4 value) {\n\treturn vec4(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))), value.w);\n}",end_frag:"gl_FragColor = outColor;",envMap_frag:"#ifdef USE_ENV_MAP\n\t\tvec3 envDir;\n\t\t#ifdef USE_VERTEX_ENVDIR\n\t\t\t\tenvDir = v_EnvDir;\n\t\t#else\n\t\t\t\tenvDir = reflect(normalize(v_modelPos - u_CameraPosition), N);\n\t\t#endif\n\t\tvec4 envColor = textureCube(envMap, vec3(envMapParams.z * envDir.x, envDir.yz));\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutColor = mix(outColor, envColor * outColor, envMapParams.y);\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutColor = mix(outColor, envColor, envMapParams.y);\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutColor += envColor * envMapParams.y;\n\t#endif\n#endif",envMap_pars_frag:"#ifdef USE_ENV_MAP\n\t\t#ifdef USE_VERTEX_ENVDIR\n\t\t\t\tvarying vec3 v_EnvDir;\n\t\t#endif\n\t\tuniform samplerCube envMap;\n\t\tuniform vec3 envMapParams;\n\t\tuniform int maxMipLevel;\n#endif",envMap_pars_vert:"#ifdef USE_ENV_MAP\n\t\t#ifdef USE_VERTEX_ENVDIR\n\t\t\t\tvarying vec3 v_EnvDir;\n\t\t#endif\n#endif",envMap_vert:"\n#ifdef USE_ENV_MAP\n\t\t#ifdef USE_VERTEX_ENVDIR\n\t\t\t\tvec3 transformedNormal = (transposeMat4(inverseMat4(u_Model)) * vec4(objectNormal, 0.0)).xyz;\n\t\t\t\ttransformedNormal = normalize(transformedNormal);\n\t\t\t\tv_EnvDir = reflect(normalize(worldPosition.xyz - u_CameraPosition), transformedNormal);\n\t\t#endif\n#endif",fog_frag:"#ifdef USE_FOG\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t\t#ifdef USE_EXP2_FOG\n\t\t\t\tfloat fogFactor = 1.0 - exp(-u_FogDensity * u_FogDensity * depth * depth);\n\t\t#else\n\t\t\t\tfloat fogFactor = smoothstep(u_FogNear, u_FogFar, depth);\n\t\t#endif\n\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, fogFactor);\n#endif",fog_pars_frag:"#ifdef USE_FOG\n\t\tuniform vec3 u_FogColor;\n\t\t#ifdef USE_EXP2_FOG\n\t\t\t\tuniform float u_FogDensity;\n\t\t#else\n\t\t\t\tuniform float u_FogNear;\n\t\t\t\tuniform float u_FogFar;\n\t\t#endif\n#endif",inverse:"mat4 inverseMat4(mat4 m) {\n\t\tfloat\n\t\ta00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n\t\ta10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n\t\ta20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n\t\ta30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\t\tb00 = a00 * a11 - a01 * a10,\n\t\tb01 = a00 * a12 - a02 * a10,\n\t\tb02 = a00 * a13 - a03 * a10,\n\t\tb03 = a01 * a12 - a02 * a11,\n\t\tb04 = a01 * a13 - a03 * a11,\n\t\tb05 = a02 * a13 - a03 * a12,\n\t\tb06 = a20 * a31 - a21 * a30,\n\t\tb07 = a20 * a32 - a22 * a30,\n\t\tb08 = a20 * a33 - a23 * a30,\n\t\tb09 = a21 * a32 - a22 * a31,\n\t\tb10 = a21 * a33 - a23 * a31,\n\t\tb11 = a22 * a33 - a23 * a32,\n\t\tdet = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\t\treturn mat4(\n\t\t\t\ta11 * b11 - a12 * b10 + a13 * b09,\n\t\t\t\ta02 * b10 - a01 * b11 - a03 * b09,\n\t\t\t\ta31 * b05 - a32 * b04 + a33 * b03,\n\t\t\t\ta22 * b04 - a21 * b05 - a23 * b03,\n\t\t\t\ta12 * b08 - a10 * b11 - a13 * b07,\n\t\t\t\ta00 * b11 - a02 * b08 + a03 * b07,\n\t\t\t\ta32 * b02 - a30 * b05 - a33 * b01,\n\t\t\t\ta20 * b05 - a22 * b02 + a23 * b01,\n\t\t\t\ta10 * b10 - a11 * b08 + a13 * b06,\n\t\t\t\ta01 * b08 - a00 * b10 - a03 * b06,\n\t\t\t\ta30 * b04 - a31 * b02 + a33 * b00,\n\t\t\t\ta21 * b02 - a20 * b04 - a23 * b00,\n\t\t\t\ta11 * b07 - a10 * b09 - a12 * b06,\n\t\t\t\ta00 * b09 - a01 * b07 + a02 * b06,\n\t\t\t\ta31 * b01 - a30 * b03 - a32 * b00,\n\t\t\t\ta20 * b03 - a21 * b01 + a22 * b00) / det;\n}",light_frag:"\n#if (defined(USE_PHONG) || defined(USE_PBR))\n\t\tvec3 V = normalize(u_CameraPosition - v_modelPos);\n#endif\n#ifdef USE_PBR\n\t\t#ifdef USE_PBR2\n\t\t\t\tvec3 diffuseColor = outColor.xyz;\n\t\t\t\tvec3 specularColor = specularFactor.xyz;\n\t\t\t\tfloat roughness = max(1.0 - glossinessFactor, 0.0525);\n\t\t#else\n\t\t\t\tvec3 diffuseColor = outColor.xyz * (1.0 - metalnessFactor);\n\t\t\t\tvec3 specularColor = mix(vec3(0.04), outColor.xyz, metalnessFactor);\n\t\t\t\tfloat roughness = max(roughnessFactor, 0.0525);\n\t\t#endif\n\t\tvec3 dxy = max(abs(dFdx(geometryNormal)), abs(dFdy(geometryNormal)));\n\t\tfloat geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);\n\t\troughness += geometryRoughness;\n\t\troughness = min(roughness, 1.0);\n\t\t#ifdef USE_CLEARCOAT\n\t\t\t\tfloat clearcoat = u_Clearcoat;\n\t\t\t\tfloat clearcoatRoughness = u_ClearcoatRoughness;\n\t\t\t\t#ifdef USE_CLEARCOATMAP\n\t\t\t\tclearcoat *= texture2D(clearcoatMap, v_Uv).x;\n\t\t\t\t#endif\n\t\t\t\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\t\t\tclearcoatRoughness *= texture2D(clearcoatRoughnessMap, v_Uv).y;\n\t\t\t#endif\n\t\t\t\tclearcoat = saturate(clearcoat);\n\t\t\t\tclearcoatRoughness = max(clearcoatRoughness, 0.0525);\n\t\t\tclearcoatRoughness += geometryRoughness;\n\t\t\tclearcoatRoughness = min(clearcoatRoughness, 1.0);\n\t\t#endif\n#else\n\t\tvec3 diffuseColor = outColor.xyz;\n\t\t#ifdef USE_PHONG\n\t\t\t\tvec3 specularColor = u_SpecularColor.xyz;\n\t\t\t\tfloat shininess = u_Specular;\n\t\t#endif\n#endif\nvec3 L;\nfloat falloff;\nfloat dotNL;\nvec3 irradiance;\nfloat clearcoatDHR;\n#ifdef USE_CLEARCOAT\n\t\tfloat ccDotNL;\n\t\tvec3 ccIrradiance;\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor (int i = 0; i < NUM_DIR_LIGHTS; i++) {\n\t\t\t\tL = normalize(-u_Directional[i].direction);\n\t\t\t\tfalloff = 1.0;\n\t\t\t\t#if defined(USE_SHADOW) && (UNROLLED_LOOP_INDEX < NUM_DIR_SHADOWS)\n\t\t\t\t\t\t#ifdef USE_PCSS_SOFT_SHADOW\n\t\t\t\t\t\t\t\tfalloff *= getShadowWithPCSS(directionalDepthMap[i], directionalShadowMap[i], vDirectionalShadowCoord[i], u_DirectionalShadow[i].shadowMapSize, u_DirectionalShadow[i].shadowBias, u_DirectionalShadow[i].shadowParams);\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tfalloff *= getShadow(directionalShadowMap[i], vDirectionalShadowCoord[i], u_DirectionalShadow[i].shadowMapSize, u_DirectionalShadow[i].shadowBias, u_DirectionalShadow[i].shadowParams);\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\tdotNL = saturate(dot(N, L));\n\t\t\t\tirradiance = u_Directional[i].color * falloff * dotNL * PI;\n\t\t\t\t#ifdef USE_CLEARCOAT\t\t\t\t\n\t\t\t\t\t\tccDotNL = saturate(dot(clearcoatNormal, L));\n\t\t\t\t\t\tccIrradiance = ccDotNL * u_Directional[i].color * falloff\t* PI;\n\t\t\t\t\t\tclearcoatDHR = clearcoat * clearcoatDHRApprox(clearcoatRoughness, ccDotNL);\n\t\t\t\t\t\treflectedLight.directSpecular += ccIrradiance * clearcoat * BRDF_Specular_GGX(specularColor, clearcoatNormal, L, V, clearcoatRoughness);\n\t\t\t\t#else\n\t\t\t\t\t\tclearcoatDHR = 0.0;\n\t\t\t\t#endif\n\t\t\t\treflectedLight.directDiffuse += (1.0 - clearcoatDHR) * irradiance * BRDF_Diffuse_Lambert(diffuseColor);\n\t\t\t\t#ifdef USE_PHONG\n\t\t\t\t\t\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(specularColor, N, L, V, shininess) * specularStrength;\n\t\t\t\t#endif\n\t\t\t\t#ifdef USE_PBR\n\t\t\t\t\t\treflectedLight.directSpecular += (1.0 - clearcoatDHR) * irradiance * BRDF_Specular_GGX(specularColor, N, L, V, roughness);\n\t\t\t\t#endif\n\t\t}\n\t\t#pragma unroll_loop_end\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t\tvec3 worldV;\n\t\t#pragma unroll_loop_start\n\t\tfor (int i = 0; i < NUM_POINT_LIGHTS; i++) {\n\t\t\t\tworldV = v_modelPos - u_Point[i].position;\n\t\t\t\tL = -worldV;\n\t\t\t\tfalloff = pow(clamp(1. - length(L) / u_Point[i].distance, 0.0, 1.0), u_Point[i].decay);\n\t\t\t\tL = normalize(L);\n\t\t\t\t#if defined(USE_SHADOW) && (UNROLLED_LOOP_INDEX < NUM_POINT_SHADOWS)\n\t\t\t\t\t\tfalloff *= getPointShadow(pointShadowMap[i], vPointShadowCoord[i], u_PointShadow[i].shadowMapSize, u_PointShadow[i].shadowBias, u_PointShadow[i].shadowParams, u_PointShadow[i].shadowCameraRange);\n\t\t\t\t#endif\n\t\t\t\tdotNL = saturate(dot(N, L));\n\t\t\t\tirradiance = u_Point[i].color * falloff * dotNL * PI;\n\t\t\t\t#ifdef USE_CLEARCOAT\t\t\t\t\n\t\t\t\t\t\tccDotNL = saturate(dot(clearcoatNormal, L));\n\t\t\t\t\t\tccIrradiance = ccDotNL *\tu_Point[i].color * falloff\t* PI;\n\t\t\t\t\t\tclearcoatDHR = clearcoat * clearcoatDHRApprox(clearcoatRoughness, ccDotNL);\n\t\t\t\t\t\treflectedLight.directSpecular += ccIrradiance * clearcoat * BRDF_Specular_GGX(specularColor, clearcoatNormal, L, V, clearcoatRoughness);\n\t\t\t\t#else\n\t\t\t\t\t\tclearcoatDHR = 0.0;\n\t\t\t\t#endif\n\t\t\t\treflectedLight.directDiffuse += (1.0 - clearcoatDHR) * irradiance * BRDF_Diffuse_Lambert(diffuseColor);\n\t\t\t\t#ifdef USE_PHONG\n\t\t\t\t\t\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(specularColor, N, L, V, shininess) * specularStrength;\n\t\t\t\t#endif\n\t\t\t\t#ifdef USE_PBR\n\t\t\t\t\t\treflectedLight.directSpecular += (1.0 - clearcoatDHR) * irradiance * BRDF_Specular_GGX(specularColor, N, L, V, roughness);\n\t\t\t\t#endif\n\t\t}\n\t\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t\tfloat lightDistance;\n\t\tfloat angleCos;\n\t\t#pragma unroll_loop_start\n\t\tfor (int i = 0; i < NUM_SPOT_LIGHTS; i++) {\n\t\t\t\tL = u_Spot[i].position - v_modelPos;\n\t\t\t\tlightDistance = length(L);\n\t\t\t\tL = normalize(L);\n\t\t\t\tangleCos = dot(L, -normalize(u_Spot[i].direction));\n\t\t\t\tfalloff = smoothstep(u_Spot[i].coneCos, u_Spot[i].penumbraCos, angleCos);\n\t\t\t\tfalloff *= pow(clamp(1. - lightDistance / u_Spot[i].distance, 0.0, 1.0), u_Spot[i].decay);\n\t\t\t\t#if defined(USE_SHADOW) && (UNROLLED_LOOP_INDEX < NUM_SPOT_SHADOWS)\n\t\t\t\t\t\t#ifdef USE_PCSS_SOFT_SHADOW\n\t\t\t\t\t\t\t\tfalloff *= getShadowWithPCSS(spotDepthMap[i], spotShadowMap[i], vSpotShadowCoord[i], u_SpotShadow[i].shadowMapSize, u_SpotShadow[i].shadowBias, u_SpotShadow[i].shadowParams);\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tfalloff *= getShadow(spotShadowMap[i], vSpotShadowCoord[i], u_SpotShadow[i].shadowMapSize, u_SpotShadow[i].shadowBias, u_SpotShadow[i].shadowParams);\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\tdotNL = saturate(dot(N, L));\n\t\t\t\tirradiance = u_Spot[i].color * falloff * dotNL * PI;\n\t\t\t\t#ifdef USE_CLEARCOAT\t\t\t\t\n\t\t\t\t\t\tccDotNL = saturate(dot(clearcoatNormal, L));\n\t\t\t\t\t\tccIrradiance = ccDotNL *\tu_Spot[i].color * falloff\t* PI;\n\t\t\t\t\t\tclearcoatDHR = clearcoat * clearcoatDHRApprox(clearcoatRoughness, ccDotNL);\n\t\t\t\t\t\treflectedLight.directSpecular += ccIrradiance * clearcoat * BRDF_Specular_GGX(specularColor, clearcoatNormal, L, V, clearcoatRoughness);\n\t\t\t\t#else\n\t\t\t\t\t\tclearcoatDHR = 0.0;\n\t\t\t\t#endif\n\t\t\t\treflectedLight.directDiffuse += (1.0 - clearcoatDHR) * irradiance * BRDF_Diffuse_Lambert(diffuseColor);\n\t\t\t\t#ifdef USE_PHONG\n\t\t\t\t\t\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(specularColor, N, L, V, shininess) * specularStrength;\n\t\t\t\t#endif\n\t\t\t\t#ifdef USE_PBR\n\t\t\t\t\t\treflectedLight.directSpecular += (1.0 - clearcoatDHR) * irradiance * BRDF_Specular_GGX(specularColor, N, L, V, roughness);\n\t\t\t\t#endif\n\t\t}\n\t\t#pragma unroll_loop_end\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\t\tvec3 RectAreaLightDirectSpecular;\n\t\tvec3 RectAreaLightDirectDiffuse;\n\t\tvec3 rectCoords[4];\n\t\t#pragma unroll_loop_start\n\t\tfor (int i = 0; i < NUM_RECT_AREA_LIGHTS; i++) {\n\t\t\t\tLTC_RectCoords(u_RectArea[i].position, u_RectArea[i].halfWidth, u_RectArea[i].halfHeight, rectCoords);\n\t\t\t\treflectedLight.directDiffuse += u_RectArea[i].color * LTC_Diffuse(diffuseColor, N, V, v_modelPos, rectCoords);\n\t\t\t\t#ifdef USE_PBR\n\t\t\t\t\t\treflectedLight.directSpecular += u_RectArea[i].color * LTC_Specular(specularColor, N, V, v_modelPos, rectCoords, roughness);\n\t\t\t\t#endif\n\t\t}\n\t\t#pragma unroll_loop_end\n#endif\n#ifdef USE_CLUSTERED_LIGHTS\n\t\tvec4 positionView = u_View * vec4(v_modelPos, 1.0);\n\t\tfloat perspectiveFactor = step(0.0, cellsTransformFactors.z);\n\t\tfloat halfFrustumHeight = -cellsTransformFactors.z * mix(1.0, positionView.z, perspectiveFactor);\n\t\tfloat halfFrustumWidth = halfFrustumHeight * cellsTransformFactors.w;\n\t\tvec3 cellCoords;\n\t\tcellCoords.z = floor(log(-positionView.z) * cellsTransformFactors.x + cellsTransformFactors.y);\n\t\tcellCoords.y = floor((positionView.y / (2.0 * halfFrustumHeight) + 0.5) * cells.y);\n\t\tcellCoords.x = floor((positionView.x / (2.0 * halfFrustumWidth) + 0.5) * cells.x);\n\t\tif(!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, cells)))) {\n\t\t\t\tfloat cellIndex = dot(cellsDotData, cellCoords);\n\t\t\t\tfloat clusterV = floor(cellIndex * cellsTextureSize.y);\n\t\t\t\tfloat clusterU = cellIndex - (clusterV * cellsTextureSize.x);\n\t\t\t\tint size = textureSize(lightsTexture, 0).x;\n\t\t\t\tClusteredPointLight clusteredPointLight;\n\t\t\t\tClusteredSpotLight clusteredSpotLight;\n\t\t\t\tvec3 clusteredLightColor;\n\t\t\t\tfloat clusteredLightDistance;\n\t\t\t\tfloat clusteredAngleCos;\n\t\t\t\tfor (int lightCellIndex = 0; lightCellIndex < maxLightsPerCell; lightCellIndex++) {\n\t\t\t\t\t\tfloat lightIndex = texelFetch(cellsTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0).x;\n\t\t\t\t\t\tif (lightIndex <= 0.0) break;\n\t\t\t\t\t\tint lightOffset = int(lightIndex - 1.) * 4;\n\t\t\t\t\t\tivec2 lightDataCoords = ivec2(lightOffset % size, lightOffset / size);\n\t\t\t\t\t\tvec4 lightData0 = texelFetch(lightsTexture, lightDataCoords, 0);\n\t\t\t\t\t\tif (lightData0.x == 1.0) {\n\t\t\t\t\t\t\t\tgetPointLightFromTexture(lightDataCoords, lightData0, clusteredPointLight);\n\t\t\t\t\t\t\t\tL = clusteredPointLight.position - v_modelPos;\n\t\t\t\t\t\t\t\tclusteredLightDistance = length(L);\n\t\t\t\t\t\t\t\tL = normalize(L);\n\t\t\t\t\t\t\t\tfalloff = pow(clamp(1. - clusteredLightDistance / clusteredPointLight.distance, 0.0, 1.0), clusteredPointLight.decay);\n\t\t\t\t\t\t\t\tclusteredLightColor = clusteredPointLight.color;\n\t\t\t\t\t\t} else if (lightData0.x == 2.0) {\n\t\t\t\t\t\t\t\tgetSpotLightFromTexture(lightDataCoords, lightData0, clusteredSpotLight);\n\t\t\t\t\t\t\t\tL = clusteredSpotLight.position - v_modelPos;\n\t\t\t\t\t\t\t\tclusteredLightDistance = length(L);\n\t\t\t\t\t\t\t\tL = normalize(L);\n\t\t\t\t\t\t\t\tclusteredAngleCos = dot(L, -normalize(clusteredSpotLight.direction));\n\t\t\t\t\t\t\t\tfalloff = smoothstep(clusteredSpotLight.coneCos, clusteredSpotLight.penumbraCos, clusteredAngleCos);\n\t\t\t\t\t\t\t\tfalloff *= pow(clamp(1. - clusteredLightDistance / clusteredSpotLight.distance, 0.0, 1.0), clusteredSpotLight.decay);\n\t\t\t\t\t\t\t\tclusteredLightColor = clusteredSpotLight.color;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdotNL = saturate(dot(N, L));\n\t\t\t\t\t\tirradiance = clusteredLightColor * falloff * dotNL * PI;\n\t\t\t\t\t\t#ifdef USE_CLEARCOAT\n\t\t\t\t\t\t\t\tccDotNL = saturate(dot(clearcoatNormal, L));\n\t\t\t\t\t\t\t\tccIrradiance = ccDotNL * clusteredLightColor * falloff * PI;\n\t\t\t\t\t\t\t\tclearcoatDHR = clearcoat * clearcoatDHRApprox(clearcoatRoughness, ccDotNL);\n\t\t\t\t\t\t\t\treflectedLight.directSpecular += ccIrradiance * clearcoat * BRDF_Specular_GGX(specularColor, clearcoatNormal, L, V, clearcoatRoughness);\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tclearcoatDHR = 0.0;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\treflectedLight.directDiffuse += (1.0 - clearcoatDHR) * irradiance * BRDF_Diffuse_Lambert(diffuseColor);\n\t\t\t\t\t\t#ifdef USE_PHONG\n\t\t\t\t\t\t\t\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong(specularColor, N, L, V, shininess) * specularStrength;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef USE_PBR\n\t\t\t\t\t\t\t\treflectedLight.directSpecular += (1.0 - clearcoatDHR) * irradiance * BRDF_Specular_GGX(specularColor, N, L, V, roughness);\n\t\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t}\n#endif\nvec3 indirectIrradiance = vec3(0., 0., 0.);\t \n#ifdef USE_AMBIENT_LIGHT\n\t\tindirectIrradiance += u_AmbientLightColor * PI;\n#endif\n#ifdef USE_SPHERICALHARMONICS_LIGHT\n\t\tindirectIrradiance += getLightProbeIrradiance(u_SphericalHarmonicsLightData, N);\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t\tfloat hemiDiffuseWeight;\n\t\t#pragma unroll_loop_start\n\t\tfor (int i = 0; i < NUM_HEMI_LIGHTS; i++) {\n\t\t\t\tL = normalize(u_Hemi[i].direction);\n\t\t\t\tdotNL = dot(N, L);\n\t\t\t\themiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\t\t\tindirectIrradiance += mix(u_Hemi[i].groundColor, u_Hemi[i].skyColor, hemiDiffuseWeight) * PI;\n\t\t}\n\t\t#pragma unroll_loop_end\n#endif\nreflectedLight.indirectDiffuse += indirectIrradiance * BRDF_Diffuse_Lambert(diffuseColor);\n#if defined(USE_ENV_MAP) && defined(USE_PBR)\n\t\tvec3 iblIrradiance = vec3(0., 0., 0.);\n\t\tvec3 indirectRadiance = vec3(0., 0., 0.);\n\t\tvec3 clearcoatRadiance = vec3(0., 0., 0.);\n\t\tvec3 envDir;\n\t\t#ifdef USE_VERTEX_ENVDIR\n\t\t\t\tenvDir = v_EnvDir;\n\t\t#else\n\t\t\t\tenvDir = reflect(normalize(v_modelPos - u_CameraPosition), N);\n\t\t#endif\n\t\tiblIrradiance += getLightProbeIndirectIrradiance(maxMipLevel, N);\n\t\tindirectRadiance += getLightProbeIndirectRadiance(roughness, maxMipLevel, N, envDir);\n\t\t#ifdef USE_CLEARCOAT\n\t\t\t\tvec3 clearcoatDir = reflect(normalize(v_modelPos - u_CameraPosition), clearcoatNormal);\n\t\t\t\tclearcoatRadiance += getLightProbeIndirectRadiance(clearcoatRoughness, maxMipLevel, clearcoatNormal, clearcoatDir);\n\t\t#endif\n\t\t#ifdef USE_CLEARCOAT\n\t\t\t\tfloat ccDotNV = saturate(dot(clearcoatNormal, V));\n\t\t\t\treflectedLight.indirectSpecular += clearcoatRadiance * clearcoat * BRDF_Specular_GGX_Environment(clearcoatNormal, V, specularColor, clearcoatRoughness);\n\t\t\t\tccDotNL = ccDotNV;\n\t\t\t\tclearcoatDHR = clearcoat * clearcoatDHRApprox(clearcoatRoughness, ccDotNL);\n\t\t#else\n\t\t\t\tclearcoatDHR = 0.0;\n\t\t#endif\n\t\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\t\tvec3 singleScattering = vec3(0.0);\n\t\tvec3 multiScattering = vec3(0.0);\n\t\tvec3 cosineWeightedIrradiance = iblIrradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment(N, V, specularColor, roughness, singleScattering, multiScattering);\n\t\tvec3 diffuse = diffuseColor * (1.0 - (singleScattering + multiScattering));\n\t\treflectedLight.indirectSpecular += clearcoatInv * indirectRadiance * singleScattering;\n\t\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n#endif",light_pars_frag:"#ifdef USE_AMBIENT_LIGHT\n\t\tuniform vec3 u_AmbientLightColor;\n#endif\n#ifdef USE_SPHERICALHARMONICS_LIGHT\n\t\tuniform vec3 u_SphericalHarmonicsLightData[9];\n#endif\n#ifdef USE_CLEARCOAT\n\t\tfloat clearcoatDHRApprox(const in float roughness, const in float dotNL) {\n\t\t\t\treturn 0.04 + (1.0 - 0.16) * (pow(1.0 - dotNL, 5.0) * pow(1.0 - roughness, 2.0));\n\t\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t\tstruct HemisphereLight {\n\t\t\t\tvec3 direction;\n\t\t\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t\t};\n\t\tuniform HemisphereLight u_Hemi[NUM_HEMI_LIGHTS];\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t\tstruct DirectLight {\n\t\t\t\tvec3 direction;\n\t\t\t\tvec3 color;\n\t\t};\n\t\tuniform DirectLight u_Directional[NUM_DIR_LIGHTS];\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t\tstruct PointLight {\n\t\t\t\tvec3 position;\n\t\t\t\tvec3 color;\n\t\t\t\tfloat distance;\n\t\t\t\tfloat decay;\n\t\t};\n\t\tuniform PointLight u_Point[NUM_POINT_LIGHTS];\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t\tstruct SpotLight {\n\t\t\t\tvec3 position;\n\t\t\t\tvec3 color;\n\t\t\t\tfloat distance;\n\t\t\t\tfloat decay;\n\t\t\t\tfloat coneCos;\n\t\t\t\tfloat penumbraCos;\n\t\t\t\tvec3 direction;\n\t\t};\n\t\tuniform SpotLight u_Spot[NUM_SPOT_LIGHTS];\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\t\tstruct RectAreaLight {\n\t\t\t\tvec3 position;\n\t\t\t\tvec3 color;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t\t};\n\t\tuniform RectAreaLight u_RectArea[NUM_RECT_AREA_LIGHTS];\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\t\tvoid LTC_RectCoords(const in vec3 lightPos, const in vec3 halfWidth, const in vec3 halfHeight, inout vec3 rectCoords[4]) {\n\t\t\t\trectCoords[0] = lightPos + halfWidth - halfHeight;\t\t\t\trectCoords[1] = lightPos - halfWidth - halfHeight;\n\t\t\t\trectCoords[2] = lightPos - halfWidth + halfHeight;\n\t\t\t\trectCoords[3] = lightPos + halfWidth + halfHeight;\n\t\t}\n\t\tvec2 LTC_Uv(const in vec3 N, const in vec3 V, const in float roughness) {\n\t\t\t\tconst float LUT_SIZE = 64.0; \n\t\t\t\tconst float LUT_SCALE = (LUT_SIZE - 1.0) / LUT_SIZE;\n\t\t\t\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\t\t\t\tfloat dotNV = saturate(dot(N, V));\n\t\t\t\tvec2 uv = vec2(roughness, sqrt(1.0 - dotNV));\n\t\t\t\tuv = uv * LUT_SCALE + LUT_BIAS;\n\t\t\t\treturn uv;\n\t\t}\n\t\tvec3 LTC_EdgeVectorFormFactor(const in vec3 v1, const in vec3 v2) {\n\t\t\t\tfloat x = dot(v1, v2);\n\t\t\t\tfloat y = abs(x);\n\t\t\t\tfloat a = 0.8543985 + (0.4965155 + 0.0145206 * y) * y;\n\t\t\t\tfloat b = 3.4175940 + (4.1616724 + y) * y;\n\t\t\t\tfloat v = a / b;\n\t\t\t\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt(max(1.0 - x * x, 1e-7)) - v;\n\t\t\t\treturn cross(v1, v2) * theta_sintheta;\n\t\t}\n\t\tfloat LTC_ClippedSphereFormFactor(const in vec3 f) {\n\t\t\t\tfloat l = length(f);\n\t\t\t\treturn max((l * l + f.z) / (l + 1.0), 0.0);\n\t\t}\n\t\tvec3 LTC_Evaluate(const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[4]) {\n\t\t\t\tvec3 v1 = rectCoords[1] - rectCoords[0];\n\t\t\t\tvec3 v2 = rectCoords[3] - rectCoords[0];\n\t\t\t\tvec3 lightNormal = cross(v1, v2);\n\t\t\t\tif(dot(lightNormal, P - rectCoords[0]) < 0.0) return vec3(0.0);\n\t\t\t\tvec3 T1, T2;\n\t\t\t\tT1 = normalize(V - N * dot(V, N));\n\t\t\t\tT2 = - cross(N, T1);\n\t\t\t\tmat3 mat = mInv * mat3(\n\t\t\t\t\t\tT1.x, T2.x, N.x,\n\t\t\t\t\t\tT1.y, T2.y, N.y,\n\t\t\t\t\t\tT1.z, T2.z, N.z\n\t\t\t\t);\n\t\t\t\tvec3 coords[4];\n\t\t\t\tcoords[0] = mat * (rectCoords[0] - P);\n\t\t\t\tcoords[1] = mat * (rectCoords[1] - P);\n\t\t\t\tcoords[2] = mat * (rectCoords[2] - P);\n\t\t\t\tcoords[3] = mat * (rectCoords[3] - P);\n\t\t\t\tcoords[0] = normalize(coords[0]);\n\t\t\t\tcoords[1] = normalize(coords[1]);\n\t\t\t\tcoords[2] = normalize(coords[2]);\n\t\t\t\tcoords[3] = normalize(coords[3]);\n\t\t\t\tvec3 vectorFormFactor = vec3(0.0);\n\t\t\t\tvectorFormFactor += LTC_EdgeVectorFormFactor(coords[0], coords[1]);\n\t\t\t\tvectorFormFactor += LTC_EdgeVectorFormFactor(coords[1], coords[2]);\n\t\t\t\tvectorFormFactor += LTC_EdgeVectorFormFactor(coords[2], coords[3]);\n\t\t\t\tvectorFormFactor += LTC_EdgeVectorFormFactor(coords[3], coords[0]);\n\t\t\t\tfloat result = LTC_ClippedSphereFormFactor(vectorFormFactor);\n\t\t\t\treturn vec3(result);\n\t\t}\n\t\tvec3 LTC_Diffuse(const in vec3 diffuseColor, const in vec3 N, const in vec3 V, const in vec3 P, const in vec3 rectCoords[4]) {\n\t\t\t\treturn diffuseColor * LTC_Evaluate(N, V, P, mat3(1.0), rectCoords);\n\t\t}\n\t\tvec3 LTC_Specular(const in vec3 specularColor, const in vec3 N, const in vec3 V, const in vec3 P, const in vec3 rectCoords[4], const in float roughness) {\n\t\t\t\tvec2 ltc_uv = LTC_Uv(N, V, roughness);\n\t\t\t\tvec4 t1 = texture2D(ltc_1, ltc_uv);\n\t\t\t\tvec4 t2 = texture2D(ltc_2, ltc_uv);\n\t\t\t\tmat3 mInv = mat3(\n\t\t\t\t\t\tvec3(t1.x, 0, t1.y),\n\t\t\t\t\t\tvec3(0, 1, 0),\n\t\t\t\t\t\tvec3(t1.z, 0, t1.w)\n\t\t\t\t);\n\t\t\t\tvec3 fresnel = (specularColor * t2.x + (vec3(1.0) - specularColor) * t2.y);\n\t\t\t\treturn fresnel * LTC_Evaluate(N, V, P, mInv, rectCoords);\n\t\t}\n#endif\n#if defined(USE_PBR) && defined(USE_ENV_MAP)\n\t\tvec3 getLightProbeIndirectIrradiance(const in int maxMIPLevel, const in vec3 N) {\n\t\t\t\tvec3 coordVec = vec3(envMapParams.z * N.x, N.yz);\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT(envMap, coordVec, float(maxMIPLevel));\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube(envMap, coordVec, float(maxMIPLevel));\n\t\t\t#endif\n\t\t\t\tenvMapColor = envMapTexelToLinear(envMapColor);\n\t\t\t\treturn PI * envMapColor.rgb * envMapParams.x;\n\t\t}\n\t\tfloat getSpecularMIPLevel(const in float roughness, const in int maxMIPLevel) {\n\t\t\tfloat maxMIPLevelScalar = float(maxMIPLevel);\n\t\t\t\tfloat sigma = PI * roughness * roughness / (1.0 + roughness);\n\t\t\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2(sigma);\n\t\t\treturn clamp(desiredMIPLevel, 0.0, maxMIPLevelScalar);\n\t\t}\n\t\tvec3 getLightProbeIndirectRadiance(const in float roughness, const in int maxMIPLevel, const in vec3 normal, const in vec3 envDir) {\n\t\t\t\tfloat specularMIPLevel = getSpecularMIPLevel(roughness, maxMIPLevel);\n\t\t\t\tvec3 coordVec = normalize(mix(envDir, normal, roughness * roughness));\n\t\t\t\tcoordVec.x *= envMapParams.z;\n\t\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT(envMap, coordVec, specularMIPLevel);\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube(envMap, coordVec, specularMIPLevel);\n\t\t\t#endif\n\t\t\t\tenvMapColor = envMapTexelToLinear(envMapColor);\n\t\t\t\treturn envMapColor.rgb * envMapParams.y;\n\t\t}\n\t\tfloat computeSpecularOcclusion(const in float dotNV, const in float ambientOcclusion, const in float roughness) {\n\t\t\treturn saturate(pow(dotNV + ambientOcclusion, exp2(-16.0 * roughness - 1.0)) - 1.0 + ambientOcclusion);\n\t\t}\n#endif\n#ifdef USE_SPHERICALHARMONICS_LIGHT\n\t\tvec3 shGetIrradianceAt(in vec3 normal, in vec3 shCoefficients[9]) {\n\t\t\t\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t\t\t\tvec3 result = shCoefficients[0] * 0.886227;\n\t\t\t\tresult += shCoefficients[1] * 2.0 * 0.511664 * y;\n\t\t\t\tresult += shCoefficients[2] * 2.0 * 0.511664 * z;\n\t\t\t\tresult += shCoefficients[3] * 2.0 * 0.511664 * x;\n\t\t\t\tresult += shCoefficients[4] * 2.0 * 0.429043 * x * y;\n\t\t\t\tresult += shCoefficients[5] * 2.0 * 0.429043 * y * z;\n\t\t\t\tresult += shCoefficients[6] * (0.743125 * z * z - 0.247708);\n\t\t\t\tresult += shCoefficients[7] * 2.0 * 0.429043 * x * z;\n\t\t\t\tresult += shCoefficients[8] * 0.429043 * (x * x - y * y);\n\t\t\t\treturn result;\n\t\t}\n\t\tvec3 getLightProbeIrradiance(const in vec3 lightProbe[9], const in vec3 normal) {\n\t\t\t\tvec3 irradiance = shGetIrradianceAt(normal, lightProbe);\n\t\t\t\treturn irradiance;\n\t\t}\n#endif\n#ifdef USE_CLUSTERED_LIGHTS\n\t\tuniform vec3 cells;\n\t\tuniform int maxLightsPerCell;\n\t\tuniform vec3 cellsDotData;\n\t\tuniform vec3 cellsTextureSize;\n\t\tuniform vec4 cellsTransformFactors;\n\t\tuniform sampler2D cellsTexture;\n\t\tuniform sampler2D lightsTexture;\n\t\tstruct ClusteredPointLight {\n\t\t\t\tvec3 position;\n\t\t\t\tvec3 color;\n\t\t\t\tfloat distance;\n\t\t\t\tfloat decay;\n\t\t};\n\t\tstruct ClusteredSpotLight {\n\t\t\t\tvec3 position;\n\t\t\t\tvec3 color;\n\t\t\t\tfloat distance;\n\t\t\t\tfloat decay;\n\t\t\t\tvec3 direction;\n\t\t\t\tfloat coneCos;\n\t\t\t\tfloat penumbraCos;\n\t\t};\n\t\tvoid getPointLightFromTexture(ivec2 lightDataCoords, vec4 lightData0, inout ClusteredPointLight pointLight) {\n\t\t\t\tvec4 lightData1 = texelFetch(lightsTexture, lightDataCoords + ivec2(1, 0), 0);\n\t\t\t\tvec4 lightData2 = texelFetch(lightsTexture, lightDataCoords + ivec2(2, 0), 0);\n\t\t\t\tpointLight.color = lightData1.xyz;\n\t\t\t\tpointLight.decay = lightData1.w;\n\t\t\t\tpointLight.position = lightData2.xyz;\n\t\t\t\tpointLight.distance = lightData2.w;\n\t\t}\n\t\tvoid getSpotLightFromTexture(ivec2 lightDataCoords, vec4 lightData0, inout ClusteredSpotLight spotLight) {\n\t\t\t\tvec4 lightData1 = texelFetch(lightsTexture, lightDataCoords + ivec2(1, 0), 0);\n\t\t\t\tvec4 lightData2 = texelFetch(lightsTexture, lightDataCoords + ivec2(2, 0), 0);\n\t\t\t\tvec4 lightData3 = texelFetch(lightsTexture, lightDataCoords + ivec2(3, 0), 0);\n\t\t\t\tspotLight.color = lightData1.xyz;\n\t\t\t\tspotLight.decay = lightData1.w;\n\t\t\t\tspotLight.position = lightData2.xyz;\n\t\t\t\tspotLight.distance = lightData2.w;\n\t\t\t\tspotLight.direction = lightData3.xyz;\n\t\t\t\tspotLight.coneCos = lightData3.w;\n\t\t\t\tspotLight.penumbraCos = lightData0.y;\n\t\t}\n#endif",alphamap_pars_frag:"#ifdef USE_ALPHA_MAP\n\tuniform sampler2D alphaMap;\n\tvarying vec2 vAlphaMapUV;\n#endif",alphamap_frag:"#ifdef USE_ALPHA_MAP\n\toutColor.a *= texture2D(alphaMap, vAlphaMapUV).g;\n#endif",alphamap_pars_vert:"#ifdef USE_ALPHA_MAP\n\t\tuniform mat3 alphaMapUVTransform;\n\tvarying vec2 vAlphaMapUV;\n#endif",alphamap_vert:"#ifdef USE_ALPHA_MAP\n\tvAlphaMapUV = (alphaMapUVTransform * vec3(ALPHAMAP_UV, 1.)).xy;\n#endif",normalMap_pars_frag:"#ifdef USE_NORMAL_MAP\n\t\tuniform sampler2D normalMap;\n\t\tuniform vec2 normalScale;\n#endif\n#if defined(USE_NORMAL_MAP) || defined(USE_CLEARCOAT_NORMALMAP)\n\t\t#if defined(USE_TANGENT) && !defined(FLAT_SHADED)\n\t\t\t\t#define USE_TBN\n\t\t#else\n\t\t\t\t#include <tsn>\n\t\t#endif\n#endif",normal_frag:"\n#ifdef FLAT_SHADED\n\t\tvec3 fdx = dFdx(v_modelPos);\n\t\tvec3 fdy = dFdy(v_modelPos);\n\t\tvec3 N = normalize(cross(fdx, fdy));\n#else\n\t\tvec3 N = normalize(v_Normal);\n\t\t#ifdef DOUBLE_SIDED\n\t\t\t\tN = N * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t#endif\n#endif\n#ifdef USE_TBN\n\tvec3 tangent = normalize(v_Tangent);\n\tvec3 bitangent = normalize(v_Bitangent);\n\t#ifdef DOUBLE_SIDED\n\t\ttangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\tbitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t#endif\n\tmat3 tspace = mat3(tangent, bitangent, N);\n#endif\nvec3 geometryNormal = N;\n#ifdef USE_NORMAL_MAP\n\t\tvec3 mapN = texture2D(normalMap, v_Uv).rgb * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\t#ifdef USE_TBN\n\t\t\t\tN = normalize(tspace * mapN);\n\t\t#else\n\t\t\t\tmapN.xy *= (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t\t\tN = normalize(tsn(N, v_modelPos, v_Uv) * mapN);\n\t\t#endif\n#elif defined(USE_BUMPMAP)\n\t\tN = perturbNormalArb(v_modelPos, N, dHdxy_fwd(v_Uv));\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D(clearcoatNormalMap, v_Uv).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TBN\n\t\tclearcoatNormal = normalize(tspace * clearcoatMapN);\n\t#else\n\t\tclearcoatMapN.xy *= (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\tclearcoatNormal = normalize(tsn(clearcoatNormal, v_modelPos, v_Uv) * clearcoatMapN);\n\t#endif\n#endif",normal_pars_frag:"#ifndef FLAT_SHADED\n\t\tvarying vec3 v_Normal;\n\t\t#ifdef USE_TANGENT\n\t\t\t\tvarying vec3 v_Tangent;\n\t\tvarying vec3 v_Bitangent;\n\t\t#endif\n#endif",normal_pars_vert:"#ifndef FLAT_SHADED\n\t\tvarying vec3 v_Normal;\n\t\t#ifdef USE_TANGENT\n\t\t\t\tvarying vec3 v_Tangent;\n\t\tvarying vec3 v_Bitangent;\n\t\t#endif\n#endif",normal_vert:"#ifndef FLAT_SHADED\n\t\tv_Normal = (transposeMat4(inverseMat4(u_Model)) * vec4(objectNormal, 0.0)).xyz;\n\t\t#ifdef FLIP_SIDED\n\t\t\tv_Normal = - v_Normal;\n\t\t#endif\n\t\t#ifdef USE_TANGENT\n\t\t\t\tv_Tangent = (transposeMat4(inverseMat4(u_Model)) * vec4(objectTangent, 0.0)).xyz;\n\t\t\t\t#ifdef FLIP_SIDED\n\t\t\t\t\t\tv_Tangent = - v_Tangent;\n\t\t\t\t#endif\n\t\t\t\tv_Bitangent = normalize(cross(v_Normal, v_Tangent) * a_Tangent.w);\n\t\t#endif\n#endif",packing:"const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,\t256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\t\tvec4 r = vec4( fract( v * PackFactors ), v );\n\t\tr.yzw -= r.xyz * ShiftRight8;\t\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\t\treturn dot( v, UnpackFactors );\n}",premultipliedAlpha_frag:"#ifdef USE_PREMULTIPLIED_ALPHA\n\t\tgl_FragColor.rgb = gl_FragColor.rgb * gl_FragColor.a;\n#endif",pvm_vert:"vec4 worldPosition = u_Model * vec4(transformed, 1.0);\ngl_Position = u_ProjectionView * worldPosition;",dithering_frag:"#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_frag:"#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",shadow:"#ifdef USE_SHADOW_SAMPLER\n\t\tfloat computeShadow(sampler2DShadow shadowMap, vec3 shadowCoord) {\n\t\t\t\treturn texture2D( shadowMap, shadowCoord );\n\t\t}\n#else\n\t\tfloat computeShadow(sampler2D shadowMap, vec3 shadowCoord) {\n\t\t\t\treturn step(shadowCoord.z, unpackRGBAToDepth(texture2D(shadowMap, shadowCoord.xy)));\n\t\t}\n#endif\nfloat computeShadowWithPoissonSampling(sampler2DShadow shadowMap, vec3 shadowCoord, float texelSize) {\n\t\tvec3 poissonDisk[4];\n\t\tpoissonDisk[0] = vec3(-0.94201624, -0.39906216, 0);\n\t\tpoissonDisk[1] = vec3(0.94558609, -0.76890725, 0);\n\t\tpoissonDisk[2] = vec3(-0.094184101, -0.92938870, 0);\n\t\tpoissonDisk[3] = vec3(0.34495938, 0.29387760, 0);\n\t\treturn computeShadow(shadowMap, shadowCoord + poissonDisk[0] * texelSize) * 0.25 +\n\t\t\t\tcomputeShadow(shadowMap, shadowCoord + poissonDisk[1] * texelSize) * 0.25 +\n\t\t\t\tcomputeShadow(shadowMap, shadowCoord + poissonDisk[2] * texelSize) * 0.25 +\n\t\t\t\tcomputeShadow(shadowMap, shadowCoord + poissonDisk[3] * texelSize) * 0.25;\n}\nfloat computeShadowWithPCF1(sampler2DShadow shadowSampler, vec3 shadowCoord) {\n\t\treturn computeShadow(shadowSampler, shadowCoord);\n}\nfloat computeShadowWithPCF3(sampler2DShadow shadowSampler, vec3 shadowCoord, vec2 shadowMapSizeAndInverse) {\n\t\tvec2 uv = shadowCoord.xy * shadowMapSizeAndInverse.x;\t\tuv += 0.5;\t\tvec2 st = fract(uv);\t\tvec2 base_uv = floor(uv) - 0.5;\t\tbase_uv *= shadowMapSizeAndInverse.y;\n\t\tvec2 uvw0 = 3. - 2. * st;\n\t\tvec2 uvw1 = 1. + 2. * st;\n\t\tvec2 u = vec2((2. - st.x) / uvw0.x - 1., st.x / uvw1.x + 1.) * shadowMapSizeAndInverse.y;\n\t\tvec2 v = vec2((2. - st.y) / uvw0.y - 1., st.y / uvw1.y + 1.) * shadowMapSizeAndInverse.y;\n\t\tfloat shadow = 0.;\n\t\tshadow += uvw0.x * uvw0.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[0], v[0]), shadowCoord.z));\n\t\tshadow += uvw1.x * uvw0.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[1], v[0]), shadowCoord.z));\n\t\tshadow += uvw0.x * uvw1.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[0], v[1]), shadowCoord.z));\n\t\tshadow += uvw1.x * uvw1.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[1], v[1]), shadowCoord.z));\n\t\tshadow = shadow / 16.;\n\t\treturn shadow;\n}\nfloat computeShadowWithPCF5(sampler2DShadow shadowSampler, vec3 shadowCoord, vec2 shadowMapSizeAndInverse) {\n\t\tvec2 uv = shadowCoord.xy * shadowMapSizeAndInverse.x;\t\tuv += 0.5;\t\tvec2 st = fract(uv);\t\tvec2 base_uv = floor(uv) - 0.5;\t\tbase_uv *= shadowMapSizeAndInverse.y;\n\t\tvec2 uvw0 = 4. - 3. * st;\n\t\tvec2 uvw1 = vec2(7.);\n\t\tvec2 uvw2 = 1. + 3. * st;\n\t\tvec3 u = vec3((3. - 2. * st.x) / uvw0.x - 2., (3. + st.x) / uvw1.x, st.x / uvw2.x + 2.) * shadowMapSizeAndInverse.y;\n\t\tvec3 v = vec3((3. - 2. * st.y) / uvw0.y - 2., (3. + st.y) / uvw1.y, st.y / uvw2.y + 2.) * shadowMapSizeAndInverse.y;\n\t\tfloat shadow = 0.;\n\t\tshadow += uvw0.x * uvw0.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[0], v[0]), shadowCoord.z));\n\t\tshadow += uvw1.x * uvw0.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[1], v[0]), shadowCoord.z));\n\t\tshadow += uvw2.x * uvw0.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[2], v[0]), shadowCoord.z));\n\t\tshadow += uvw0.x * uvw1.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[0], v[1]), shadowCoord.z));\n\t\tshadow += uvw1.x * uvw1.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[1], v[1]), shadowCoord.z));\n\t\tshadow += uvw2.x * uvw1.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[2], v[1]), shadowCoord.z));\n\t\tshadow += uvw0.x * uvw2.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[0], v[2]), shadowCoord.z));\n\t\tshadow += uvw1.x * uvw2.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[1], v[2]), shadowCoord.z));\n\t\tshadow += uvw2.x * uvw2.y * computeShadow(shadowSampler, vec3(base_uv.xy + vec2(u[2], v[2]), shadowCoord.z));\n\t\tshadow = shadow / 144.;\n\t\treturn shadow;\n}\nfloat computeFallOff(float value, vec2 clipSpace, float frustumEdgeFalloff) {\n\t\tfloat factor = mix(clipSpace.y * abs(clipSpace.y), dot(clipSpace, clipSpace), step(0., frustumEdgeFalloff));\n\t\tfloat mask = smoothstep(1.0 - abs(frustumEdgeFalloff), 1.00000012, clamp(factor, 0., 1.));\n\t\treturn mix(value, 1.0, mask);\n}\nfloat getShadow(sampler2DShadow shadowMap, vec4 shadowCoord, vec2 shadowMapSize, vec2 shadowBias, vec2 shadowParams) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias.x;\n\t\tbvec4 inFrustumVec = bvec4 (shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0);\n\t\tbool inFrustum = all(inFrustumVec);\n\t\tbvec2 frustumTestVec = bvec2(inFrustum, shadowCoord.z <= 1.0);\n\t\tbool frustumTest = all(frustumTestVec);\n\t\tfloat shadow = 1.0;\n\t\tif (frustumTest) {\n\t\t\t\t#ifdef USE_HARD_SHADOW\n\t\t\t\t\t\tshadow = computeShadow(shadowMap, shadowCoord.xyz);\n\t\t\t\t#else\n\t\t\t\t\t\t#ifdef USE_PCF3_SOFT_SHADOW\n\t\t\t\t\t\t\t\tvec2 shadowMapSizeAndInverse = vec2(shadowMapSize.x, 1. / shadowMapSize.x);\n\t\t\t\t\t\t\t\tshadow = computeShadowWithPCF3(shadowMap, shadowCoord.xyz, shadowMapSizeAndInverse);\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t#ifdef USE_PCF5_SOFT_SHADOW\n\t\t\t\t\t\t\t\t\t\tvec2 shadowMapSizeAndInverse = vec2(shadowMapSize.x, 1. / shadowMapSize.x);\n\t\t\t\t\t\t\t\t\t\tshadow = computeShadowWithPCF5(shadowMap, shadowCoord.xyz, shadowMapSizeAndInverse);\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\tfloat texelSize = shadowParams.x * 0.5 / shadowMapSize.x;\n\t\t\t\t\t\t\t\t\t\tshadow = computeShadowWithPoissonSampling(shadowMap, shadowCoord.xyz, texelSize);\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\tshadow = computeFallOff(shadow, shadowCoord.xy * 2. - 1., shadowParams.y);\n\t\t}\n\t\treturn shadow;\n}\nfloat textureCubeCompare(samplerCube depths, vec3 uv, float compare) {\n\t\treturn step(compare, unpackRGBAToDepth(textureCube(depths, uv)));\n}\nfloat getPointShadow(samplerCube shadowMap, vec4 shadowCoord, vec2 shadowMapSize, vec2 shadowBias, vec2 shadowParams, vec2 shadowCameraRange) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat lightToPositionLength = length(lightToPosition);\n\t\tif (lightToPositionLength - shadowCameraRange.y <= 0.0 && lightToPositionLength - shadowCameraRange.x >= 0.0) {\n\t\t\t\tfloat dp = (lightToPositionLength - shadowCameraRange.x) / (shadowCameraRange.y - shadowCameraRange.x);\n\t\t\t\tdp += shadowBias.x;\n\t\tvec3 bd3D = normalize(lightToPosition);\n\t\t\t\t#ifdef USE_HARD_SHADOW\n\t\t\t\t\t\tshadow = textureCubeCompare(shadowMap, bd3D, dp);\n\t\t\t\t#else\n\t\t\t\t\t\tfloat texelSize = shadowParams.x * 0.5 / shadowMapSize.x;\n\t\t\t\t\t\tvec2 offset = vec2(-1.0, 1.0) * texelSize;\n\t\t\t\t\t\tshadow = (\n\t\t\t\t\t\t\t\ttextureCubeCompare(shadowMap, bd3D + offset.xyy, dp) +\n\t\t\t\t\t\t\t\ttextureCubeCompare(shadowMap, bd3D + offset.yyy, dp) +\n\t\t\t\t\t\t\t\ttextureCubeCompare(shadowMap, bd3D + offset.xyx, dp) +\n\t\t\t\t\t\t\t\ttextureCubeCompare(shadowMap, bd3D + offset.yyx, dp) +\n\t\t\t\t\t\t\t\ttextureCubeCompare(shadowMap, bd3D, dp) +\n\t\t\t\t\t\t\t\ttextureCubeCompare(shadowMap, bd3D + offset.xxy, dp) +\n\t\t\t\t\t\t\t\ttextureCubeCompare(shadowMap, bd3D + offset.yxy, dp) +\n\t\t\t\t\t\t\t\ttextureCubeCompare(shadowMap, bd3D + offset.xxx, dp) +\n\t\t\t\t\t\t\t\ttextureCubeCompare(shadowMap, bd3D + offset.yxx, dp)\n\t\t\t\t\t\t) * (1.0 / 9.0);\n\t\t\t\t#endif\n\t\t}\n\t\treturn shadow;\n}\n#ifdef USE_PCSS_SOFT_SHADOW\n\t\tconst vec3 PoissonSamplers32[64] = vec3[64](\n\t\t\t\tvec3(0.06407013, 0.05409927, 0.),\n\t\t\t\tvec3(0.7366577, 0.5789394, 0.),\n\t\t\t\tvec3(-0.6270542, -0.5320278, 0.),\n\t\t\t\tvec3(-0.4096107, 0.8411095, 0.),\n\t\t\t\tvec3(0.6849564, -0.4990818, 0.),\n\t\t\t\tvec3(-0.874181, -0.04579735, 0.),\n\t\t\t\tvec3(0.9989998, 0.0009880066, 0.),\n\t\t\t\tvec3(-0.004920578, -0.9151649, 0.),\n\t\t\t\tvec3(0.1805763, 0.9747483, 0.),\n\t\t\t\tvec3(-0.2138451, 0.2635818, 0.),\n\t\t\t\tvec3(0.109845, 0.3884785, 0.),\n\t\t\t\tvec3(0.06876755, -0.3581074, 0.),\n\t\t\t\tvec3(0.374073, -0.7661266, 0.),\n\t\t\t\tvec3(0.3079132, -0.1216763, 0.),\n\t\t\t\tvec3(-0.3794335, -0.8271583, 0.),\n\t\t\t\tvec3(-0.203878, -0.07715034, 0.),\n\t\t\t\tvec3(0.5912697, 0.1469799, 0.),\n\t\t\t\tvec3(-0.88069, 0.3031784, 0.),\n\t\t\t\tvec3(0.5040108, 0.8283722, 0.),\n\t\t\t\tvec3(-0.5844124, 0.5494877, 0.),\n\t\t\t\tvec3(0.6017799, -0.1726654, 0.),\n\t\t\t\tvec3(-0.5554981, 0.1559997, 0.),\n\t\t\t\tvec3(-0.3016369, -0.3900928, 0.),\n\t\t\t\tvec3(-0.5550632, -0.1723762, 0.),\n\t\t\t\tvec3(0.925029, 0.2995041, 0.),\n\t\t\t\tvec3(-0.2473137, 0.5538505, 0.),\n\t\t\t\tvec3(0.9183037, -0.2862392, 0.),\n\t\t\t\tvec3(0.2469421, 0.6718712, 0.),\n\t\t\t\tvec3(0.3916397, -0.4328209, 0.),\n\t\t\t\tvec3(-0.03576927, -0.6220032, 0.),\n\t\t\t\tvec3(-0.04661255, 0.7995201, 0.),\n\t\t\t\tvec3(0.4402924, 0.3640312, 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.),\n\t\t\t\tvec3(0., 0., 0.)\n\t\t);\n\t\tconst vec3 PoissonSamplers64[64] = vec3[64](\n\t\t\t\tvec3(-0.613392, 0.617481, 0.),\n\t\t\t\tvec3(0.170019, -0.040254, 0.),\n\t\t\t\tvec3(-0.299417, 0.791925, 0.),\n\t\t\t\tvec3(0.645680, 0.493210, 0.),\n\t\t\t\tvec3(-0.651784, 0.717887, 0.),\n\t\t\t\tvec3(0.421003, 0.027070, 0.),\n\t\t\t\tvec3(-0.817194, -0.271096, 0.),\n\t\t\t\tvec3(-0.705374, -0.668203, 0.),\n\t\t\t\tvec3(0.977050, -0.108615, 0.),\n\t\t\t\tvec3(0.063326, 0.142369, 0.),\n\t\t\t\tvec3(0.203528, 0.214331, 0.),\n\t\t\t\tvec3(-0.667531, 0.326090, 0.),\n\t\t\t\tvec3(-0.098422, -0.295755, 0.),\n\t\t\t\tvec3(-0.885922, 0.215369, 0.),\n\t\t\t\tvec3(0.566637, 0.605213, 0.),\n\t\t\t\tvec3(0.039766, -0.396100, 0.),\n\t\t\t\tvec3(0.751946, 0.453352, 0.),\n\t\t\t\tvec3(0.078707, -0.715323, 0.),\n\t\t\t\tvec3(-0.075838, -0.529344, 0.),\n\t\t\t\tvec3(0.724479, -0.580798, 0.),\n\t\t\t\tvec3(0.222999, -0.215125, 0.),\n\t\t\t\tvec3(-0.467574, -0.405438, 0.),\n\t\t\t\tvec3(-0.248268, -0.814753, 0.),\n\t\t\t\tvec3(0.354411, -0.887570, 0.),\n\t\t\t\tvec3(0.175817, 0.382366, 0.),\n\t\t\t\tvec3(0.487472, -0.063082, 0.),\n\t\t\t\tvec3(-0.084078, 0.898312, 0.),\n\t\t\t\tvec3(0.488876, -0.783441, 0.),\n\t\t\t\tvec3(0.470016, 0.217933, 0.),\n\t\t\t\tvec3(-0.696890, -0.549791, 0.),\n\t\t\t\tvec3(-0.149693, 0.605762, 0.),\n\t\t\t\tvec3(0.034211, 0.979980, 0.),\n\t\t\t\tvec3(0.503098, -0.308878, 0.),\n\t\t\t\tvec3(-0.016205, -0.872921, 0.),\n\t\t\t\tvec3(0.385784, -0.393902, 0.),\n\t\t\t\tvec3(-0.146886, -0.859249, 0.),\n\t\t\t\tvec3(0.643361, 0.164098, 0.),\n\t\t\t\tvec3(0.634388, -0.049471, 0.),\n\t\t\t\tvec3(-0.688894, 0.007843, 0.),\n\t\t\t\tvec3(0.464034, -0.188818, 0.),\n\t\t\t\tvec3(-0.440840, 0.137486, 0.),\n\t\t\t\tvec3(0.364483, 0.511704, 0.),\n\t\t\t\tvec3(0.034028, 0.325968, 0.),\n\t\t\t\tvec3(0.099094, -0.308023, 0.),\n\t\t\t\tvec3(0.693960, -0.366253, 0.),\n\t\t\t\tvec3(0.678884, -0.204688, 0.),\n\t\t\t\tvec3(0.001801, 0.780328, 0.),\n\t\t\t\tvec3(0.145177, -0.898984, 0.),\n\t\t\t\tvec3(0.062655, -0.611866, 0.),\n\t\t\t\tvec3(0.315226, -0.604297, 0.),\n\t\t\t\tvec3(-0.780145, 0.486251, 0.),\n\t\t\t\tvec3(-0.371868, 0.882138, 0.),\n\t\t\t\tvec3(0.200476, 0.494430, 0.),\n\t\t\t\tvec3(-0.494552, -0.711051, 0.),\n\t\t\t\tvec3(0.612476, 0.705252, 0.),\n\t\t\t\tvec3(-0.578845, -0.768792, 0.),\n\t\t\t\tvec3(-0.772454, -0.090976, 0.),\n\t\t\t\tvec3(0.504440, 0.372295, 0.),\n\t\t\t\tvec3(0.155736, 0.065157, 0.),\n\t\t\t\tvec3(0.391522, 0.849605, 0.),\n\t\t\t\tvec3(-0.620106, -0.328104, 0.),\n\t\t\t\tvec3(0.789239, -0.419965, 0.),\n\t\t\t\tvec3(-0.545396, 0.538133, 0.),\n\t\t\t\tvec3(-0.178564, -0.596057, 0.)\n\t\t);\n\t\tfloat getRand(vec2 seed) {\n\t\t\t\treturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\t}\n\t\tfloat computeShadowWithPCSS(sampler2D depthSampler, sampler2DShadow shadowSampler, vec3 shadowCoord, float shadowMapSizeInverse, float lightSizeUV, int searchTapCount, int pcfTapCount, vec3[64] poissonSamplers) {\n\t\t\t\tfloat depthMetric = shadowCoord.z;\n\t\t\t\tfloat blockerDepth = 0.0;\n\t\t\t\tfloat sumBlockerDepth = 0.0;\n\t\t\t\tfloat numBlocker = 0.0;\n\t\t\t\tfor (int i = 0; i < searchTapCount; i++) {\n\t\t\t\t\t\tblockerDepth = unpackRGBAToDepth(texture(depthSampler, shadowCoord.xy + (lightSizeUV * shadowMapSizeInverse * PoissonSamplers32[i].xy)));\n\t\t\t\t\t\tif (blockerDepth < depthMetric) {\n\t\t\t\t\t\t\t\tsumBlockerDepth += blockerDepth;\n\t\t\t\t\t\t\t\tnumBlocker++;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (numBlocker < 1.0) {\n\t\t\t\t\t\treturn 1.0;\n\t\t\t\t}\n\t\t\t\tfloat avgBlockerDepth = sumBlockerDepth / numBlocker;\n\t\t\t\tfloat AAOffset = shadowMapSizeInverse * 10.;\n\t\t\t\tfloat penumbraRatio = ((depthMetric - avgBlockerDepth) + AAOffset);\n\t\t\t\tfloat filterRadius = penumbraRatio * lightSizeUV * shadowMapSizeInverse;\n\t\t\t\tfloat random = getRand(shadowCoord.xy);\t\t\t\tfloat rotationAngle = random * 3.1415926;\n\t\t\t\tvec2 rotationVector = vec2(cos(rotationAngle), sin(rotationAngle));\n\t\t\t\tfloat shadow = 0.;\n\t\t\t\tfor (int i = 0; i < pcfTapCount; i++) {\n\t\t\t\t\t\tvec3 offset = poissonSamplers[i];\n\t\t\t\t\t\toffset = vec3(offset.x * rotationVector.x - offset.y * rotationVector.y, offset.y * rotationVector.x + offset.x * rotationVector.y, 0.);\n\t\t\t\t\t\tshadow += texture(shadowSampler, shadowCoord + offset * filterRadius);\n\t\t\t\t}\n\t\t\t\tshadow /= float(pcfTapCount);\n\t\t\t\tshadow = mix(shadow, 1., depthMetric - avgBlockerDepth);\n\t\t\t\treturn shadow;\n\t\t}\n\t\tfloat getShadowWithPCSS(sampler2D depthSampler, sampler2DShadow shadowMap, vec4 shadowCoord, vec2 shadowMapSize, vec2 shadowBias, vec2 shadowParams) {\n\t\t\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\t\t\tshadowCoord.z += shadowBias.x;\n\t\t\t\tbvec4 inFrustumVec = bvec4 (shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0);\n\t\t\t\tbool inFrustum = all(inFrustumVec);\n\t\t\t\tbvec2 frustumTestVec = bvec2(inFrustum, shadowCoord.z <= 1.0);\n\t\t\t\tbool frustumTest = all(frustumTestVec);\n\t\t\t\tfloat shadow = 1.0;\n\t\t\t\tif (frustumTest) {\n\t\t\t\t\t\t#ifdef USE_PCSS16_SOFT_SHADOW\n\t\t\t\t\t\t\t\tshadow = computeShadowWithPCSS(depthSampler, shadowMap, shadowCoord.xyz, 1. / shadowMapSize.x, 0.1 * shadowMapSize.x, 16, 16, PoissonSamplers32);\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t#ifdef USE_PCSS32_SOFT_SHADOW\n\t\t\t\t\t\t\t\t\t\tshadow = computeShadowWithPCSS(depthSampler, shadowMap, shadowCoord.xyz, 1. / shadowMapSize.x, 0.1 * shadowMapSize.x, 16, 32, PoissonSamplers32);\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\tshadow = computeShadowWithPCSS(depthSampler, shadowMap, shadowCoord.xyz, 1. / shadowMapSize.x, 0.1 * shadowMapSize.x, 32, 64, PoissonSamplers64);\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tshadow = computeFallOff(shadow, shadowCoord.xy * 2. - 1., shadowParams.y);\n\t\t\t\t}\n\t\t\t\treturn shadow;\n\t\t}\n#endif",shadowMap_frag:"#ifdef USE_SHADOW\n#endif",shadowMap_pars_frag:"#ifdef USE_SHADOW\n\t#if NUM_DIR_SHADOWS > 0\n\t\tuniform sampler2DShadow directionalShadowMap[NUM_DIR_SHADOWS];\n\t\tvarying vec4 vDirectionalShadowCoord[NUM_DIR_SHADOWS];\n\t\t#ifdef USE_PCSS_SOFT_SHADOW\n\t\t\tuniform sampler2D directionalDepthMap[NUM_DIR_SHADOWS];\n\t\t#endif\n\t\tstruct DirectLightShadow {\n\t\t\tvec2 shadowBias;\n\t\t\tvec2 shadowMapSize;\n\t\t\tvec2 shadowParams;\n\t\t};\n\t\tuniform DirectLightShadow u_DirectionalShadow[NUM_DIR_SHADOWS];\n\t#endif\n\t#if NUM_POINT_SHADOWS > 0\n\t\tuniform samplerCube pointShadowMap[NUM_POINT_SHADOWS];\n\t\tvarying vec4 vPointShadowCoord[NUM_POINT_SHADOWS];\n\t\tstruct PointLightShadow {\n\t\t\tvec2 shadowBias;\n\t\t\tvec2 shadowMapSize;\n\t\t\tvec2 shadowParams;\n\t\t\tvec2 shadowCameraRange;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow u_PointShadow[NUM_POINT_SHADOWS];\n\t#endif\n\t#if NUM_SPOT_SHADOWS > 0\n\t\tuniform sampler2DShadow spotShadowMap[NUM_SPOT_SHADOWS];\n\t\tvarying vec4 vSpotShadowCoord[NUM_SPOT_SHADOWS];\n\t\t#ifdef USE_PCSS_SOFT_SHADOW\n\t\t\tuniform sampler2D spotDepthMap[NUM_SPOT_SHADOWS];\n\t\t#endif\n\t\tstruct SpotLightShadow {\n\t\t\tvec2 shadowBias;\n\t\t\tvec2 shadowMapSize;\n\t\t\tvec2 shadowParams;\n\t\t};\n\t\tuniform SpotLightShadow u_SpotShadow[NUM_SPOT_SHADOWS];\n\t#endif\n\t#include <packing>\n\t#include <shadow>\n#endif",shadowMap_pars_vert:"#ifdef USE_SHADOW\n\t#if NUM_DIR_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[NUM_DIR_SHADOWS];\n\t\tvarying vec4 vDirectionalShadowCoord[NUM_DIR_SHADOWS];\n\t\tstruct DirectLightShadow {\n\t\t\tvec2 shadowBias;\n\t\t\tvec2 shadowMapSize;\n\t\t\tvec2 shadowParams;\n\t\t};\n\t\tuniform DirectLightShadow u_DirectionalShadow[NUM_DIR_SHADOWS];\n\t#endif\n\t#if NUM_POINT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[NUM_POINT_SHADOWS];\n\t\tvarying vec4 vPointShadowCoord[NUM_POINT_SHADOWS];\n\t\tstruct PointLightShadow {\n\t\t\tvec2 shadowBias;\n\t\t\tvec2 shadowMapSize;\n\t\t\tvec2 shadowParams;\n\t\t\tvec2 shadowCameraRange;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow u_PointShadow[NUM_POINT_SHADOWS];\n\t#endif\n\t#if NUM_SPOT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[NUM_SPOT_SHADOWS];\n\t\tvarying vec4 vSpotShadowCoord[NUM_SPOT_SHADOWS];\n\t\tstruct SpotLightShadow {\n\t\t\tvec2 shadowBias;\n\t\t\tvec2 shadowMapSize;\n\t\t\tvec2 shadowParams;\n\t\t};\n\t\tuniform SpotLightShadow u_SpotShadow[NUM_SPOT_SHADOWS];\n\t#endif\n#endif",shadowMap_vert:"\n#ifdef USE_SHADOW\n\tvec3 shadowWorldNormal = (transposeMat4(inverseMat4(u_Model)) * vec4(objectNormal, 0.0)).xyz;\n\tshadowWorldNormal = normalize(shadowWorldNormal);\n\t#ifdef FLIP_SIDED\n\t\tshadowWorldNormal = -shadowWorldNormal;\n\t#endif\n\tvec4 shadowWorldPosition;\n\t#if NUM_DIR_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor (int i = 0; i < NUM_DIR_SHADOWS; i++) {\n\t\t\tshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * u_DirectionalShadow[i].shadowBias[1], 0);\n\t\t\tvDirectionalShadowCoord[i] = directionalShadowMatrix[i] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor (int i = 0; i < NUM_POINT_SHADOWS; i++) {\n\t\t\tshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * u_PointShadow[i].shadowBias[1], 0);\n\t\t\tvPointShadowCoord[i] = pointShadowMatrix[i] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor (int i = 0; i < NUM_SPOT_SHADOWS; i++) {\n\t\t\tshadowWorldPosition = worldPosition + vec4(shadowWorldNormal * u_SpotShadow[i].shadowBias[1], 0);\n\t\t\tvSpotShadowCoord[i] = spotShadowMatrix[i] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif",morphnormal_vert:"#ifdef USE_MORPHNORMALS\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vert:"#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vert:"#ifdef USE_MORPHTARGETS\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",skinning_pars_vert:"#ifdef USE_SKINNING\n\t\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n\t\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t\t#ifdef BONE_TEXTURE\n\t\t\t\tuniform sampler2D boneTexture;\n\t\t\t\tuniform int boneTextureSize;\n\t\t\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\t\t\t\tfloat j = i * 4.0;\n\t\t\t\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\t\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\t\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\t\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\t\t\t\ty = dy * ( y + 0.5 );\n\t\t\t\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\t\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\t\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\t\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\t\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\t\t\t\treturn bone;\n\t\t\t\t}\n\t\t#else\n\t\t\t\tuniform mat4 boneMatrices[MAX_BONES];\n\t\t\t\tmat4 getBoneMatrix(const in float i) {\n\t\t\t\t\t\tmat4 bone = boneMatrices[int(i)];\n\t\t\t\t\t\treturn bone;\n\t\t\t\t}\n\t\t#endif\n#endif",skinning_vert:"#ifdef USE_SKINNING\n\t\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\t\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\t\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\t\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\t\tvec4 skinVertex = bindMatrix * vec4(transformed, 1.0);\n\t\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned = bindMatrixInverse * skinned;\n\t\ttransformed = skinned.xyz / skinned.w;\n#endif",skinnormal_vert:"#ifdef USE_SKINNING\n\t\tmat4 skinMatrix = mat4( 0.0 );\n\t\tskinMatrix += skinWeight.x * boneMatX;\n\t\tskinMatrix += skinWeight.y * boneMatY;\n\t\tskinMatrix += skinWeight.z * boneMatZ;\n\t\tskinMatrix += skinWeight.w * boneMatW;\n\t\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\t\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularMap_frag:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, v_Uv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularMap_pars_frag:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",transpose:"mat4 transposeMat4(mat4 inMatrix) {\n\t\tvec4 i0 = inMatrix[0];\n\t\tvec4 i1 = inMatrix[1];\n\t\tvec4 i2 = inMatrix[2];\n\t\tvec4 i3 = inMatrix[3];\n\t\tmat4 outMatrix = mat4(\n\t\t\t\tvec4(i0.x, i1.x, i2.x, i3.x),\n\t\t\t\tvec4(i0.y, i1.y, i2.y, i3.y),\n\t\t\t\tvec4(i0.z, i1.z, i2.z, i3.z),\n\t\t\t\tvec4(i0.w, i1.w, i2.w, i3.w)\n\t\t);\n\t\treturn outMatrix;\n}",tsn:"mat3 tsn(vec3 N, vec3 V, vec2 uv) {\n\t\tvec3 q0 = dFdx(V.xyz);\n\t\tvec3 q1 = dFdy(V.xyz);\n\t\tvec2 st0 = dFdx(uv.xy);\n\t\tvec2 st1 = dFdy(uv.xy);\n\t\tfloat scale = sign(st1.y * st0.x - st0.y * st1.x);\n\t\tvec3 S = normalize((q0 * st1.y - q1 * st0.y) * scale);\n\t\tvec3 T = normalize((-q0 * st1.x + q1 * st0.x) * scale);\n\t\treturn mat3(S, T, N);\n}",uv_pars_frag:"#ifdef USE_UV1\n\t\tvarying vec2 v_Uv;\n#endif",uv_pars_vert:"#if defined(USE_UV) || defined(USE_UV1)\n\t\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_UV1\n\t\tattribute vec2 a_Uv;\n\t\tvarying vec2 v_Uv;\n#endif",uv_vert:"#ifdef USE_UV1\n\t\tv_Uv = (uvTransform * vec3(a_Uv, 1.)).xy;\n#endif",modelPos_pars_frag:"varying vec3 v_modelPos;",modelPos_pars_vert:"varying vec3 v_modelPos;",modelPos_vert:"\nv_modelPos = worldPosition.xyz;",logdepthbuf_frag:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_frag:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vert:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tuniform float logDepthCameraNear;\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t\tuniform float logDepthCameraNear;\n\t#endif\n#endif",logdepthbuf_vert:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w - logDepthCameraNear;\n\t\tvIsPerspective = float( isPerspectiveMatrix( u_Projection ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( u_Projection ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w - logDepthCameraNear + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",clearcoat_pars_frag:"#ifdef USE_CLEARCOAT\n\tuniform float u_Clearcoat;\n\tuniform float u_ClearcoatRoughness;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif"};var pi="#define USE_PBR\n#include <common_vert>\n#include <normal_pars_vert>\n#include <uv_pars_vert>\n#include <color_pars_vert>\n#include <diffuseMap_pars_vert>\n#include <modelPos_pars_vert>\n#include <envMap_pars_vert>\n#include <aoMap_pars_vert>\n#include <alphamap_pars_vert>\n#include <emissiveMap_pars_vert>\n#include <shadowMap_pars_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n\t\t#include <begin_vert>\n\t\t#include <morphtarget_vert>\n\t\t#include <morphnormal_vert>\n\t\t#include <skinning_vert>\n\t\t#include <skinnormal_vert>\n\t\t#include <pvm_vert>\n\t\t#include <normal_vert>\n\t\t#include <logdepthbuf_vert>\n\t\t#include <uv_vert>\n\t\t#include <color_vert>\n\t\t#include <diffuseMap_vert>\n\t\t#include <modelPos_vert>\n\t\t#include <envMap_vert>\n\t\t#include <aoMap_vert>\n\t\t#include <alphamap_vert>\n\t\t#include <emissiveMap_vert>\n\t\t#include <shadowMap_vert>\n}";const fi={basic_frag:"#include <common_frag>\n#include <uv_pars_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <alphamap_pars_frag>\n#include <alphaTest_pars_frag>\n#include <modelPos_pars_frag>\n#if defined(USE_ENV_MAP) && !defined(USE_VERTEX_ENVDIR)\n\t\t#include <normalMap_pars_frag>\n\t\t#include <normal_pars_frag>\t\t\n#endif\n#include <envMap_pars_frag>\n#include <aoMap_pars_frag>\n#include <fog_pars_frag>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n\t\t#include <clippingPlanes_frag>\n\t\t#include <logdepthbuf_frag>\n\t\t#include <begin_frag>\n\t\t#include <color_frag>\n\t\t#include <diffuseMap_frag>\n\t\t#include <alphamap_frag>\n\t\t#include <alphaTest_frag>\n\t\tReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n\t\treflectedLight.indirectDiffuse += vec3(1.0);\n\t\t#include <aoMap_frag>\n\t\treflectedLight.indirectDiffuse *= outColor.xyz;\n\t\toutColor.xyz = reflectedLight.indirectDiffuse;\n\t\t#if defined(USE_ENV_MAP) && !defined(USE_VERTEX_ENVDIR)\n\t\t\t\t#include <normal_frag>\n\t\t#endif\n\t\t#include <envMap_frag>\n\t\t#include <end_frag>\n\t\t#include <encodings_frag>\n\t\t#include <premultipliedAlpha_frag>\n\t\t#include <fog_frag>\n}",basic_vert:"#include <common_vert>\n#include <uv_pars_vert>\n#include <color_pars_vert>\n#include <diffuseMap_pars_vert>\n#include <modelPos_pars_vert>\n#if defined(USE_ENV_MAP) && !defined(USE_VERTEX_ENVDIR)\n\t\t#include <normal_pars_vert>\n#endif\n#include <envMap_pars_vert>\n#include <aoMap_pars_vert>\n#include <alphamap_pars_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n\t\t#include <begin_vert>\n\t\t#include <morphtarget_vert>\n\t\t#include <skinning_vert>\n\t\t#include <pvm_vert>\n\t\t#include <logdepthbuf_vert>\n\t\t#include <uv_vert>\n\t\t#include <color_vert>\n\t\t#include <diffuseMap_vert>\n\t\t#include <modelPos_vert>\n\t\t#ifdef USE_ENV_MAP\n\t\t\t\t#include <morphnormal_vert>\n\t\t\t\t#include <skinnormal_vert>\n\t\t\t\t#ifndef USE_VERTEX_ENVDIR\n\t\t\t\t\t\t#include <normal_vert>\n\t\t\t\t#endif\t\n\t\t#endif\n\t\t#include <envMap_vert>\n\t\t#include <aoMap_vert>\n\t\t#include <alphamap_vert>\n}",depth_frag:"#include <common_frag>\n#include <diffuseMap_pars_frag>\n#include <alphaTest_pars_frag>\n#include <modelPos_pars_frag>\n#include <uv_pars_frag>\n#include <packing>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n\t\t#include <clippingPlanes_frag>\n\t\t#if defined(USE_DIFFUSE_MAP) && defined(ALPHATEST)\n\t\t\t\tvec4 texelColor = texture2D( diffuseMap, v_Uv );\n\t\t\t\tfloat alpha = texelColor.a * u_Opacity;\n\t\t\t\tif(alpha < u_AlphaTest) discard;\n\t\t#endif\n\t\t#include <logdepthbuf_frag>\n\t\t\n\t\t#ifdef DEPTH_PACKING_RGBA\n\t\t\t\tgl_FragColor = packDepthToRGBA(gl_FragCoord.z);\n\t\t#else\n\t\t\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), u_Opacity );\n\t\t#endif\n}",depth_vert:"#include <common_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <uv_pars_vert>\n#include <modelPos_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n\t\t#include <uv_vert>\n\t\t#include <begin_vert>\n\t\t#include <morphtarget_vert>\n\t\t#include <skinning_vert>\n\t\t#include <pvm_vert>\n\t\t#include <logdepthbuf_vert>\n\t\t#include <modelPos_vert>\n}",distance_frag:"#include <common_frag>\nuniform float nearDistance;\nuniform float farDistance;\n#include <modelPos_pars_frag>\n#include <packing>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n\t\t#include <clippingPlanes_frag>\n\t\t\n\t\tfloat dist = length( v_modelPos - u_CameraPosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\t\tgl_FragColor = packDepthToRGBA(dist);\n}",distance_vert:"#include <common_vert>\n#include <modelPos_pars_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\nvoid main() {\n\t\t#include <begin_vert>\n\t\t#include <morphtarget_vert>\n\t\t#include <skinning_vert>\n\t\t#include <pvm_vert>\n\t\t#include <modelPos_vert>\n}",lambert_frag:"#define USE_LAMBERT\n#include <common_frag>\n#include <dithering_pars_frag>\nuniform vec3 emissive;\n#include <uv_pars_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <normalMap_pars_frag>\n#include <alphamap_pars_frag>\n#include <alphaTest_pars_frag>\n#include <bumpMap_pars_frag>\n#include <light_pars_frag>\n#include <normal_pars_frag>\n#include <modelPos_pars_frag>\n#include <bsdfs>\n#include <envMap_pars_frag>\n#include <aoMap_pars_frag>\n#include <shadowMap_pars_frag>\n#include <fog_pars_frag>\n#include <emissiveMap_pars_frag>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n\t\t#include <clippingPlanes_frag>\n\t\t#include <logdepthbuf_frag>\n\t\t#include <begin_frag>\n\t\t#include <color_frag>\n\t\t#include <diffuseMap_frag>\n\t\t#include <alphamap_frag>\n\t\t#include <alphaTest_frag>\n\t\t#include <normal_frag>\n\t\tReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n\t\t#include <light_frag>\n\t\t#include <aoMap_frag>\n\t\toutColor.xyz = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\t\t#include <envMap_frag>\n\t\t#include <shadowMap_frag>\n\t\tvec3 totalEmissiveRadiance = emissive;\n\t\t#include <emissiveMap_frag>\n\t\toutColor.xyz += totalEmissiveRadiance;\n\t\t#include <end_frag>\n\t\t#include <encodings_frag>\n\t\t#include <premultipliedAlpha_frag>\n\t\t#include <fog_frag>\n\t\t#include <dithering_frag>\n}",lambert_vert:"#define USE_LAMBERT\n#include <common_vert>\n#include <normal_pars_vert>\n#include <uv_pars_vert>\n#include <color_pars_vert>\n#include <diffuseMap_pars_vert>\n#include <modelPos_pars_vert>\n#include <envMap_pars_vert>\n#include <aoMap_pars_vert>\n#include <alphamap_pars_vert>\n#include <emissiveMap_pars_vert>\n#include <shadowMap_pars_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n\t\t#include <begin_vert>\n\t\t#include <morphtarget_vert>\n\t\t#include <morphnormal_vert>\n\t\t#include <skinning_vert>\n\t\t#include <skinnormal_vert>\n\t\t#include <pvm_vert>\n\t\t#include <normal_vert>\n\t\t#include <logdepthbuf_vert>\n\t\t#include <uv_vert>\n\t\t#include <color_vert>\n\t\t#include <diffuseMap_vert>\n\t\t#include <modelPos_vert>\n\t\t#include <envMap_vert>\n\t\t#include <aoMap_vert>\n\t\t#include <alphamap_vert>\n\t\t#include <emissiveMap_vert>\n\t\t#include <shadowMap_vert>\n}",normaldepth_frag:"#include <common_frag>\n#include <diffuseMap_pars_frag>\n#include <alphaTest_pars_frag>\n#include <uv_pars_frag>\n#include <packing>\n#include <normal_pars_frag>\n#include <logdepthbuf_pars_frag>\nvoid main() {\n\t\t#if defined(USE_DIFFUSE_MAP) && defined(ALPHATEST)\n\t\t\t\tvec4 texelColor = texture2D( diffuseMap, v_Uv );\n\t\t\t\tfloat alpha = texelColor.a * u_Opacity;\n\t\t\t\tif(alpha < u_AlphaTest) discard;\n\t\t#endif\n\t\t#include <logdepthbuf_frag>\n\t\tvec4 packedNormalDepth;\n\t\tpackedNormalDepth.xyz = normalize(v_Normal) * 0.5 + 0.5;\n\t\tpackedNormalDepth.w = gl_FragCoord.z;\n\t\tgl_FragColor = packedNormalDepth;\n}",normaldepth_vert:"#include <common_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <normal_pars_vert>\n#include <uv_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n\t\t#include <uv_vert>\n\t\t#include <begin_vert>\n\t\t#include <morphtarget_vert>\n\t\t#include <morphnormal_vert>\n\t\t#include <skinning_vert>\n\t\t#include <skinnormal_vert>\n\t\t#include <normal_vert>\n\t\t#include <pvm_vert>\n\t\t#include <logdepthbuf_vert>\n}",pbr_frag:"#define USE_PBR\n#include <common_frag>\n#include <dithering_pars_frag>\nuniform float u_Metalness;\n#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif\nuniform float u_Roughness;\n#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif\nuniform vec3 emissive;\n#include <uv_pars_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <alphamap_pars_frag>\n#include <alphaTest_pars_frag>\n#include <normalMap_pars_frag>\n#include <bumpMap_pars_frag>\n#include <envMap_pars_frag>\n#include <aoMap_pars_frag>\n#include <light_pars_frag>\n#include <normal_pars_frag>\n#include <clearcoat_pars_frag>\n#include <modelPos_pars_frag>\n#include <bsdfs>\n#include <shadowMap_pars_frag>\n#include <fog_pars_frag>\n#include <emissiveMap_pars_frag>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n\t\t#include <clippingPlanes_frag>\n\t\t#include <logdepthbuf_frag>\n\t\t#include <begin_frag>\n\t\t#include <color_frag>\n\t\t#include <diffuseMap_frag>\n\t\t#include <alphamap_frag>\n\t\t#include <alphaTest_frag>\n\t\t#include <normal_frag>\n\t\tfloat roughnessFactor = u_Roughness;\n\t\t#ifdef USE_ROUGHNESSMAP\n\t\t\tvec4 texelRoughness = texture2D( roughnessMap, v_Uv );\n\t\t\troughnessFactor *= texelRoughness.g;\n\t\t#endif\n\t\tfloat metalnessFactor = u_Metalness;\n\t\t#ifdef USE_METALNESSMAP\n\t\t\tvec4 texelMetalness = texture2D( metalnessMap, v_Uv );\n\t\t\tmetalnessFactor *= texelMetalness.b;\n\t\t#endif\n\t\tReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n\t\t#include <light_frag>\n\t\t#include <aoMap_frag>\n\t\toutColor.xyz = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t\t#include <shadowMap_frag>\n\t\tvec3 totalEmissiveRadiance = emissive;\n\t\t#include <emissiveMap_frag>\n\t\toutColor.xyz += totalEmissiveRadiance;\n\t\t#include <end_frag>\n\t\t#include <encodings_frag>\n\t\t#include <premultipliedAlpha_frag>\n\t\t#include <fog_frag>\n\t\t#include <dithering_frag>\n}",pbr_vert:pi,pbr2_frag:"#define USE_PBR\n#define USE_PBR2\n#include <common_frag>\n#include <dithering_pars_frag>\nuniform vec3 u_SpecularColor;\n#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif\nuniform float glossiness;\n#ifdef USE_GLOSSINESSMAP\n\tuniform sampler2D glossinessMap;\n#endif\nuniform vec3 emissive;\n#include <uv_pars_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <alphamap_pars_frag>\n#include <alphaTest_pars_frag>\n#include <normalMap_pars_frag>\n#include <bumpMap_pars_frag>\n#include <envMap_pars_frag>\n#include <aoMap_pars_frag>\n#include <light_pars_frag>\n#include <normal_pars_frag>\n#include <modelPos_pars_frag>\n#include <bsdfs>\n#include <shadowMap_pars_frag>\n#include <fog_pars_frag>\n#include <emissiveMap_pars_frag>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n\t\t#include <clippingPlanes_frag>\n\t\t#include <logdepthbuf_frag>\n\t\t#include <begin_frag>\n\t\t#include <color_frag>\n\t\t#include <diffuseMap_frag>\n\t\t#include <alphamap_frag>\n\t\t#include <alphaTest_frag>\n\t\t#include <normal_frag>\n\t\tvec3 specularFactor = u_SpecularColor;\n\t\t#ifdef USE_SPECULARMAP\n\t\t\t\tvec4 texelSpecular = texture2D(specularMap, v_Uv);\n\t\t\t\ttexelSpecular = sRGBToLinear(texelSpecular);\n\t\t\t\tspecularFactor *= texelSpecular.rgb;\n\t\t#endif\n\t\tfloat glossinessFactor = glossiness;\n\t\t#ifdef USE_GLOSSINESSMAP\n\t\t\t\tvec4 texelGlossiness = texture2D(glossinessMap, v_Uv);\n\t\t\t\tglossinessFactor *= texelGlossiness.a;\n\t\t#endif\n\t\tReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n\t\t#include <light_frag>\n\t\t#include <aoMap_frag>\n\t\toutColor.xyz = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t\t#include <shadowMap_frag>\n\t\tvec3 totalEmissiveRadiance = emissive;\n\t\t#include <emissiveMap_frag>\n\t\toutColor.xyz += totalEmissiveRadiance;\n\t\t#include <end_frag>\n\t\t#include <encodings_frag>\n\t\t#include <premultipliedAlpha_frag>\n\t\t#include <fog_frag>\n\t\t#include <dithering_frag>\n}",pbr2_vert:pi,phong_frag:"#define USE_PHONG\n#include <common_frag>\n#include <dithering_pars_frag>\nuniform float u_Specular;\nuniform vec3 u_SpecularColor;\n#include <specularMap_pars_frag>\nuniform vec3 emissive;\n#include <uv_pars_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <alphamap_pars_frag>\n#include <alphaTest_pars_frag>\n#include <normalMap_pars_frag>\n#include <bumpMap_pars_frag>\n#include <light_pars_frag>\n#include <normal_pars_frag>\n#include <modelPos_pars_frag>\n#include <bsdfs>\n#include <envMap_pars_frag>\n#include <aoMap_pars_frag>\n#include <shadowMap_pars_frag>\n#include <fog_pars_frag>\n#include <emissiveMap_pars_frag>\n#include <logdepthbuf_pars_frag>\n#include <clippingPlanes_pars_frag>\nvoid main() {\n\t\t#include <clippingPlanes_frag>\n\t\t#include <logdepthbuf_frag>\n\t\t#include <begin_frag>\n\t\t#include <color_frag>\n\t\t#include <diffuseMap_frag>\n\t\t#include <alphamap_frag>\n\t\t#include <alphaTest_frag>\n\t\t#include <normal_frag>\n\t\t#include <specularMap_frag>\n\t\tReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n\t\t#include <light_frag>\n\t\t#include <aoMap_frag>\n\t\toutColor.xyz = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t\t#include <envMap_frag>\n\t\t#include <shadowMap_frag>\n\t\tvec3 totalEmissiveRadiance = emissive;\n\t\t#include <emissiveMap_frag>\n\t\toutColor.xyz += totalEmissiveRadiance;\n\t\t#include <end_frag>\n\t\t#include <encodings_frag>\n\t\t#include <premultipliedAlpha_frag>\n\t\t#include <fog_frag>\n\t\t#include <dithering_frag>\n}",phong_vert:"#define USE_PHONG\n#include <common_vert>\n#include <normal_pars_vert>\n#include <uv_pars_vert>\n#include <color_pars_vert>\n#include <diffuseMap_pars_vert>\n#include <modelPos_pars_vert>\n#include <envMap_pars_vert>\n#include <aoMap_pars_vert>\n#include <alphamap_pars_vert>\n#include <emissiveMap_pars_vert>\n#include <shadowMap_pars_vert>\n#include <morphtarget_pars_vert>\n#include <skinning_pars_vert>\n#include <logdepthbuf_pars_vert>\nvoid main() {\n\t\t#include <begin_vert>\n\t\t#include <morphtarget_vert>\n\t\t#include <morphnormal_vert>\n\t\t#include <skinning_vert>\n\t\t#include <skinnormal_vert>\n\t\t#include <pvm_vert>\n\t\t#include <normal_vert>\n\t\t#include <logdepthbuf_vert>\n\t\t#include <uv_vert>\n\t\t#include <color_vert>\n\t\t#include <diffuseMap_vert>\n\t\t#include <modelPos_vert>\n\t\t#include <envMap_vert>\n\t\t#include <aoMap_vert>\n\t\t#include <alphamap_vert>\n\t\t#include <emissiveMap_vert>\n\t\t#include <shadowMap_vert>\n}",point_frag:"#include <common_frag>\n#include <color_pars_frag>\n#include <diffuseMap_pars_frag>\n#include <fog_pars_frag>\n#include <logdepthbuf_pars_frag>\nvoid main() {\n\t\t#include <begin_frag>\n\t\t#include <color_frag>\n\t\t#include <logdepthbuf_frag>\n\t\t#ifdef USE_DIFFUSE_MAP\n\t\t\t\toutColor *= texture2D(diffuseMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));\n\t\t#endif\n\t\t#include <end_frag>\n\t\t#include <encodings_frag>\n\t\t#include <premultipliedAlpha_frag>\n\t\t#include <fog_frag>\n}",point_vert:"#include <common_vert>\n#include <color_pars_vert>\n#include <logdepthbuf_pars_vert>\nuniform float u_PointSize;\nuniform float u_PointScale;\nvoid main() {\n\t\t#include <begin_vert>\n\t\t#include <pvm_vert>\n\t\t#include <color_vert>\n\t\tvec4 mvPosition = u_View * u_Model * vec4(transformed, 1.0);\n\t\t#ifdef USE_SIZEATTENUATION\n\t\t\t\tgl_PointSize = u_PointSize * ( u_PointScale / - mvPosition.z );\n\t\t#else\n\t\t\t\tgl_PointSize = u_PointSize;\n\t\t#endif\n\t\t#include <logdepthbuf_vert>\n}"};class _i{constructor(t,e,n){this.gl=t,this.name=n.name,this.type=n.type,this.size=n.size,this.location=t.getAttribLocation(e,this.name),this.count=function(t,e){switch(e){case t.FLOAT:case t.INT:case t.UNSIGNED_INT:return 1;case t.FLOAT_VEC2:case t.INT_VEC2:return 2;case t.FLOAT_VEC3:case t.INT_VEC3:return 3;case t.FLOAT_VEC4:case t.INT_VEC4:case t.FLOAT_MAT2:return 4;case t.FLOAT_MAT3:return 9;case t.FLOAT_MAT4:return 16;default:return 0}}(t,this.type),this.format=function(t,e){switch(e){case t.FLOAT:case t.FLOAT_VEC2:case t.FLOAT_VEC3:case t.FLOAT_VEC4:case t.FLOAT_MAT2:case t.FLOAT_MAT3:case t.FLOAT_MAT4:return t.FLOAT;case t.INT:case t.INT_VEC2:case t.INT_VEC3:case t.INT_VEC4:return t.INT;case t.UNSIGNED_INT:return t.UNSIGNED_INT;default:return t.FLOAT}}(t,this.type),this.locationSize=1,this.type===t.FLOAT_MAT2&&(this.locationSize=2),this.type===t.FLOAT_MAT3&&(this.locationSize=3),this.type===t.FLOAT_MAT4&&(this.locationSize=4)}}class mi{constructor(t){this._gl=t,this._extensions={},this.version=parseFloat(/^WebGL (\d)/.exec(t.getParameter(t.VERSION))[1]);const e=this.getExtension("EXT_texture_filter_anisotropic");this.anisotropyExt=e,this.maxAnisotropy=null!==e?t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT):1;let n=null,i=!1;try{this.version>1?(n=this.getExtension("EXT_disjoint_timer_query_webgl2"),n&&(i=!!t.getQuery(n.TIMESTAMP_EXT,n.QUERY_COUNTER_BITS_EXT))):(n=this.getExtension("EXT_disjoint_timer_query"),n&&(i=!!n.getQueryEXT(n.TIMESTAMP_EXT,n.QUERY_COUNTER_BITS_EXT)))}catch(t){console.warn(t)}this.timerQuery=n,this.canUseTimestamp=i,this.parallelShaderCompileExt=this.getExtension("KHR_parallel_shader_compile"),this.maxPrecision=function(t,e){if("highp"===e){if(t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.HIGH_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision>0)return"highp";e="mediump"}if("mediump"===e&&t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.MEDIUM_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.MEDIUM_FLOAT).precision>0)return"mediump";return"lowp"}(t,"highp"),this.maxTextures=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),this.maxVertexTextures=t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),this.maxTextureSize=t.getParameter(t.MAX_TEXTURE_SIZE),this.maxCubemapSize=t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),this.maxVertexUniformVectors=t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),this.maxSamples=this.version>1?t.getParameter(t.MAX_SAMPLES):1,this.lineWidthRange=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE)}getExtension(t){const e=this._gl,n=this._extensions;if(void 0!==n[t])return n[t];let i=null;for(const n of gi)if(i=e.getExtension(n+t),i)break;return n[t]=i,i}}const gi=["","WEBKIT_","MOZ_"];class vi extends wn{constructor(t,e,n,i){super(t),this._gl=e,this._buffers=n,this._vertexArrayBindings=i;const r=this;this._onGeometryDispose=function t(e){const s=e.target,a=r.get(s);s.removeEventListener("dispose",t),null!==s.index&&n.removeBuffer(s.index.buffer);for(const t in s.attributes)n.removeBuffer(s.attributes[t].buffer);for(const t in s.morphAttributes){const e=s.morphAttributes[t];for(let t=0,i=e.length;t<i;t++)n.removeBuffer(e[t].buffer)}i.releaseByGeometry(s),a.created=!1,r.delete(s)}}setGeometry(t,e){const n=this._gl,i=this._buffers,r=this.get(t);if(r.pass!==e.count){r.pass=e.count,r.created||(t.addEventListener("dispose",this._onGeometryDispose),r.created=!0),null!==t.index&&i.setBuffer(t.index.buffer,n.ELEMENT_ARRAY_BUFFER,this._vertexArrayBindings);for(const e in t.attributes)i.setBuffer(t.attributes[e].buffer,n.ARRAY_BUFFER);for(const e in t.morphAttributes){const r=t.morphAttributes[e];for(let t=0,e=r.length;t<e;t++)i.setBuffer(r[t].buffer,n.ARRAY_BUFFER)}return r}}}const Ti={u_Model:[1,null],u_Projection:[2,function(t){this.set(t.projectionMatrix.elements)}],u_View:[2,function(t){this.set(t.viewMatrix.elements)}],u_ProjectionView:[2,function(t){this.set(t.projectionViewMatrix.elements)}],u_CameraPosition:[2,function(t){this.setValue(t.position.x,t.position.y,t.position.z)}],logDepthBufFC:[2,function(t){this.set(t.logDepthBufFC)}],logDepthCameraNear:[2,function(t){this.set(t.logDepthCameraNear)}],u_FogColor:[3,function(t){const e=t.fog.color;this.setValue(e.r,e.g,e.b)}],u_FogDensity:[3,function(t){this.set(t.fog.density)}],u_FogNear:[3,function(t){this.set(t.fog.near)}],u_FogFar:[3,function(t){this.set(t.fog.far)}],u_Color:[4,function(t,e){const n=t.diffuse;this.setValue(n.r,n.g,n.b)}],u_Opacity:[4,function(t,e){this.set(t.opacity)}],u_AlphaTest:[4,function(t,e){this.set(t.alphaTest)}],diffuseMap:[4,function(t,e){this.set(t.diffuseMap,e)}],alphaMap:[4,function(t,e){this.set(t.alphaMap,e)}],alphaMapUVTransform:[4,function(t,e){const n=t.alphaMapTransform;n.isTransformUV&&n.update(),this.set(n.elements)}],normalMap:[4,function(t,e){this.set(t.normalMap,e)}],normalScale:[4,function(t,e){this.setValue(t.normalScale.x,t.normalScale.y)}],bumpMap:[4,function(t,e){this.set(t.bumpMap,e)}],bumpScale:[4,function(t,e){this.set(t.bumpScale)}],cubeMap:[4,function(t,e){this.set(t.cubeMap,e)}],u_Specular:[4,function(t,e){this.set(t.shininess)}],u_SpecularColor:[4,function(t,e){const n=t.specular;this.setValue(n.r,n.g,n.b)}],specularMap:[4,function(t,e){this.set(t.specularMap,e)}],aoMap:[4,function(t,e){this.set(t.aoMap,e)}],aoMapIntensity:[4,function(t,e){this.set(t.aoMapIntensity)}],aoMapUVTransform:[4,function(t,e){const n=t.aoMapTransform;n.isTransformUV&&n.update(),this.set(n.elements)}],u_Roughness:[4,function(t,e){this.set(t.roughness)}],roughnessMap:[4,function(t,e){this.set(t.roughnessMap,e)}],u_Metalness:[4,function(t,e){this.set(t.metalness)}],metalnessMap:[4,function(t,e){this.set(t.metalnessMap,e)}],u_Clearcoat:[4,function(t,e){this.set(t.clearcoat)}],u_ClearcoatRoughness:[4,function(t,e){this.set(t.clearcoatRoughness)}],clearcoatMap:[4,function(t,e){this.set(t.clearcoatMap,e)}],clearcoatRoughnessMap:[4,function(t,e){this.set(t.clearcoatRoughnessMap,e)}],clearcoatNormalMap:[4,function(t,e){this.set(t.clearcoatNormalMap,e)}],clearcoatNormalScale:[4,function(t,e){this.setValue(t.clearcoatNormalScale.x,t.clearcoatNormalScale.y)}],glossiness:[4,function(t,e){this.set(t.glossiness)}],glossinessMap:[4,function(t,e){this.set(t.glossinessMap,e)}],emissive:[4,function(t,e){const n=t.emissive;this.setValue(n.r,n.g,n.b)}],emissiveMap:[4,function(t,e){this.set(t.emissiveMap,e)}],emissiveMapUVTransform:[4,function(t,e){const n=t.emissiveMapTransform;n.isTransformUV&&n.update(),this.set(n.elements)}],uvTransform:[4,function(t,e){const n=t.diffuseMapTransform;n.isTransformUV&&n.update(),this.set(n.elements)}],u_PointSize:[4,function(t,e){this.set(t.size)}],envMap:[5,function(t,e){this.set(t.map,e)}],envMapParams:[5,function(t,e){this.setValue(t.diffuse,t.specular,t.map.images[0]&&t.map.images[0].rtt?1:-1)}],maxMipLevel:[5,function(t,e){this.set(e.get(t.map).__maxMipLevel||8)}]},Si=new On;Si.image={data:new Uint8Array([1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1]),width:2,height:2},Si.magFilter=I.NEAREST,Si.minFilter=I.NEAREST,Si.generateMipmaps=!1,Si.version++;const Ei=new On;Ei.image={data:null,width:2,height:2},Ei.version++,Ei.type=F.FLOAT_32_UNSIGNED_INT_24_8_REV,Ei.format=D.DEPTH_STENCIL,Ei.magFilter=I.NEAREST,Ei.minFilter=I.NEAREST,Ei.compare=U.LESS,Ei.generateMipmaps=!1,Ei.version++;const xi=new Gn,Mi=new Bn,Ai=new kn;function yi(t,e){if(t.length!==e.length)return!1;for(let n=0,i=t.length;n<i;n++)if(t[n]!==e[n])return!1;return!0}function wi(t,e){for(let n=0,i=e.length;n<i;n++)t[n]=e[n]}const Ri=[];function Li(t,e){let n=Ri[e];void 0===n&&(n=new Int32Array(e),Ri[e]=n);for(let i=0;i!==e;++i)n[i]=t.allocTexUnit();return n}function Ci(t,e){const n=t.gl,i=t.type,r=t.location,s=t.cache;switch(i){case n.FLOAT:t.setValue=function(t){s[0]!==t&&(n.uniform1f(r,t),s[0]=t)},t.set=e?function(t){yi(s,t)||(n.uniform1fv(r,t),wi(s,t))}:t.setValue;break;case n.SAMPLER_2D:case n.SAMPLER_2D_SHADOW:case n.INT_SAMPLER_2D:case n.UNSIGNED_INT_SAMPLER_2D:t.setValue=function(t,e){const a=e.allocTexUnit();e.setTexture2D(t||(i===n.SAMPLER_2D_SHADOW?Ei:Si),a),s[0]!==a&&(n.uniform1i(r,a),s[0]=a)},t.set=e?function(t,e){const a=t.length,o=Li(e,a);for(let r=0;r!==a;++r)e.setTexture2D(t[r]||(i===n.SAMPLER_2D_SHADOW?Ei:Si),o[r]);yi(s,o)||(n.uniform1iv(r,o),wi(s,o))}:t.setValue;break;case n.SAMPLER_2D_ARRAY:case n.SAMPLER_2D_ARRAY_SHADOW:case n.INT_SAMPLER_2D_ARRAY:case n.UNSIGNED_INT_SAMPLER_2D_ARRAY:t.setValue=function(t,e){const i=e.allocTexUnit();e.setTexture2DArray(t||Mi,i),s[0]!==i&&(n.uniform1i(r,i),s[0]=i)},t.set=e?function(t,e){const i=t.length,a=Li(e,i);for(let n=0;n!==i;++n)e.setTexture2DArray(t[n]||Mi,a[n]);yi(s,a)||(n.uniform1iv(r,a),wi(s,a))}:t.setValue;break;case n.SAMPLER_CUBE:case n.SAMPLER_CUBE_SHADOW:t.setValue=function(t,e){const i=e.allocTexUnit();e.setTextureCube(t||Ai,i),s[0]!==i&&(n.uniform1i(r,i),s[0]=i)},t.set=e?function(t,e){const i=t.length,a=Li(e,i);for(let n=0;n!==i;++n)e.setTextureCube(t[n]||Ai,a[n]);yi(s,a)||(n.uniform1iv(r,a),wi(s,a))}:t.setValue;break;case n.SAMPLER_3D:t.setValue=function(t,e){const i=e.allocTexUnit();e.setTexture3D(t||xi,i),s[0]!==i&&(n.uniform1i(r,i),s[0]=i)},t.set=e?function(t,e){const i=t.length,a=Li(e,i);for(let n=0;n!==i;++n)e.setTexture3D(t[n]||xi,a[n]);yi(s,a)||(n.uniform1iv(r,a),wi(s,a))}:t.setValue;break;case n.BOOL:case n.INT:t.setValue=function(t){s[0]!==t&&(n.uniform1i(r,t),s[0]=t)},t.set=e?function(t){yi(s,t)||(n.uniform1iv(r,t),wi(s,t))}:t.setValue;break;case n.FLOAT_VEC2:t.setValue=function(t,e){s[0]===t&&s[1]===e||(n.uniform2f(r,t,e),s[0]=t,s[1]=e)},t.set=function(t){yi(s,t)||(n.uniform2fv(r,t),wi(s,t))};break;case n.BOOL_VEC2:case n.INT_VEC2:t.setValue=function(t,e){s[0]===t&&s[1]===e||(n.uniform2i(r,t,e),s[0]=t,s[1]=e)},t.set=function(t){yi(s,t)||(n.uniform2iv(r,t),wi(s,t))};break;case n.FLOAT_VEC3:t.setValue=function(t,e,i){s[0]===t&&s[1]===e&&s[2]===i||(n.uniform3f(r,t,e,i),s[0]=t,s[1]=e,s[2]=i)},t.set=function(t){yi(s,t)||(n.uniform3fv(r,t),wi(s,t))};break;case n.BOOL_VEC3:case n.INT_VEC3:t.setValue=function(t,e,i){s[0]===t&&s[1]===e&&s[2]===i||(n.uniform3i(r,t,e,i),s[0]=t,s[1]=e,s[2]=i)},t.set=function(t){yi(s,t)||(n.uniform3iv(r,t),wi(s,t))};break;case n.FLOAT_VEC4:t.setValue=function(t,e,i,a){s[0]===t&&s[1]===e&&s[2]===i&&s[3]===a||(n.uniform4f(r,t,e,i,a),s[0]=t,s[1]=e,s[2]=i,s[3]=a)},t.set=function(t){yi(s,t)||(n.uniform4fv(r,t),wi(s,t))};break;case n.BOOL_VEC4:case n.INT_VEC4:t.setValue=function(t,e,i,a){s[0]===t&&s[1]===e&&s[2]===i&&s[3]===a||(n.uniform4i(r,t,e,i,a),s[0]=t,s[1]=e,s[2]=i,s[3]=a)},t.set=function(t){yi(s,t)||(n.uniform4iv(r,t),wi(s,t))};break;case n.FLOAT_MAT2:t.setValue=t.set=e?function(t){yi(s,t)||(n.uniformMatrix2fv(r,!1,t),wi(s,t))}:function(t){s[0]===t[0]&&s[1]===t[1]&&s[2]===t[2]&&s[3]===t[3]||(n.uniformMatrix2fv(r,!1,t),s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[3])};break;case n.FLOAT_MAT3:t.setValue=t.set=e?function(t){yi(s,t)||(n.uniformMatrix3fv(r,!1,t),wi(s,t))}:function(t){s[0]===t[0]&&s[1]===t[1]&&s[2]===t[2]&&s[3]===t[3]&&s[4]===t[4]&&s[5]===t[5]&&s[6]===t[6]&&s[7]===t[7]&&s[8]===t[8]||(n.uniformMatrix3fv(r,!1,t),s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[3],s[4]=t[4],s[5]=t[5],s[6]=t[6],s[7]=t[7],s[8]=t[8])};break;case n.FLOAT_MAT4:t.setValue=t.set=e?function(t){yi(s,t)||(n.uniformMatrix4fv(r,!1,t),wi(s,t))}:function(t){s[0]===t[0]&&s[1]===t[1]&&s[2]===t[2]&&s[3]===t[3]&&s[4]===t[4]&&s[5]===t[5]&&s[6]===t[6]&&s[7]===t[7]&&s[8]===t[8]&&s[9]===t[9]&&s[10]===t[10]&&s[11]===t[11]&&s[12]===t[12]&&s[13]===t[13]&&s[14]===t[14]&&s[15]===t[15]||(n.uniformMatrix4fv(r,!1,t),s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[3],s[4]=t[4],s[5]=t[5],s[6]=t[6],s[7]=t[7],s[8]=t[8],s[9]=t[9],s[10]=t[10],s[11]=t[11],s[12]=t[12],s[13]=t[13],s[14]=t[14],s[15]=t[15])}}}class bi{constructor(t,e,n,i){this.gl=t,this.id=e,this.type=n.type,this.location=i,this.setValue=void 0,this.set=void 0,this.cache=[],Ci(this),this.internalGroup=0,this.internalFun=null;const r=Ti[e];r&&(this.internalGroup=r[0],this.internalFun=r[1])}}class Pi{constructor(t,e,n,i){this.gl=t,this.id=e,this.type=n.type,this.size=n.size,this.location=i,this.setValue=void 0,this.set=void 0,this.cache=[],Ci(this,!0)}}class Ni{constructor(){this.seq=[],this.map={}}}class Di extends Ni{constructor(t){super(),this.id=t}set(t,e){const n=this.seq;for(let i=0,r=n.length;i!==r;++i){const r=n[i];r.set(t[r.id],e)}}}const Fi=/(\w+)(\])?(\[|\.)?/g;function Ii(t,e){t.seq.push(e),t.map[e.id]=e}function Oi(t,e,n,i){const r=e.name,s=r.length;for(Fi.lastIndex=0;;){const a=Fi.exec(r),o=Fi.lastIndex;let l=a[1];const h="]"===a[2],c=a[3];if(h&&(l|=0),void 0===c||"["===c&&o+2===s){Ii(i,void 0===c?new bi(t,l,e,n):new Pi(t,l,e,n));break}{let t=i.map[l];void 0===t&&(t=new Di(l),Ii(i,t)),i=t}}}class Ui extends Ni{constructor(t,e){super();const n=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const n=t.getActiveUniform(e,i),r=t.getUniformLocation(e,n.name);Oi(t,n,r,this)}}set(t,e,n){const i=this.map[t];void 0!==i&&i.set(e,n)}has(t){return!!this.map[t]}}let Bi=0;class zi{constructor(t,e,n){let i,r,s,a,o;this.gl=t,this.vshaderSource=e,this.fshaderSource=n,this.id=Bi++,this.usedTimes=1,this.code="",this.name="",this.lightId=-1,this.lightVersion=-1,this.cameraId=-1,this.cameraVersion=-1,this.sceneId=-1,this.sceneVersion=-1,this.program,this._checkErrors=!0,this._compileAsynchronously=!1,this._status=0,this.compile=function(a){r=Gi(t,t.VERTEX_SHADER,e),s=Gi(t,t.FRAGMENT_SHADER,n),i=t.createProgram(),t.attachShader(i,r),t.attachShader(i,s),t.linkProgram(i),this.program=i,this._checkErrors=a.checkErrors,this._compileAsynchronously=a.compileAsynchronously,this._status=1,t.deleteShader(r),t.deleteShader(s)},this.isReady=function(e){return 1===this._status&&(this._compileAsynchronously&&e?t.getProgramParameter(i,e.COMPLETION_STATUS_KHR)&&(this._status=2,this._tryCheckErrors()):(this._status=2,this._tryCheckErrors())),2===this._status},this._tryCheckErrors=function(){if(this._checkErrors&&!1===t.getProgramParameter(i,t.LINK_STATUS)){const e=t.getProgramInfoLog(i).trim(),n=Hi(t,r,"VERTEX"),a=Hi(t,s,"FRAGMENT");this.program=void 0,this._status=0,console.error("Shader Error "+t.getError()+" - VALIDATE_STATUS "+t.getProgramParameter(i,t.VALIDATE_STATUS)+"\n\nShader Name: "+this.name+"\nProgram Info Log: "+e+"\n"+n+"\n"+a)}},this.getUniforms=function(){return void 0===a&&(a=new Ui(t,i)),a},this.getAttributes=function(){return void 0===o&&(o=function(t,e){const n={},i=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let r=0;r<i;r++){const i=t.getActiveAttrib(e,r);n[i.name]=new _i(t,e,i)}return n}(t,i)),o},this.dispose=function(){t.deleteProgram(i),this.program=void 0,this._status=0}}}function Gi(t,e,n){const i=t.createShader(e);return t.shaderSource(i,n),t.compileShader(i),i}function Hi(t,e,n){const i=t.getShaderParameter(e,t.COMPILE_STATUS),r=t.getShaderInfoLog(e).trim();if(i&&""===r)return"";const s=/ERROR: 0:(\d+)/.exec(r);if(s){const i=parseInt(s[1]);return n+"\n\n"+r+"\n\n"+function(t,e){const n=t.split("\n"),i=[],r=Math.max(e-6,0),s=Math.min(e+6,n.length);for(let t=r;t<s;t++){const r=t+1;i.push(`${r===e?">":" "} ${r}: ${n[t]}`)}return i.join("\n")}(t.getShaderSource(e),i)}return r}class Vi{constructor(t,e,n){this._gl=t,this._state=e,this._capabilities=n,this._programs=[]}getProgram(t,e,n,i){const r=this._programs;let s;for(let t=0,e=r.length;t<e;t++){const e=r[t];if(e.code===n){s=e,++s.usedTimes;break}}if(void 0===s){const a=function(t){const e=[];for(const n in t){const i=t[n];!1!==i&&e.push("#define "+n+" "+i)}return e.join("\n")}(t.defines),o=fi[t.type+"_vert"]||t.vertexShader||fi.basic_vert,l=fi[t.type+"_frag"]||t.fragmentShader||fi.basic_frag;s=function(t,e,n,i,r){let s=["precision "+n.precision+" float;","precision "+n.precision+" int;","precision "+n.precision+" sampler2D;",n.version>=2?"precision "+n.precision+" isampler2D;":"",n.version>=2?"precision "+n.precision+" usampler2D;":"","#define SHADER_NAME "+n.shaderName,e,n.version>=2?"#define WEBGL2":"",n.useDiffuseMap?"#define USE_DIFFUSE_MAP":"",n.useAlphaMap?"#define USE_ALPHA_MAP":"",n.useEmissiveMap?"#define USE_EMISSIVEMAP":"",n.useAOMap?"#define USE_AOMAP":"",n.useNormalMap?"#define USE_NORMAL_MAP":"",n.useBumpMap?"#define USE_BUMPMAP":"",n.useSpecularMap?"#define USE_SPECULARMAP":"",n.useRoughnessMap?"#define USE_ROUGHNESSMAP":"",n.useMetalnessMap?"#define USE_METALNESSMAP":"",n.useGlossinessMap?"#define USE_GLOSSINESSMAP":"",n.useEnvMap?"#define USE_ENV_MAP":"",n.diffuseMapUv?"#define DIFFUSEMAP_UV "+n.diffuseMapUv:"",n.alphaMapUv?"#define ALPHAMAP_UV "+n.alphaMapUv:"",n.emissiveMapUv?"#define EMISSIVEMAP_UV "+n.emissiveMapUv:"",n.aoMapUv?"#define AOMAP_UV "+n.aoMapUv:"",n.activeMapCoords>0?"#define USE_UV":"",1&n.activeMapCoords?"#define USE_UV1":"",Qi(n.activeMapCoords),n.useAmbientLight?"#define USE_AMBIENT_LIGHT":"",n.useSphericalHarmonicsLight?"#define USE_SPHERICALHARMONICS_LIGHT":"",n.useShadow?"#define USE_SHADOW":"",n.useVertexColors==k.RGB?"#define USE_VCOLOR_RGB":"",n.useVertexColors==k.RGBA?"#define USE_VCOLOR_RGBA":"",n.useVertexTangents?"#define USE_TANGENT":"",n.flatShading?"#define FLAT_SHADED":"",n.fog?"#define USE_FOG":"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.flipSided?"#define FLIP_SIDED":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.useSkinning?"#define USE_SKINNING":"",n.bonesNum>0?"#define MAX_BONES "+n.bonesNum:"",n.useVertexTexture?"#define BONE_TEXTURE":"","\n"].filter(Ki).join("\n"),a=[n.useStandardDerivatives&&n.version<2?"#extension GL_OES_standard_derivatives : enable":"",n.useShaderTextureLOD&&n.version<2?"#extension GL_EXT_shader_texture_lod : enable":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth&&n.version<2?"#extension GL_EXT_frag_depth : enable":"","precision "+n.precision+" float;","precision "+n.precision+" int;","precision "+n.precision+" sampler2D;",n.version>=2?"precision "+n.precision+" isampler2D;":"",n.version>=2?"precision "+n.precision+" usampler2D;":"",n.version>=2?"precision "+n.precision+" sampler2DShadow;":"",n.version>=2?"precision "+n.precision+" samplerCubeShadow;":"","#define SHADER_NAME "+n.shaderName,"#define PI 3.14159265359","#define EPSILON 1e-6","float pow2(const in float x) { return x * x; }","#define LOG2 1.442695","#define RECIPROCAL_PI 0.31830988618","#define saturate(a) clamp(a, 0.0, 1.0)","#define whiteCompliment(a) (1.0 - saturate(a))","highp float rand(const in vec2 uv) {","\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;","\thighp float dt = dot(uv.xy, vec2(a, b)), sn = mod(dt, PI);","\treturn fract(sin(sn) * c);","}",e,n.version>=2?"#define WEBGL2":"",n.useShadowSampler?"#define USE_SHADOW_SAMPLER":"#define sampler2DShadow sampler2D",n.useShaderTextureLOD?"#define TEXTURE_LOD_EXT":"",n.useDiffuseMap?"#define USE_DIFFUSE_MAP":"",n.useAlphaMap?"#define USE_ALPHA_MAP":"",n.useEmissiveMap?"#define USE_EMISSIVEMAP":"",n.useAOMap?"#define USE_AOMAP":"",n.useNormalMap?"#define USE_NORMAL_MAP":"",n.useBumpMap?"#define USE_BUMPMAP":"",n.useSpecularMap?"#define USE_SPECULARMAP":"",n.useRoughnessMap?"#define USE_ROUGHNESSMAP":"",n.useMetalnessMap?"#define USE_METALNESSMAP":"",n.useGlossinessMap?"#define USE_GLOSSINESSMAP":"",n.useEnvMap?"#define USE_ENV_MAP":"",n.envMapCombine?"#define "+n.envMapCombine:"",n.useClearcoat?"#define USE_CLEARCOAT":"",n.useClearcoatMap?"#define USE_CLEARCOATMAP":"",n.useClearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.useClearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",1&n.activeMapCoords?"#define USE_UV1":"",n.useAmbientLight?"#define USE_AMBIENT_LIGHT":"",n.useSphericalHarmonicsLight?"#define USE_SPHERICALHARMONICS_LIGHT":"",n.useClusteredLights?"#define USE_CLUSTERED_LIGHTS":"",n.useShadow?"#define USE_SHADOW":"",n.shadowType===z.HARD?"#define USE_HARD_SHADOW":"",n.shadowType===z.POISSON_SOFT?"#define USE_POISSON_SOFT_SHADOW":"",n.shadowType===z.PCF3_SOFT?"#define USE_PCF3_SOFT_SHADOW":"",n.shadowType===z.PCF5_SOFT?"#define USE_PCF5_SOFT_SHADOW":"",n.shadowType===z.PCSS16_SOFT?"#define USE_PCSS16_SOFT_SHADOW":"",n.shadowType===z.PCSS32_SOFT?"#define USE_PCSS32_SOFT_SHADOW":"",n.shadowType===z.PCSS64_SOFT?"#define USE_PCSS64_SOFT_SHADOW":"",n.shadowType===z.PCSS16_SOFT||n.shadowType===z.PCSS32_SOFT||n.shadowType===z.PCSS64_SOFT?"#define USE_PCSS_SOFT_SHADOW":"",n.dithering?"#define DITHERING":"",di.encodings_pars_frag,"#define GAMMA_FACTOR "+n.gammaFactor,Yi("linearToOutputTexel",n.outputEncoding),ji("mapTexelToLinear",n.diffuseMapEncoding),n.useEnvMap?ji("envMapTexelToLinear",n.envMapEncoding):"",n.useEmissiveMap?ji("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.alphaTest?"#define ALPHATEST":"",n.premultipliedAlpha?"#define USE_PREMULTIPLIED_ALPHA":"",n.useVertexColors==k.RGB?"#define USE_VCOLOR_RGB":"",n.useVertexColors==k.RGBA?"#define USE_VCOLOR_RGBA":"",n.useVertexTangents?"#define USE_TANGENT":"",n.flatShading?"#define FLAT_SHADED":"",n.fog?"#define USE_FOG":"",n.fogExp2?"#define USE_EXP2_FOG":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.packDepthToRGBA?"#define DEPTH_PACKING_RGBA":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","\n"].filter(Ki).join("\n"),o=i,l=r;if(o=Zi(o),l=Zi(l),o=$i(o,n),l=$i(l,n),o=Ji(o,n),l=Ji(l,n),o=nr(o),l=nr(l),n.version>1){const t=o.match(ir);t&&(o=o.replace(ir,"")),s=["#version 300 es",t?t.join("\n"):"","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+s,l=l.replace("#extension GL_EXT_draw_buffers : require","");let e=0;const n=[];for(;l.indexOf("gl_FragData["+e+"]")>-1;)l=l.replace("gl_FragData["+e+"]","pc_fragData"+e),n.push("layout(location = "+e+") out highp vec4 pc_fragData"+e+";"),e++;a=["#version 300 es","#define varying in",l.indexOf("layout")>-1||n.length>0?"":"out highp vec4 pc_fragColor;","#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad",n.join("\n")].join("\n")+"\n"+a}return o=s+o,l=a+l,new zi(t,o,l)}(this._gl,a,e,o,l),s.name=e.shaderName,s.compile(i),s.code=n,r.push(s)}return s}releaseProgram(t){if(0==--t.usedTimes){const e=this._programs,n=e.indexOf(t);e[n]=e[e.length-1],e.pop(),t.dispose(this._gl)}}generateProps(t,e,n,i){const r=this._state,s=this._capabilities,a=t.fog?i.scene.fog:null,o=void 0!==t.envMap?t.envMap||i.scene.environment:null,l=i.scene.logarithmicDepthBuffer,h=i.scene.disableShadowSampler,c=t.clippingPlanes&&t.clippingPlanes.length>0?t.clippingPlanes.length:i.scene.numClippingPlanes,u=t.clearcoat>0,d=!!t.diffuseMap,p=!!t.alphaMap,f=!!t.emissiveMap,_=!!t.aoMap,m=!!t.normalMap,g=!!t.bumpMap,v=!!t.specularMap,T=!!t.roughnessMap,S=!!t.metalnessMap,E=!!t.glossinessMap,x=!!o,M=u&&!!t.clearcoatMap,A=u&&!!t.clearcoatRoughnessMap,y=u&&!!t.clearcoatNormalMap;ki=t.extUvCoordMask;const R={};R.shaderName=t.type===w.SHADER&&t.shaderName?t.shaderName:t.type,R.version=s.version,R.precision=t.precision||s.maxPrecision,R.useStandardDerivatives=s.version>=2||!!s.getExtension("OES_standard_derivatives")||!!s.getExtension("GL_OES_standard_derivatives"),R.useShaderTextureLOD=s.version>=2||!!s.getExtension("EXT_shader_texture_lod"),R.useDiffuseMap=d,R.useAlphaMap=p,R.useEmissiveMap=f,R.useAOMap=_,R.useNormalMap=m,R.useBumpMap=g,R.useSpecularMap=v,R.useRoughnessMap=T,R.useMetalnessMap=S,R.useGlossinessMap=E,R.useEnvMap=x,R.envMapCombine=x&&t.envMapCombine,R.useClearcoat=u,R.useClearcoatMap=M,R.useClearcoatRoughnessMap=A,R.useClearcoatNormalMap=y,R.diffuseMapUv=d&&Wi(t.diffuseMapCoord),R.alphaMapUv=p&&Wi(t.alphaMapCoord),R.emissiveMapUv=f&&Wi(t.emissiveMapCoord),R.aoMapUv=_&&Wi(t.aoMapCoord),(m||g||v||T||S||E||M||A||y)&&(ki|=1),R.activeMapCoords=ki,n.setProgramProps(R,e.receiveShadow),R.useShadowSampler=s.version>=2&&!h,R.shadowType=e.shadowType,R.useShadowSampler||R.shadowType===z.HARD||(R.shadowType=z.POISSON_SOFT),R.dithering=t.dithering;const L=r.currentRenderTarget;R.gammaFactor=i.gammaFactor,R.outputEncoding=L.texture?Xi(L.texture):i.outputEncoding,R.diffuseMapEncoding=Xi(t.diffuseMap||t.cubeMap),R.envMapEncoding=Xi(o),R.emissiveMapEncoding=Xi(t.emissiveMap),R.alphaTest=t.alphaTest>0,R.premultipliedAlpha=t.premultipliedAlpha,R.useVertexColors=t.vertexColors,R.useVertexTangents=!!t.normalMap&&t.vertexTangents,R.numClippingPlanes=c,R.flatShading=t.shading===N.FLAT_SHADING,R.fog=!!a,R.fogExp2=!!a&&a.isFogExp2,R.sizeAttenuation=t.sizeAttenuation,R.doubleSided=t.side===P.DOUBLE,R.flipSided=t.side===P.BACK,R.packDepthToRGBA=t.packToRGBA,R.logarithmicDepthBuffer=!!l,R.rendererExtensionFragDepth=s.version>=2||!!s.getExtension("EXT_frag_depth"),R.morphTargets=!!e.morphTargetInfluences,R.morphNormals=!!e.morphTargetInfluences&&e.geometry.morphAttributes.normal;const C=e.isSkinnedMesh&&e.skeleton,b=s.maxVertexUniformVectors,D=s.maxVertexTextures>0&&(!!s.getExtension("OES_texture_float")||s.version>=2);let F=0;return D?F=1024:(F=e.skeleton?e.skeleton.bones.length:0,16*F>b&&(console.warn("Program: too many bones ("+F+"), current cpu only support "+Math.floor(b/16)+" bones!!"),F=Math.floor(b/16))),R.useSkinning=C,R.bonesNum=F,R.useVertexTexture=D,R}generateProgramCode(t,e){let n="";for(const e in t)n+=t[e]+"_";for(const t in e.defines)n+=t+"_"+e.defines[t]+"_";return e.type!==w.SHADER||e.shaderName||(n+=e.vertexShader,n+=e.fragmentShader),n}}let ki=0;function Wi(t){return ki|=1<<t,0===t?"a_Uv":`a_Uv${t+1}`}function Xi(t){let e;return t?t.encoding&&(e=t.encoding):e=G.LINEAR,e}function qi(t){switch(t){case G.LINEAR:return["Linear","(value)"];case G.SRGB:return["sRGB","(value)"];case G.GAMMA:return["Gamma","(value, float(GAMMA_FACTOR))"];default:console.error("unsupported encoding: "+t)}}function ji(t,e){const n=qi(e);return"vec4 "+t+"(vec4 value) { return "+n[0]+"ToLinear"+n[1]+"; }"}function Yi(t,e){const n=qi(e);return"vec4 "+t+"(vec4 value) { return LinearTo"+n[0]+n[1]+"; }"}function Qi(t){let e="";for(let n=1;n<8;n++)t&1<<n&&(e+="attribute vec2 a_Uv"+(n+1)+";",7!==n&&(e+="\n"));return e}const Zi=function(t){return t.replace(/#include +<([\w\d.]+)>/g,(function(t,e){const n=di[e];if(void 0===n)throw new Error("Can not resolve #include <"+e+">");return Zi(n)}))};function Ki(t){return""!==t}function $i(t,e){return t.replace(/NUM_HEMI_LIGHTS/g,e.hemisphereLightNum).replace(/NUM_DIR_LIGHTS/g,e.directLightNum).replace(/NUM_SPOT_LIGHTS/g,e.spotLightNum).replace(/NUM_POINT_LIGHTS/g,e.pointLightNum).replace(/NUM_RECT_AREA_LIGHTS/g,e.rectAreaLightNum).replace(/NUM_DIR_SHADOWS/g,e.directShadowNum).replace(/NUM_SPOT_SHADOWS/g,e.spotShadowNum).replace(/NUM_POINT_SHADOWS/g,e.pointShadowNum)}function Ji(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes)}const tr=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function er(t,e,n,i){let r="";for(let t=parseInt(e);t<parseInt(n);t++)r+=i.replace(/\[\s*i\s*\]/g,"["+t+"]").replace(/UNROLLED_LOOP_INDEX/g,t);return r}function nr(t){return t.replace(tr,er)}const ir=/#extension .*/g;class rr extends wn{constructor(t,e,n){super(t),this._gl=e,this._capabilities=n;const i=n.timerQuery,r=this,s=t=>{const a=t.target,o=r.get(a);a.removeEventListener("dispose",s),o._webglQuery&&(n.version>1?e.deleteQuery(o._webglQuery):i.deleteQueryEXT(o._webglQuery)),r.delete(a)};this._onQueryDispose=s,this._typeToGL={[q.ANY_SAMPLES_PASSED]:35887,[q.ANY_SAMPLES_PASSED_CONSERVATIVE]:36202,[q.TIME_ELAPSED]:35007}}_get(t){const e=this._capabilities,n=this.get(t);return void 0===n._webglQuery&&(t.addEventListener("dispose",this._onQueryDispose),n._webglQuery=e.version>1?this._gl.createQuery():e.timerQuery.createQueryEXT(),n._target=null,n._result=null),n}begin(t,e){const n=this._capabilities,i=this._typeToGL,r=this._get(t);n.version>1?this._gl.beginQuery(i[e],r._webglQuery):n.timerQuery.beginQueryEXT(i[e],r._webglQuery),r._target=e,r._result=null}end(t){const e=this._capabilities,n=this._typeToGL,i=this._get(t);e.version>1?this._gl.endQuery(n[i._target]):e.timerQuery.endQueryEXT(n[i._target])}counter(t){const e=this._capabilities.timerQuery,n=this._get(t);e.queryCounterEXT(n._webglQuery,e.TIMESTAMP_EXT),n._target=e.TIMESTAMP_EXT,n._result=null}isResultAvailable(t){const e=this._gl,n=this._capabilities,i=n.timerQuery,r=this._get(t);let s;return s=n.version>1?e.getQueryParameter(r._webglQuery,e.QUERY_RESULT_AVAILABLE):i.getQueryObjectEXT(r._webglQuery,i.QUERY_RESULT_AVAILABLE),s}isTimerDisjoint(){return this._gl.getParameter(this._capabilities.timerQuery.GPU_DISJOINT_EXT)}getResult(t){const e=this._gl,n=this._capabilities,i=n.timerQuery,r=this._get(t);return null===r._result&&(n.version>1?r._result=e.getQueryParameter(r._webglQuery,e.QUERY_RESULT):r._result=i.getQueryObjectEXT(r._webglQuery,i.QUERY_RESULT_EXT)),r._result}}class sr{constructor(t,e){this._gl=t,this._capabilities=e}getGLType(t){const e=this._gl,n=this._capabilities,i=n.version>=2;if(t===F.UNSIGNED_BYTE)return e.UNSIGNED_BYTE;if(t===F.UNSIGNED_SHORT_5_6_5)return e.UNSIGNED_SHORT_5_6_5;if(t===F.UNSIGNED_SHORT_4_4_4_4)return e.UNSIGNED_SHORT_4_4_4_4;if(t===F.UNSIGNED_SHORT_5_5_5_1)return e.UNSIGNED_SHORT_5_5_5_1;let r;if(i){if(t===F.UNSIGNED_SHORT)return e.UNSIGNED_SHORT;if(t===F.UNSIGNED_INT)return e.UNSIGNED_INT;if(t===F.UNSIGNED_INT_24_8)return e.UNSIGNED_INT_24_8;if(t===F.FLOAT)return e.FLOAT;if(t===F.HALF_FLOAT)return e.HALF_FLOAT;if(t===F.FLOAT_32_UNSIGNED_INT_24_8_REV)return e.FLOAT_32_UNSIGNED_INT_24_8_REV;if(t===F.BYTE)return e.BYTE;if(t===F.SHORT)return e.SHORT;if(t===F.INT)return e.INT}else{if(t===F.UNSIGNED_SHORT||t===F.UNSIGNED_INT||t===F.UNSIGNED_INT_24_8){if(r=n.getExtension("WEBGL_depth_texture"),!r)return console.warn("extension WEBGL_depth_texture is not support."),null;if(t===F.UNSIGNED_SHORT)return e.UNSIGNED_SHORT;if(t===F.UNSIGNED_INT)return e.UNSIGNED_INT;if(t===F.UNSIGNED_INT_24_8)return r.UNSIGNED_INT_24_8_WEBGL}if(t===F.FLOAT)return r=n.getExtension("OES_texture_float"),r?e.FLOAT:(console.warn("extension OES_texture_float is not support."),null);if(t===F.HALF_FLOAT)return r=n.getExtension("OES_texture_half_float"),r?r.HALF_FLOAT_OES:(console.warn("extension OES_texture_half_float is not support."),null)}return void 0!==e[t]?e[t]:t}getGLFormat(t){const e=this._gl,n=this._capabilities;if(t===D.RGB)return e.RGB;if(t===D.RGBA)return e.RGBA;if(t===D.ALPHA)return e.ALPHA;if(t===D.LUMINANCE)return e.LUMINANCE;if(t===D.LUMINANCE_ALPHA)return e.LUMINANCE_ALPHA;if(t===D.DEPTH_COMPONENT)return e.DEPTH_COMPONENT;if(t===D.DEPTH_STENCIL)return e.DEPTH_STENCIL;if(t===D.RED)return e.RED;if(t===D.RED_INTEGER)return e.RED_INTEGER;if(t===D.RG)return e.RG;if(t===D.RG_INTEGER)return e.RG_INTEGER;if(t===D.RGB_INTEGER)return e.RGB_INTEGER;if(t===D.RGBA_INTEGER)return e.RGBA_INTEGER;let i;if(t===D.RGB_S3TC_DXT1||t===D.RGBA_S3TC_DXT1||t===D.RGBA_S3TC_DXT3||t===D.RGBA_S3TC_DXT5){if(i=n.getExtension("WEBGL_compressed_texture_s3tc"),!i)return console.warn("extension WEBGL_compressed_texture_s3tc is not support."),null;if(t===D.RGB_S3TC_DXT1)return i.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===D.RGBA_S3TC_DXT1)return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===D.RGBA_S3TC_DXT3)return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===D.RGBA_S3TC_DXT5)return i.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(t===D.RGB_PVRTC_4BPPV1||t===D.RGB_PVRTC_2BPPV1||t===D.RGBA_PVRTC_4BPPV1||t===D.RGBA_PVRTC_2BPPV1){if(i=n.getExtension("WEBGL_compressed_texture_pvrtc"),!i)return console.warn("extension WEBGL_compressed_texture_pvrtc is not support."),null;if(t===D.RGB_PVRTC_4BPPV1)return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(t===D.RGB_PVRTC_2BPPV1)return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(t===D.RGBA_PVRTC_4BPPV1)return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(t===D.RGBA_PVRTC_2BPPV1)return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}return t===D.RGB_ETC1?(i=n.getExtension("WEBGL_compressed_texture_etc1"),i?i.COMPRESSED_RGB_ETC1_WEBGL:(console.warn("extension WEBGL_compressed_texture_etc1 is not support."),null)):t===D.RGBA_ASTC_4x4?(i=n.getExtension("WEBGL_compressed_texture_astc"),i?i.COMPRESSED_RGBA_ASTC_4x4_KHR:(console.warn("extension WEBGL_compressed_texture_astc is not support."),null)):t===D.RGBA_BPTC?(i=n.getExtension("EXT_texture_compression_bptc"),i?i.COMPRESSED_RGBA_BPTC_UNORM_EXT:(console.warn("extension EXT_texture_compression_bptc is not support."),null)):void 0!==e[t]?e[t]:t}getGLInternalFormat(t){const e=this._gl,n=this._capabilities,i=n.version>=2;if(t===D.RGBA4)return e.RGBA4;if(t===D.RGB5_A1)return e.RGB5_A1;if(t===D.DEPTH_COMPONENT16)return e.DEPTH_COMPONENT16;if(t===D.STENCIL_INDEX8)return e.STENCIL_INDEX8;if(t===D.DEPTH_STENCIL)return e.DEPTH_STENCIL;let r;if(i){if(t===D.R8)return e.R8;if(t===D.RG8)return e.RG8;if(t===D.RGB8)return e.RGB8;if(t===D.RGBA8)return e.RGBA8;if(t===D.DEPTH_COMPONENT24)return e.DEPTH_COMPONENT24;if(t===D.DEPTH_COMPONENT32F)return e.DEPTH_COMPONENT32F;if(t===D.DEPTH24_STENCIL8)return e.DEPTH24_STENCIL8;if(t===D.DEPTH32F_STENCIL8)return e.DEPTH32F_STENCIL8;if(t===D.R16F||t===D.RG16F||t===D.RGB16F||t===D.RGBA16F||t===D.R32F||t===D.RG32F||t===D.RGB32F||t===D.RGBA32F||t===D.R11F_G11F_B10F){if(r=n.getExtension("EXT_color_buffer_float"),!r)return console.warn("extension EXT_color_buffer_float is not support."),null;if(t===D.R16F)return e.R16F;if(t===D.RG16F)return e.RG16F;if(t===D.RGB16F)return e.RGB16F;if(t===D.RGBA16F)return e.RGBA16F;if(t===D.R32F)return e.R32F;if(t===D.RG32F)return e.RG32F;if(t===D.RGB32F)return e.RGB32F;if(t===D.RGBA32F)return e.RGBA32F;if(t===D.R11F_G11F_B10F)return e.R11F_G11F_B10F}}else if(t===D.RGBA32F||t===D.RGB32F){if(r=n.getExtension("WEBGL_color_buffer_float"),!r)return console.warn("extension WEBGL_color_buffer_float is not support."),null;if(t===D.RGBA32F)return r.RGBA32F_EXT;if(t===D.RGB32F)return r.RGB32F_EXT}return void 0!==e[t]?e[t]:t}}function ar(t,e,n,i){const r=new Uint8Array(4),s=t.createTexture();t.bindTexture(e,s),t.texParameteri(e,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(e,t.TEXTURE_MAG_FILTER,t.NEAREST);for(let e=0;e<i;e++)t.texImage2D(n+e,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,r);return s}function or(t){let e=!1;const n=new ne;let i=null;const r=new ne(0,0,0,0);return{setMask:function(n){i===n||e||(t.colorMask(n,n,n,n),i=n)},setLocked:function(t){e=t},setClear:function(e,i,s,a,o){!0===o&&(e*=a,i*=a,s*=a),n.set(e,i,s,a),!1===r.equals(n)&&(t.clearColor(e,i,s,a),r.copy(n))},getClear:function(){return r},reset:function(){e=!1,i=null,r.set(-1,0,0,0)}}}function lr(t,e){let n=!1,i=null,r=null,s=null;return{setTest:function(n){n?e.enable(t.DEPTH_TEST):e.disable(t.DEPTH_TEST)},setMask:function(e){i===e||n||(t.depthMask(e),i=e)},setFunc:function(e){r!==e&&(t.depthFunc(e),r=e)},setLocked:function(t){n=t},setClear:function(e){s!==e&&(t.clearDepth(e),s=e)},reset:function(){n=!1,i=null,r=null,s=null}}}function hr(t,e){let n=!1,i=null,r=null,s=null,a=null,o=null,l=null,h=null,c=null,u=null,d=null,p=null,f=null,_=null,m=null;return{setTest:function(n){n?e.enable(t.STENCIL_TEST):e.disable(t.STENCIL_TEST)},setMask:function(e){i===e||n||(t.stencilMask(e),i=e)},setFunc:function(e,n,i,o,l,h){r===e&&s===n&&a===i&&c===o&&u===l&&d===h||(null===o||null===l||null===h?t.stencilFunc(e,n,i):(t.stencilFuncSeparate(t.FRONT,e,n,i),t.stencilFuncSeparate(t.BACK,o,l,h)),r=e,s=n,a=i,c=o,u=l,d=h)},setOp:function(e,n,i,r,s,a){o===e&&l===n&&h===i&&p===r&&f===s&&_===a||(null===r||null===s||null===a?t.stencilOp(e,n,i):(t.stencilOpSeparate(t.FRONT,e,n,i),t.stencilOpSeparate(t.BACK,r,s,a)),o=e,l=n,h=i,p=r,f=s,_=a)},setLocked:function(t){n=t},setClear:function(e){m!==e&&(t.clearStencil(e),m=e)},reset:function(){n=!1,i=null,r=null,s=null,a=null,o=null,l=null,h=null,c=null,u=null,d=null,p=null,f=null,_=null,m=null}}}class cr{constructor(t,e){this.gl=t,this.capabilities=e,this.colorBuffer=new or(t),this.depthBuffer=new lr(t,this),this.stencilBuffer=new hr(t,this),this.states={},this.currentBlending=null,this.currentBlendEquation=null,this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendEquationAlpha=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null,this.currentPremultipliedAlpha=null,this.currentFlipSided=!1,this.currentCullFace=null;const n=t.getParameter(t.VIEWPORT);this.currentViewport=(new ne).fromArray(n),this.currentLineWidth=null,this.currentPolygonOffsetFactor=null,this.currentPolygonOffsetUnits=null,this.currentProgram=null,this.currentBoundBuffers={},this.currentRenderTarget=null,this.currentTextureSlot=null,this.currentBoundTextures={},this.emptyTextures={},this.emptyTextures[t.TEXTURE_2D]=ar(t,t.TEXTURE_2D,t.TEXTURE_2D,1),this.emptyTextures[t.TEXTURE_CUBE_MAP]=ar(t,t.TEXTURE_CUBE_MAP,t.TEXTURE_CUBE_MAP_POSITIVE_X,6),this.blendEquationToGL={[L.ADD]:t.FUNC_ADD,[L.SUBTRACT]:t.FUNC_SUBTRACT,[L.REVERSE_SUBTRACT]:t.FUNC_REVERSE_SUBTRACT,[L.MIN]:t.MIN,[L.MAX]:t.MAX},this.blendFactorToGL={[C.ZERO]:t.ZERO,[C.ONE]:t.ONE,[C.SRC_COLOR]:t.SRC_COLOR,[C.SRC_ALPHA]:t.SRC_ALPHA,[C.SRC_ALPHA_SATURATE]:t.SRC_ALPHA_SATURATE,[C.DST_COLOR]:t.DST_COLOR,[C.DST_ALPHA]:t.DST_ALPHA,[C.ONE_MINUS_SRC_COLOR]:t.ONE_MINUS_SRC_COLOR,[C.ONE_MINUS_SRC_ALPHA]:t.ONE_MINUS_SRC_ALPHA,[C.ONE_MINUS_DST_COLOR]:t.ONE_MINUS_DST_COLOR,[C.ONE_MINUS_DST_ALPHA]:t.ONE_MINUS_DST_ALPHA},this.colorBuffer.setClear(0,0,0,1),this.depthBuffer.setClear(1),this.stencilBuffer.setClear(0),this.depthBuffer.setTest(!0),this.depthBuffer.setFunc(U.LEQUAL),this.setFlipSided(!1),this.setCullFace(b.BACK)}enable(t){!0!==this.states[t]&&(this.gl.enable(t),this.states[t]=!0)}disable(t){!1!==this.states[t]&&(this.gl.disable(t),this.states[t]=!1)}setBlending(t,e,n,i,r,s,a,o){const l=this.gl;if(t!==R.NONE){if(this.enable(l.BLEND),t!==R.CUSTOM)t===this.currentBlending&&o===this.currentPremultipliedAlpha||(this.currentBlendEquation===L.ADD&&this.currentBlendEquationAlpha===L.ADD||(l.blendEquation(l.FUNC_ADD),this.currentBlendEquation=L.ADD,this.currentBlendEquationAlpha=L.ADD),t===R.NORMAL?o?l.blendFuncSeparate(l.ONE,l.ONE_MINUS_SRC_ALPHA,l.ONE,l.ONE_MINUS_SRC_ALPHA):l.blendFuncSeparate(l.SRC_ALPHA,l.ONE_MINUS_SRC_ALPHA,l.ONE,l.ONE_MINUS_SRC_ALPHA):t===R.ADD?o?l.blendFunc(l.ONE,l.ONE):l.blendFunc(l.SRC_ALPHA,l.ONE):t===R.SUB?l.blendFuncSeparate(l.ZERO,l.ONE_MINUS_SRC_COLOR,l.ZERO,l.ONE):t===R.MUL?o?l.blendFuncSeparate(l.ZERO,l.SRC_COLOR,l.ZERO,l.SRC_ALPHA):l.blendFunc(l.ZERO,l.SRC_COLOR):console.error("WebGLState: Invalid blending: ",t)),this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null;else{r=r||e,s=s||n,a=a||i;const t=this.blendEquationToGL,o=this.blendFactorToGL;e===this.currentBlendEquation&&r===this.currentBlendEquationAlpha||(l.blendEquationSeparate(t[e],t[r]),this.currentBlendEquation=e,this.currentBlendEquationAlpha=r),n===this.currentBlendSrc&&i===this.currentBlendDst&&s===this.currentBlendSrcAlpha&&a===this.currentBlendDstAlpha||(l.blendFuncSeparate(o[n],o[i],o[s],o[a]),this.currentBlendSrc=n,this.currentBlendDst=i,this.currentBlendSrcAlpha=s,this.currentBlendDstAlpha=a)}this.currentBlending=t,this.currentPremultipliedAlpha=o}else this.disable(l.BLEND)}setFlipSided(t){const e=this.gl;this.currentFlipSided!==t&&(t?e.frontFace(e.CW):e.frontFace(e.CCW),this.currentFlipSided=t)}setCullFace(t){const e=this.gl;t!==b.NONE?(this.enable(e.CULL_FACE),t!==this.currentCullFace&&(t===b.BACK?e.cullFace(e.BACK):t===b.FRONT?e.cullFace(e.FRONT):e.cullFace(e.FRONT_AND_BACK))):this.disable(e.CULL_FACE),this.currentCullFace=t}viewport(t){const e=this.currentViewport;e.equals(t)||(this.gl.viewport(t.x,t.y,t.z,t.w),e.copy(t))}setLineWidth(t){if(t!==this.currentLineWidth){const e=this.capabilities.lineWidthRange;e[0]<=t&&t<=e[1]?this.gl.lineWidth(t):console.warn("GL_ALIASED_LINE_WIDTH_RANGE is ["+e[0]+","+e[1]+"], but set to "+t+"."),this.currentLineWidth=t}}setPolygonOffset(t,e,n){const i=this.gl;t?(this.enable(i.POLYGON_OFFSET_FILL),this.currentPolygonOffsetFactor===e&&this.currentPolygonOffsetUnits===n||(i.polygonOffset(e,n),this.currentPolygonOffsetFactor=e,this.currentPolygonOffsetUnits=n)):this.disable(i.POLYGON_OFFSET_FILL)}setProgram(t){this.currentProgram!==t&&(this.gl.useProgram(t.program),this.currentProgram=t)}bindBuffer(t,e){const n=this.gl;this.currentBoundBuffers[t]!==e&&(n.bindBuffer(t,e),this.currentBoundBuffers[t]=e)}activeTexture(t){const e=this.gl;void 0===t&&(t=e.TEXTURE0+this.capabilities.maxTextures-1),this.currentTextureSlot!==t&&(e.activeTexture(t),this.currentTextureSlot=t)}bindTexture(t,e){const n=this.gl;null===this.currentTextureSlot&&this.activeTexture();let i=this.currentBoundTextures[this.currentTextureSlot];void 0===i&&(i={type:void 0,texture:void 0},this.currentBoundTextures[this.currentTextureSlot]=i),i.type===t&&i.texture===e||(n.bindTexture(t,e||this.emptyTextures[t]),i.type=t,i.texture=e)}reset(){const t=this.gl;t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(t.LESS),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(t.ALWAYS,0,4294967295),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.clearStencil(0),t.disable(t.BLEND),t.disable(t.CULL_FACE),t.disable(t.DEPTH_TEST),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.ONE,t.ZERO),t.blendFuncSeparate(t.ONE,t.ZERO,t.ONE,t.ZERO),t.cullFace(t.BACK),t.frontFace(t.CCW),t.viewport(0,0,t.canvas.width,t.canvas.height),t.lineWidth(1),t.polygonOffset(0,0),t.useProgram(null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.activeTexture(t.TEXTURE0),this.colorBuffer.reset(),this.depthBuffer.reset(),this.stencilBuffer.reset(),this.states={},this.currentBlending=null,this.currentBlendEquation=null,this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendEquationAlpha=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null,this.currentPremultipliedAlpha=null,this.currentFlipSided=!1,this.currentCullFace=null,this.currentViewport.set(0,0,t.canvas.width,t.canvas.height),this.currentLineWidth=null,this.currentPolygonOffsetFactor=null,this.currentPolygonOffsetUnits=null,this.currentProgram=null,this.currentBoundBuffers={},this.currentRenderTarget=null,this.currentTextureSlot=null,this.currentBoundTextures={}}setMaterial(t,e){this.setCullFace(t.side===P.DOUBLE?b.NONE:b.BACK);let n=t.side===P.BACK;e&&(n=!n),this.setFlipSided(n),t.blending===R.NORMAL&&!1===t.transparent?this.setBlending(R.NONE):this.setBlending(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),this.depthBuffer.setFunc(t.depthFunc),this.depthBuffer.setTest(t.depthTest),this.depthBuffer.setMask(t.depthWrite),this.colorBuffer.setMask(t.colorWrite);const i=t.stencilTest;this.stencilBuffer.setTest(i),i&&(this.stencilBuffer.setMask(t.stencilWriteMask),this.stencilBuffer.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask,t.stencilFuncBack,t.stencilRefBack,t.stencilFuncMaskBack),this.stencilBuffer.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass,t.stencilFailBack,t.stencilZFailBack,t.stencilZPassBack)),this.setPolygonOffset(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),void 0!==t.lineWidth&&this.setLineWidth(t.lineWidth),!0===t.alphaToCoverage?this.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE):this.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE)}}class ur extends wn{constructor(t,e,n,i,r){super(t),this._gl=e,this._state=n,this._capabilities=i,this._constants=r,this._usedTextureUnits=0;const s=this;this._onTextureDispose=function t(n){const i=n.target,r=s.get(i);i.removeEventListener("dispose",t),r.__webglTexture&&!r.__external&&e.deleteTexture(r.__webglTexture),s.delete(i)},this._wrappingToGL={[O.REPEAT]:e.REPEAT,[O.CLAMP_TO_EDGE]:e.CLAMP_TO_EDGE,[O.MIRRORED_REPEAT]:e.MIRRORED_REPEAT},this._filterToGL={[I.NEAREST]:e.NEAREST,[I.LINEAR]:e.LINEAR,[I.NEAREST_MIPMAP_NEAREST]:e.NEAREST_MIPMAP_NEAREST,[I.LINEAR_MIPMAP_NEAREST]:e.LINEAR_MIPMAP_NEAREST,[I.NEAREST_MIPMAP_LINEAR]:e.NEAREST_MIPMAP_LINEAR,[I.LINEAR_MIPMAP_LINEAR]:e.LINEAR_MIPMAP_LINEAR}}allocTexUnit(){const t=this._usedTextureUnits++;return t>=this._capabilities.maxTextures&&console.warn("trying to use "+t+" texture units while this GPU supports only "+this._capabilities.maxTextures),t}resetTextureUnits(){this._usedTextureUnits=0}setTexture2D(t,e){const n=this._gl,i=this._state,r=this._capabilities,s=this._constants;void 0!==e&&(e=n.TEXTURE0+e);const a=this.get(t);if(t.image&&a.__version!==t.version&&(!t.image.rtt||void 0===e)&&!a.__external){void 0===a.__webglTexture&&(t.addEventListener("dispose",this._onTextureDispose),a.__webglTexture=n.createTexture()),i.activeTexture(e),i.bindTexture(n.TEXTURE_2D,a.__webglTexture);let o=t.image;const l=vr(o);l&&(o=mr(o,r.maxTextureSize),dr(t)&&!1===fr(o)&&r.version<2&&(o=_r(o)));const h=!fr(o)&&r.version<2;this._setPixelStores(t),this._setTextureParameters(t,h);const c=s.getGLFormat(t.format),u=s.getGLType(t.type),d=null!==t.internalformat?s.getGLInternalFormat(t.internalformat):gr(n,r,c,u),p=t.mipmaps;let f;if(l)if(p.length>0&&!h){for(let t=0,e=p.length;t<e;t++)f=p[t],n.texImage2D(n.TEXTURE_2D,t,d,c,u,f);t.generateMipmaps=!1,a.__maxMipLevel=p.length-1}else n.texImage2D(n.TEXTURE_2D,0,d,c,u,o),a.__maxMipLevel=0;else if(p.length>0&&!h){const e=o.isCompressed;for(let i=0,r=p.length;i<r;i++)f=p[i],e?n.compressedTexImage2D(n.TEXTURE_2D,i,d,f.width,f.height,0,f.data):n.texImage2D(n.TEXTURE_2D,i,d,f.width,f.height,t.border,c,u,f.data);t.generateMipmaps=!1,a.__maxMipLevel=p.length-1}else n.texImage2D(n.TEXTURE_2D,0,d,o.width,o.height,t.border,c,u,o.data),a.__maxMipLevel=0;return t.generateMipmaps&&!h&&this._generateMipmap(n.TEXTURE_2D,t,o.width,o.height),a.__version=t.version,a}return i.activeTexture(e),i.bindTexture(n.TEXTURE_2D,a.__webglTexture),a}setTextureCube(t,e){const n=this._gl,i=this._state,r=this._capabilities,s=this._constants;void 0!==e&&(e=n.TEXTURE0+e);const a=this.get(t);if(!(6!==t.images.length||a.__version===t.version||t.images[0].rtt&&void 0!==e||a.__external)){void 0===a.__webglTexture&&(t.addEventListener("dispose",this._onTextureDispose),a.__webglTexture=n.createTexture()),i.activeTexture(e),i.bindTexture(n.TEXTURE_CUBE_MAP,a.__webglTexture);const o=[];let l=!1;for(let e=0;e<6;e++){let n=t.images[e];const i=vr(n);i&&(n=mr(n,r.maxTextureSize),dr(t)&&!1===fr(n)&&r.version<2&&(n=_r(n))),!fr(n)&&r.version<2&&(l=!0),o[e]=n,n.__isDom=i}this._setPixelStores(t),this._setTextureParameters(t,l);const h=s.getGLFormat(t.format),c=s.getGLType(t.type),u=null!==t.internalformat?s.getGLInternalFormat(t.internalformat):gr(n,r,h,c),d=t.mipmaps;let p;for(let e=0;e<6;e++){const i=o[e];if(i.__isDom)if(d.length>0&&!l){for(let t=0,i=d.length;t<i;t++)p=d[t][e],n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+e,t,u,h,c,p);a.__maxMipLevel=d.length-1,t.generateMipmaps=!1}else n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,u,h,c,i),a.__maxMipLevel=0;else if(d.length>0&&!l){const r=i.isCompressed;for(let i=0,s=d.length;i<s;i++)p=d[i][e],r?n.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,u,p.width,p.height,0,p.data):n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,u,p.width,p.height,t.border,h,c,p.data);a.__maxMipLevel=d.length-1,t.generateMipmaps=!1}else n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,u,i.width,i.height,t.border,h,c,i.data),a.__maxMipLevel=0}return t.generateMipmaps&&!l&&this._generateMipmap(n.TEXTURE_CUBE_MAP,t,o[0].width,o[0].height),a.__version=t.version,a}return i.activeTexture(e),i.bindTexture(n.TEXTURE_CUBE_MAP,a.__webglTexture),a}setTexture3D(t,e){const n=this._gl,i=this._state,r=this._capabilities,s=this._constants;if(r.version<2)return void console.warn("Try to use Texture3D but browser not support WebGL2.0");void 0!==e&&(e=n.TEXTURE0+e);const a=this.get(t);if(t.image&&a.__version!==t.version&&!a.__external){void 0===a.__webglTexture&&(t.addEventListener("dispose",this._onTextureDispose),a.__webglTexture=n.createTexture()),i.activeTexture(e),i.bindTexture(n.TEXTURE_3D,a.__webglTexture),this._setPixelStores(t),this._setTextureParameters(t,!1);const o=t.image,l=s.getGLFormat(t.format),h=s.getGLType(t.type),c=null!==t.internalformat?s.getGLInternalFormat(t.internalformat):gr(n,r,l,h);return n.texImage3D(n.TEXTURE_3D,0,c,o.width,o.height,o.depth,t.border,l,h,o.data),t.generateMipmaps&&this._generateMipmap(n.TEXTURE_3D,t,o.width,o.height),a.__version=t.version,a}return i.activeTexture(e),i.bindTexture(n.TEXTURE_3D,a.__webglTexture),a}setTexture2DArray(t,e){const n=this._gl,i=this._state,r=this._capabilities,s=this._constants;if(r.version<2)return void console.warn("Try to use Texture2DArray but browser not support WebGL2.0");void 0!==e&&(e=n.TEXTURE0+e);const a=this.get(t);if(t.image&&a.__version!==t.version&&!a.__external){void 0===a.__webglTexture&&(t.addEventListener("dispose",this._onTextureDispose),a.__webglTexture=n.createTexture()),i.activeTexture(e),i.bindTexture(n.TEXTURE_2D_ARRAY,a.__webglTexture),this._setPixelStores(t),this._setTextureParameters(t,!1);const o=t.image,l=s.getGLFormat(t.format),h=s.getGLType(t.type),c=null!==t.internalformat?s.getGLInternalFormat(t.internalformat):gr(n,r,l,h);if(t.layerUpdates.size>0){for(const e of t.layerUpdates){const i=Tr(o.width,o.height,t.format,t.type),r=o.data.subarray(e*i/o.data.BYTES_PER_ELEMENT,(e+1)*i/o.data.BYTES_PER_ELEMENT);n.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,e,o.width,o.height,1,l,h,r)}t.layerUpdates.clear()}else n.texImage3D(n.TEXTURE_2D_ARRAY,0,c,o.width,o.height,o.depth,t.border,l,h,o.data);return t.generateMipmaps&&this._generateMipmap(n.TEXTURE_2D_ARRAY,t,o.width,o.height),a.__version=t.version,a}return i.activeTexture(e),i.bindTexture(n.TEXTURE_2D_ARRAY,a.__webglTexture),a}setTextureExternal(t,e){const n=this._gl,i=this.get(t);i.__external||(i.__webglTexture?n.deleteTexture(i.__webglTexture):t.addEventListener("dispose",this._onTextureDispose)),i.__webglTexture=e,i.__external=!0}_setPixelStores(t){const e=this._gl;e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,t.flipY),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.premultiplyAlpha),e.pixelStorei(e.UNPACK_ALIGNMENT,t.unpackAlignment),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,e.NONE)}_setTextureParameters(t,e){const n=this._gl,i=this._capabilities,r=this._wrappingToGL,s=this._filterToGL;let a=n.TEXTURE_2D;t.isTextureCube&&(a=n.TEXTURE_CUBE_MAP),t.isTexture3D&&(a=n.TEXTURE_3D),t.isTexture2DArray&&(a=n.TEXTURE_2D_ARRAY);let o=t.wrapS,l=t.wrapT,h=t.wrapR,c=t.magFilter,u=t.minFilter;e&&(o=O.CLAMP_TO_EDGE,l=O.CLAMP_TO_EDGE,t.isTexture3D&&(h=O.CLAMP_TO_EDGE),t.wrapS===O.CLAMP_TO_EDGE&&t.wrapT===O.CLAMP_TO_EDGE||console.warn("Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to TEXTURE_WRAP.CLAMP_TO_EDGE.",t),c=pr(t.magFilter),u=pr(t.minFilter),(t.minFilter!==I.NEAREST&&t.minFilter!==I.LINEAR||t.magFilter!==I.NEAREST&&t.magFilter!==I.LINEAR)&&console.warn("Texture is not power of two. Texture.minFilter and Texture.magFilter should be set to TEXTURE_FILTER.NEAREST or TEXTURE_FILTER.LINEAR.",t)),n.texParameteri(a,n.TEXTURE_WRAP_S,r[o]),n.texParameteri(a,n.TEXTURE_WRAP_T,r[l]),t.isTexture3D&&n.texParameteri(a,n.TEXTURE_WRAP_R,r[h]),n.texParameteri(a,n.TEXTURE_MAG_FILTER,s[c]),n.texParameteri(a,n.TEXTURE_MIN_FILTER,s[u]);const d=i.anisotropyExt;d&&n.texParameterf(a,d.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(t.anisotropy,i.maxAnisotropy)),i.version>=2&&(void 0!==t.compare?(n.texParameteri(a,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(a,n.TEXTURE_COMPARE_FUNC,t.compare)):n.texParameteri(a,n.TEXTURE_COMPARE_MODE,n.NONE))}_generateMipmap(t,e,n,i){this._gl.generateMipmap(t);this.get(e).__maxMipLevel=Math.log(Math.max(n,i))*Math.LOG2E}}function dr(t){return t.wrapS!==O.CLAMP_TO_EDGE||t.wrapT!==O.CLAMP_TO_EDGE||t.minFilter!==I.NEAREST&&t.minFilter!==I.LINEAR}function pr(t){return t===I.NEAREST||t===I.NEAREST_MIPMAP_LINEAR||t===I.NEAREST_MIPMAP_NEAREST?I.NEAREST:I.LINEAR}function fr(t){return e.isPowerOfTwo(t.width)&&e.isPowerOfTwo(t.height)}function _r(t){if(t instanceof HTMLImageElement||t instanceof HTMLCanvasElement){const n=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");n.width=e.nearestPowerOfTwo(t.width),n.height=e.nearestPowerOfTwo(t.height);return n.getContext("2d").drawImage(t,0,0,n.width,n.height),console.warn("image is not power of two ("+t.width+"x"+t.height+"). Resized to "+n.width+"x"+n.height,t),n}return t}function mr(t,e){if(t.width>e||t.height>e){const n=e/Math.max(t.width,t.height),i=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");i.width=Math.floor(t.width*n),i.height=Math.floor(t.height*n);return i.getContext("2d").drawImage(t,0,0,t.width,t.height,0,0,i.width,i.height),console.warn("image is too big ("+t.width+"x"+t.height+"). Resized to "+i.width+"x"+i.height,t),i}return t}function gr(t,e,n,i){if(!1===e.version>=2)return n;let r=n;return n===t.RED&&(i===t.FLOAT&&(r=t.R32F),i===t.HALF_FLOAT&&(r=t.R16F),i===t.UNSIGNED_BYTE&&(r=t.R8)),n===t.RG&&(i===t.FLOAT&&(r=t.RG32F),i===t.HALF_FLOAT&&(r=t.RG16F),i===t.UNSIGNED_BYTE&&(r=t.RG8)),n===t.RGB&&(i===t.FLOAT&&(r=t.RGB32F),i===t.HALF_FLOAT&&(r=t.RGB16F),i===t.UNSIGNED_BYTE&&(r=t.RGB8)),n===t.RGBA&&(i===t.FLOAT&&(r=t.RGBA32F),i===t.HALF_FLOAT&&(r=t.RGBA16F),i===t.UNSIGNED_BYTE&&(r=t.RGBA8),i===t.UNSIGNED_SHORT_4_4_4_4&&(r=t.RGBA4),i===t.UNSIGNED_SHORT_5_5_5_1&&(r=t.RGB5_A1)),n!==t.DEPTH_COMPONENT&&n!==t.DEPTH_STENCIL||(r=t.DEPTH_COMPONENT16,i===t.FLOAT&&(r=t.DEPTH_COMPONENT32F),i===t.UNSIGNED_INT&&(r=t.DEPTH_COMPONENT24),i===t.UNSIGNED_INT_24_8&&(r=t.DEPTH24_STENCIL8),i===t.FLOAT_32_UNSIGNED_INT_24_8_REV&&(r=t.DEPTH32F_STENCIL8)),r!==t.R16F&&r!==t.R32F&&r!==t.RG16F&&r!==t.RG32F&&r!==t.RGB16F&&r!==t.RGB32F&&r!==t.RGBA16F&&r!==t.RGBA32F||e.getExtension("EXT_color_buffer_float"),r}function vr(t){return"undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||"undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement||"undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap}function Tr(t,e,n,i){const r=function(t){switch(t){case F.UNSIGNED_BYTE:case F.ByteType:return Sr.byteLength=1,Sr.components=1,Sr;case F.UNSIGNED_SHORT:case F.SHORT:case F.HALF_FLOAT:return Sr.byteLength=2,Sr.components=1,Sr;case F.UNSIGNED_SHORT_4_4_4_4:case F.UNSIGNED_SHORT_5_5_5_1:return Sr.byteLength=2,Sr.components=4,Sr;case F.UNSIGNED_INT:case F.INT:case F.FLOAT:return Sr.byteLength=4,Sr.components=1,Sr}throw new Error(`Unknown texture type ${t}.`)}(i);switch(n){case D.ALPHA:case D.LUMINANCE:return t*e;case D.LUMINANCE_ALPHA:return t*e*2;case D.RED:case D.RED_INTEGER:return t*e/r.components*r.byteLength;case D.RG:case D.RG_INTEGER:return t*e*2/r.components*r.byteLength;case D.RGB:return t*e*3/r.components*r.byteLength;case D.RGBA:case D.RGBA_INTEGER:return t*e*4/r.components*r.byteLength;case D.RGB_S3TC_DXT1:case D.RGBA_S3TC_DXT1:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*8;case D.RGBA_S3TC_DXT3:case D.RGBA_S3TC_DXT5:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case D.RGB_PVRTC_2BPPV1:case D.RGBA_PVRTC_2BPPV1:return Math.max(t,16)*Math.max(e,8)/4;case D.RGB_PVRTC_4BPPV1:case D.RGBA_PVRTC_4BPPV1:return Math.max(t,8)*Math.max(e,8)/2;case D.RGB_ETC1:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*8;case D.RGBA_ASTC_4x4:return Math.floor((t+3)/4)*Math.floor((e+3)/4)*16;case D.RGBA_BPTC:return Math.ceil(t/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${n} format.`)}const Sr={byteLength:0,components:0};class Er extends wn{constructor(t,e,n,i){super(t),this._gl=e,this._capabilities=n,this._constants=i;const r=this;this._onRenderBufferDispose=function t(n){const i=n.target;i.removeEventListener("dispose",t);const s=r.get(i);s.__webglRenderbuffer&&!s.__external&&e.deleteRenderbuffer(s.__webglRenderbuffer),r.delete(i)}}setRenderBuffer(t){const e=this._gl,n=this._capabilities,i=this._constants,r=this.get(t);if(void 0===r.__webglRenderbuffer){t.addEventListener("dispose",this._onRenderBufferDispose),r.__webglRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,r.__webglRenderbuffer);const s=i.getGLInternalFormat(t.format);t.multipleSampling>0?(n.version<2&&console.error("render buffer multipleSampling is not support in webgl 1.0."),e.renderbufferStorageMultisample(e.RENDERBUFFER,Math.min(t.multipleSampling,n.maxSamples),s,t.width,t.height)):e.renderbufferStorage(e.RENDERBUFFER,s,t.width,t.height)}else e.bindRenderbuffer(e.RENDERBUFFER,r.__webglRenderbuffer);return r}setRenderBufferExternal(t,e){const n=this._gl,i=this.get(t);i.__external||(i.__webglRenderbuffer?n.deleteRenderbuffer(i.__webglRenderbuffer):t.addEventListener("dispose",this._onRenderBufferDispose)),i.__webglRenderbuffer=e,i.__external=!0}}class xr extends wn{constructor(t,e,n,i,r,s,a){super(t),this._gl=e,this._state=n,this._capabilities=i,this._textures=r,this._renderBuffers=s,this._constants=a;const o=this;this._onRenderTargetDispose=function t(i){const r=i.target;r.removeEventListener("dispose",t);const s=o.get(r);s.__webglFramebuffer&&e.deleteFramebuffer(s.__webglFramebuffer),s.__readBuffer&&e.deleteBuffer(s.__readBuffer),o.delete(r),n.currentRenderTarget===r&&(n.currentRenderTarget=null)}}_setupRenderTarget(t){const e=this._gl,n=this._state,i=this._textures,r=this._renderBuffers,s=this._capabilities,a=this.get(t);t.addEventListener("dispose",this._onRenderTargetDispose);const o=e.createFramebuffer(),l=[];a.__webglFramebuffer=o,a.__drawBuffers=l,t.isRenderTargetCube&&(a.__currentActiveCubeFace=t.activeCubeFace,a.__currentActiveMipmapLevel=t.activeMipmapLevel),(t.isRenderTarget3D||t.isRenderTarget2DArray)&&(a.__currentActiveLayer=t.activeLayer,a.__currentActiveMipmapLevel=t.activeMipmapLevel),e.bindFramebuffer(e.FRAMEBUFFER,o);for(const a in t._attachments){const o=Mr[a];o===e.DEPTH_ATTACHMENT||o===e.DEPTH_STENCIL_ATTACHMENT?s.version<2&&!s.getExtension("WEBGL_depth_texture")&&console.warn("WebGLRenderTargets: extension WEBGL_depth_texture is not support."):o!==e.STENCIL_ATTACHMENT&&l.push(o);const h=t._attachments[a];if(h.isTexture2D){const t=i.setTexture2D(h);e.framebufferTexture2D(e.FRAMEBUFFER,o,e.TEXTURE_2D,t.__webglTexture,0),n.bindTexture(e.TEXTURE_2D,null)}else if(h.isTextureCube){const r=i.setTextureCube(h);e.framebufferTexture2D(e.FRAMEBUFFER,o,e.TEXTURE_CUBE_MAP_POSITIVE_X+t.activeCubeFace,r.__webglTexture,t.activeMipmapLevel),n.bindTexture(e.TEXTURE_CUBE_MAP,null)}else if(h.isTexture3D){const r=i.setTexture3D(h);e.framebufferTextureLayer(e.FRAMEBUFFER,o,r.__webglTexture,t.activeMipmapLevel,t.activeLayer),n.bindTexture(e.TEXTURE_3D,null)}else if(h.isTexture2DArray){const r=i.setTexture2DArray(h);e.framebufferTextureLayer(e.FRAMEBUFFER,o,r.__webglTexture,t.activeMipmapLevel,t.activeLayer),n.bindTexture(e.TEXTURE_2D_ARRAY,null)}else{const t=r.setRenderBuffer(h);e.framebufferRenderbuffer(e.FRAMEBUFFER,o,e.RENDERBUFFER,t.__webglRenderbuffer)}}l.sort(Ar),s.version>=2?e.drawBuffers(l):s.getExtension("WEBGL_draw_buffers")&&s.getExtension("WEBGL_draw_buffers").drawBuffersWEBGL(l)}setRenderTarget(t){const e=this._gl,n=this._state,i=this._textures;let r;if(n.currentRenderTarget!==t&&(t.isRenderTargetBack?e.bindFramebuffer(e.FRAMEBUFFER,null):(r=this.get(t),void 0===r.__webglFramebuffer?this._setupRenderTarget(t):e.bindFramebuffer(e.FRAMEBUFFER,r.__webglFramebuffer)),n.currentRenderTarget=t),t.isRenderTargetCube){r=this.get(t);const n=t.activeCubeFace,s=t.activeMipmapLevel;if(r.__currentActiveCubeFace!==n||r.__currentActiveMipmapLevel!==s){for(const r in t._attachments){const a=t._attachments[r];if(a.isTextureCube){const t=i.get(a);e.framebufferTexture2D(e.FRAMEBUFFER,Mr[r],e.TEXTURE_CUBE_MAP_POSITIVE_X+n,t.__webglTexture,s)}}r.__currentActiveCubeFace=n,r.__currentActiveMipmapLevel=s}}if(t.isRenderTarget3D||t.isRenderTarget2DArray){r=this.get(t);const n=t.activeLayer,s=t.activeMipmapLevel;if(r.__currentActiveLayer!==n||r.__currentActiveMipmapLevel!==s){for(const r in t._attachments){const a=t._attachments[r];if(a.isTexture3D||a.isTexture2DArray){const t=i.get(a);e.framebufferTextureLayer(e.FRAMEBUFFER,Mr[r],t.__webglTexture,s,n)}}r.__currentActiveLayer=n,r.__currentActiveMipmapLevel=s}}}blitRenderTarget(t,e,n=!0,i=!0,r=!0){const s=this._gl,a=this._capabilities;if(a.version<2)return void console.warn("WebGLRenderTargets: blitFramebuffer not support by WebGL"+a.version);const o=this.get(t).__webglFramebuffer,l=this.get(e).__webglFramebuffer;s.bindFramebuffer(s.READ_FRAMEBUFFER,o),s.bindFramebuffer(s.DRAW_FRAMEBUFFER,l);let h=0;n&&(h|=s.COLOR_BUFFER_BIT),i&&(h|=s.DEPTH_BUFFER_BIT),r&&(h|=s.STENCIL_BUFFER_BIT),s.blitFramebuffer(0,0,t.width,t.height,0,0,e.width,e.height,h,s.NEAREST)}readRenderTargetPixels(t,e,n,i,r){const s=this._gl,a=this._state,o=this._constants,l=a.currentRenderTarget;if(l&&l.texture){if(t>=0&&t<=l.width-n&&e>=0&&e<=l.height-i){const a=o.getGLType(l.texture.type),h=o.getGLFormat(l.texture.format);s.readPixels(t,e,n,i,h,a,r)}}else console.warn("WebGLRenderTargets.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not bound or texture not attached.")}readRenderTargetPixelsAsync(t,e,n,i,r){const s=this._gl,a=this._state,o=this._constants,l=a.currentRenderTarget;if(l&&l.texture){if(t>=0&&t<=l.width-n&&e>=0&&e<=l.height-i){const a=this.get(l);void 0===a.__readBuffer&&(a.__readBuffer=s.createBuffer()),s.bindBuffer(s.PIXEL_PACK_BUFFER,a.__readBuffer),s.bufferData(s.PIXEL_PACK_BUFFER,r.byteLength,s.STREAM_READ);const h=o.getGLType(l.texture.type),c=o.getGLFormat(l.texture.format);return s.readPixels(t,e,n,i,c,h,0),function(t){const e=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);return t.flush(),new Promise((function(n,i){function r(){const s=t.clientWaitSync(e,t.SYNC_FLUSH_COMMANDS_BIT,0);if(s===t.WAIT_FAILED)return t.deleteSync(e),void i();s!==t.TIMEOUT_EXPIRED?(t.deleteSync(e),n()):requestAnimationFrame(r)}r()}))}(s).then((()=>a.__readBuffer?(s.bindBuffer(s.PIXEL_PACK_BUFFER,a.__readBuffer),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r):Promise.reject("Read Buffer is not valid.")))}return Promise.resolve(r)}return console.warn("WebGLRenderTargets.readRenderTargetPixelsAsync: readPixels from renderTarget failed. Framebuffer not bound or texture not attached."),Promise.reject()}updateRenderTargetMipmap(t){const n=this._gl,i=this._state,r=this._capabilities,s=t.texture;if(s.generateMipmaps&&s.minFilter!==I.NEAREST&&s.minFilter!==I.LINEAR&&(function(t){return e.isPowerOfTwo(t.width)&&e.isPowerOfTwo(t.height)}(t)||r.version>=2)){let t=n.TEXTURE_2D;s.isTextureCube&&(t=n.TEXTURE_CUBE_MAP),s.isTexture3D&&(t=n.TEXTURE_3D);const e=this._textures.get(s).__webglTexture;i.bindTexture(t,e),n.generateMipmap(t),i.bindTexture(t,null)}}}const Mr={[W.COLOR_ATTACHMENT0]:36064,[W.COLOR_ATTACHMENT1]:36065,[W.COLOR_ATTACHMENT2]:36066,[W.COLOR_ATTACHMENT3]:36067,[W.COLOR_ATTACHMENT4]:36068,[W.COLOR_ATTACHMENT5]:36069,[W.COLOR_ATTACHMENT6]:36070,[W.COLOR_ATTACHMENT7]:36071,[W.COLOR_ATTACHMENT8]:36072,[W.COLOR_ATTACHMENT9]:36073,[W.COLOR_ATTACHMENT10]:36074,[W.COLOR_ATTACHMENT11]:36075,[W.COLOR_ATTACHMENT12]:36076,[W.COLOR_ATTACHMENT13]:36077,[W.COLOR_ATTACHMENT14]:36078,[W.COLOR_ATTACHMENT15]:36079,[W.DEPTH_ATTACHMENT]:36096,[W.STENCIL_ATTACHMENT]:36128,[W.DEPTH_STENCIL_ATTACHMENT]:33306};function Ar(t,e){return t-e}class yr extends wn{constructor(t,e,n){super(t),this._gl=e,this._capabilities=n}setBuffer(t,e,n){const i=this.get(t),r=void 0===i.glBuffer;(r||i.version!==t.version)&&(n&&n.reset(),r||i.__external?this._createGLBuffer(i,t,e):(this._updateGLBuffer(i.glBuffer,t,e),i.version=t.version))}removeBuffer(t){const e=this._gl,n=this.get(t);n.glBuffer&&!n.__external&&e.deleteBuffer(n.glBuffer),this.delete(t)}setBufferExternal(t,e){const n=this._gl,i=this.get(t);i.__external||i.glBuffer&&n.deleteBuffer(i.glBuffer);const r=wr(n,t.array);i.glBuffer=e,i.type=r,i.bytesPerElement=t.array.BYTES_PER_ELEMENT,i.version=t.version,i.__external=!0}_createGLBuffer(t,e,n){const i=this._gl,r=e.array,s=e.usage,a=i.createBuffer();i.bindBuffer(n,a),i.bufferData(n,r,s),e.onUploadCallback();const o=wr(i,r);t.glBuffer=a,t.type=o,t.bytesPerElement=r.BYTES_PER_ELEMENT,t.version=e.version,t.__external=!1,e.updateRange.count=-1}_updateGLBuffer(t,e,n){const i=this._gl,r=this._capabilities,s=e.array,a=e.updateRange;i.bindBuffer(n,t),-1===a.count?i.bufferSubData(n,0,s):(r.version>=2?i.bufferSubData(n,a.offset*s.BYTES_PER_ELEMENT,s,a.offset,a.count):i.bufferSubData(n,a.offset*s.BYTES_PER_ELEMENT,s.subarray(a.offset,a.offset+a.count)),a.count=-1)}}function wr(t,e){let n;return e instanceof Float32Array?n=t.FLOAT:e instanceof Float64Array?console.warn("Unsupported data buffer format: Float64Array."):n=e instanceof Uint16Array?t.UNSIGNED_SHORT:e instanceof Int16Array?t.SHORT:e instanceof Uint32Array?t.UNSIGNED_INT:e instanceof Int32Array?t.INT:e instanceof Int8Array?t.BYTE:e instanceof Uint8Array?t.UNSIGNED_BYTE:t.FLOAT,n}class Rr extends wn{constructor(t,e,n){super(t);const i=this;this._onMaterialDispose=function t(r){const s=r.target,a=i.get(s);s.removeEventListener("dispose",t);const o=a.programList;if(void 0!==o)for(let t=0,i=o.length;t<i;t++){const i=o[t];n.releaseByProgram(i),e.releaseProgram(i)}i.delete(s)},this._programs=e,this._vertexArrayBindings=n}setMaterial(t){const e=this.get(t);return void 0===e.programList&&(t.addEventListener("dispose",this._onMaterialDispose),e.programList=[]),e}updateProgram(t,e,n,i,r){const s=this._programs,a=this._vertexArrayBindings,o=this.get(t),l=s.generateProps(t,e,n,i),h=s.generateProgramCode(l,t),c=o.programList;let u=function(t,e){let n=0,i=null;for(let r=t.length;n<r;n++){const r=t[n];if(r.code===e){i=r;break}}if(null!==i&&n>0){for(let e=n;e>0;e--)t[e]=t[e-1];t[0]=i}return i}(c,h);if(null===u&&(u=s.getProgram(t,l,h,r),c.unshift(u),c.length>r.maxMaterialPrograms)){const t=c.pop();a.releaseByProgram(t),s.releaseProgram(t)}o.currentProgram=u}}class Lr extends wn{constructor(t,e,n,i){super(t),this._gl=e,this._capabilities=n,this._buffers=i,this._isWebGL2=n.version>=2,this._vaoExt=n.getExtension("OES_vertex_array_object"),this._vaoCache={},this._currentGeometryProgram="",this._currentVAO=null}setup(t,e,n){if(t.morphTargetInfluences)this.reset(),this._setupVertexAttributes(n,e),this._currentGeometryProgram="";else if(this._isWebGL2||this._vaoExt){const t=this.get(e);void 0===t._vaos&&(t._vaos={},this._vaoCache[e.id]=t._vaos);let i=t._vaos[n.id];i||(i=t._vaos[n.id]={version:-1,object:this._createVAO()}),this._bindVAO(i.object),i.version!==e.version&&(this._setupVertexAttributes(n,e),i.version=e.version)}else{const t=n.id+"_"+e.id+"_"+e.version;t!==this._currentGeometryProgram&&(this._setupVertexAttributes(n,e),this._currentGeometryProgram=t)}}releaseByGeometry(t){const e=this.get(t),n=e._vaos;if(n){for(const t in n){const e=n[t];e&&this._disposeVAO(e.object)}delete e._vaos,delete this._vaoCache[t.id]}}releaseByProgram(t){for(const e in this._vaoCache){const n=this._vaoCache[e];if(n){const e=n[t.id];if(!e)continue;this._disposeVAO(e.object),delete n[t.id]}}}reset(t){(null!==this._currentVAO||t)&&(this._isWebGL2?this._gl.bindVertexArray(null):this._vaoExt&&this._vaoExt.bindVertexArrayOES(null),this._currentVAO=null),""!==this._currentGeometryProgram&&(this._currentGeometryProgram="")}_createVAO(){return this._isWebGL2?this._gl.createVertexArray():this._vaoExt?this._vaoExt.createVertexArrayOES():null}_bindVAO(t){this._currentVAO!==t&&(this._isWebGL2?this._gl.bindVertexArray(t):this._vaoExt&&this._vaoExt.bindVertexArrayOES(t),this._currentVAO=t)}_disposeVAO(t){this._isWebGL2?this._gl.deleteVertexArray(t):this._vaoExt&&this._vaoExt.deleteVertexArrayOES(t)}_setupVertexAttributes(t,e){const n=this._gl,i=this._isWebGL2,r=t.getAttributes(),s=this._capabilities,a=this._buffers;for(const t in r){const o=r[t],l=e.getAttribute(t);if(l){const e=l.size;o.count!==e&&console.warn("WebGLVertexArrayBindings: attribute "+t+" size not match! "+o.count+" : "+e);const r=l.buffer,h=a.get(r),c=h.type,u=i&&(o.format===n.INT||o.format===n.UNSIGNED_INT);for(let t=0,e=o.locationSize;t<e;t++)n.enableVertexAttribArray(o.location+t);if(l.divisor>0)for(let t=0,e=o.locationSize;t<e;t++)i?n.vertexAttribDivisor(o.location+t,l.divisor):s.getExtension("ANGLE_instanced_arrays")?s.getExtension("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(o.location+t,l.divisor):console.warn("vertexAttribDivisor not supported");const d=h.bytesPerElement,p=h.glBuffer,f=r.stride,_=l.offset,m=l.normalized;if(n.bindBuffer(n.ARRAY_BUFFER,p),o.count===f&&1===o.locationSize)this._vertexAttribPointer(o.location,o.count,c,m,0,0,u);else for(let t=0;t<o.locationSize;t++)this._vertexAttribPointer(o.location+t,o.count/o.locationSize,c,m,d*f,d*(_+o.count/o.locationSize*t),u)}}if(e.index){const t=a.get(e.index.buffer);n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t.glBuffer)}}_vertexAttribPointer(t,e,n,i,r,s,a){const o=this._gl;a?o.vertexAttribIPointer(t,e,n,r,s):o.vertexAttribPointer(t,e,n,i,r,s)}}class Cr{constructor(t){this.lightsTexture=new Pr,this.lightsTexture.initLights(t.maxClusterLights,t.useFloatPrecision?F.FLOAT:F.HALF_FLOAT),this.cellsTexture=new br,this.cellsTexture.initCells(t.gridDimensions,t.maxLightsPerCell),this._zClip=t.zClip.clone(),this._cellsTextureEmpty=!1,this.cellsTransform={clips:[0,0],factors:[0,0,0,0],perspective:!0}}dispose(){this._cellsTextureEmpty=!1,this.cellsTexture.dispose(),this.lightsTexture.dispose()}setOptions(t){this.lightsTexture.updateLights(t.maxClusterLights,t.useFloatPrecision?F.FLOAT:F.HALF_FLOAT),this.cellsTexture.updateCells(t.gridDimensions,t.maxLightsPerCell),this._zClip.copy(t.zClip)}update(t,e,n=!0){this._updateCellsTransform(e),this.cellsTexture.resetLightIndices();const i=this.cellsTexture.cellsInfo.table,r=this.cellsTransform;let s=!1;for(let a=0;a<t.pointsNum;a++){const o=t.point[a];Or(o,Dr),Dr.center.applyMatrix4(e.viewMatrix),Dr.center.z*=-1,zr(Dr,i,r,Fr)&&(s=this.cellsTexture.setLightIndex(Fr,a)||s,n&&this.lightsTexture.setPointLight(a,o))}for(let a=0;a<t.spotsNum;a++){const o=t.spot[a];Ur(o,Dr),Dr.center.applyMatrix4(e.viewMatrix),Dr.center.z*=-1,zr(Dr,i,r,Fr)&&(s=this.cellsTexture.setLightIndex(Fr,a+t.pointsNum)||s,n&&this.lightsTexture.setSpotLight(a+t.pointsNum,o))}s&&n&&this.lightsTexture.version++,(s||!this._cellsTextureEmpty)&&this.cellsTexture.version++,this._cellsTextureEmpty=!s}_updateCellsTransform(t){const{clips:e,factors:n}=this.cellsTransform;this._zClip.toArray(e),e[0]=e[0]>0?e[0]:t.near,e[1]=e[1]>0?e[1]:t.far;const i=this.cellsTexture.cellsInfo.table[2],r=Math.log(e[1]/e[0]);n[0]=i/r,n[1]=-i*Math.log(e[0])/r;const s=-1===t.projectionMatrix.elements[11];const a=t.projectionMatrix.elements;n[2]=(s?1:-1)/a[5],n[3]=a[5]/a[0],this.cellsTransform.perspective=s}}class br extends On{constructor(){super(),this.format=D.RED,this.type=F.HALF_FLOAT,this.magFilter=I.NEAREST,this.minFilter=I.NEAREST,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.cellsInfo={table:[],maxLightsPerCell:0,textureSize:[],dotData:[]},this._counts=null}initCells(t,e){const n=t.x*t.y*t.z,i=n*e;let r=Math.ceil(Math.sqrt(i));r=Math.ceil(r/e)*e;const s=Math.ceil(i/r),a=new Uint16Array(r*s);this.image={data:a,width:r,height:s},t.toArray(this.cellsInfo.table),this.cellsInfo.maxLightsPerCell=e,this.cellsInfo.textureSize[0]=r,this.cellsInfo.textureSize[1]=1/r,this.cellsInfo.textureSize[2]=1/s,this.cellsInfo.dotData[0]=e,this.cellsInfo.dotData[1]=t.x*t.z*e,this.cellsInfo.dotData[2]=t.x*e,this._counts=new Int32Array(n)}updateCells(t,e){const n=this.cellsInfo;Ir.fromArray(n.table).equals(t)&&n.maxLightsPerCell===e||(this.dispose(),this.initCells(t,e),this.version++)}resetLightIndices(){this.image.data.fill(0),this._counts.fill(0)}setLightIndex(t,n){const i=this.image.data,r=this._counts,{table:s,maxLightsPerCell:a}=this.cellsInfo,{min:o,max:l}=t;let h=!1;for(let t=o.x;t<=l.x;t++)for(let c=o.z;c<=l.z;c++)for(let u=o.y;u<=l.y;u++){const o=t+s[0]*(c+u*s[2]),l=r[o];if(l<a){i[o*a+l]=e.toHalfFloat(n+1),r[o]++,h=!0}}return h}}class Pr extends On{constructor(){super(),this.format=D.RGBA,this.magFilter=I.NEAREST,this.minFilter=I.NEAREST,this.generateMipmaps=!1,this.flipY=!1}initLights(t,e){const n=Br(t),i=new(e===F.FLOAT?Float32Array:Uint16Array)(n*n*4);this.image={data:i,width:n,height:n},this.type=e}updateLights(t,e){Br(t)===this.image.width&&e===this.type||(this.dispose(),this.initLights(t,e),this.version++)}setPointLight(t,n){const i=this.image.data,r=this.type===F.HALF_FLOAT,s=t*Nr*4,{color:a,decay:o,position:l,distance:h}=n;i[s+0+0]=r?e.toHalfFloat(1):1,i[s+4+0]=r?e.toHalfFloat(a[0]):a[0],i[s+4+1]=r?e.toHalfFloat(a[1]):a[1],i[s+4+2]=r?e.toHalfFloat(a[2]):a[2],i[s+4+3]=r?e.toHalfFloat(o):o,i[s+8+0]=r?e.toHalfFloat(l[0]):l[0],i[s+8+1]=r?e.toHalfFloat(l[1]):l[1],i[s+8+2]=r?e.toHalfFloat(l[2]):l[2],i[s+8+3]=r?e.toHalfFloat(h):h}setSpotLight(t,n){const i=this.image.data,r=this.type===F.HALF_FLOAT,s=t*Nr*4,{color:a,decay:o,position:l,distance:h,direction:c,coneCos:u,penumbraCos:d}=n;i[s+0+0]=r?e.toHalfFloat(2):2,i[s+0+1]=r?e.toHalfFloat(d):d,i[s+4+0]=r?e.toHalfFloat(a[0]):a[0],i[s+4+1]=r?e.toHalfFloat(a[1]):a[1],i[s+4+2]=r?e.toHalfFloat(a[2]):a[2],i[s+4+3]=r?e.toHalfFloat(o):o,i[s+8+0]=r?e.toHalfFloat(l[0]):l[0],i[s+8+1]=r?e.toHalfFloat(l[1]):l[1],i[s+8+2]=r?e.toHalfFloat(l[2]):l[2],i[s+8+3]=r?e.toHalfFloat(h):h,i[s+12+0]=r?e.toHalfFloat(c[0]):c[0],i[s+12+1]=r?e.toHalfFloat(c[1]):c[1],i[s+12+2]=r?e.toHalfFloat(c[2]):c[2],i[s+12+3]=r?e.toHalfFloat(u):u}}const Nr=4,Dr=new Yt,Fr=new ct,Ir=new r;function Or(t,e){e.center.fromArray(t.position),e.radius=t.distance}function Ur(t,e){t.coneCos<.70710678118?(Ir.fromArray(t.direction).multiplyScalar(t.distance*t.coneCos),e.center.fromArray(t.position).add(Ir),e.radius=t.distance*Math.sqrt(1-t.coneCos*t.coneCos)):(Ir.fromArray(t.direction).multiplyScalar(t.distance/(2*t.coneCos)),e.center.fromArray(t.position).add(Ir),e.radius=t.distance/(2*t.coneCos))}function Br(t){return Math.max(e.nextPowerOfTwo(Math.ceil(Math.sqrt(t*Nr))),Nr)}function zr(t,e,n,i){const{center:r,radius:s}=t,{clips:a,factors:o,perspective:l}=n;let h=r.z-s;const c=r.z+s;if(h>a[1]||c<a[0])return!1;h=Math.max(h,a[0]);const u=Math.floor(Math.log(h)*o[0]+o[1]),d=Math.min(Math.floor(Math.log(c)*o[0]+o[1]),e[2]-1),p=(l?Math.abs(r.z):-1)*o[2],f=1/(2*p),_=(r.y-s)*f+.5,m=(r.y+s)*f+.5;if(_>1||m<0)return!1;const g=Math.max(Math.floor(_*e[1]),0),v=Math.min(Math.floor(m*e[1]),e[1]-1),T=1/(2*(p*o[3])),S=(r.x-s)*T+.5,E=(r.x+s)*T+.5;if(S>1||E<0)return!1;const x=Math.max(Math.floor(S*e[0]),0),M=Math.min(Math.floor(E*e[0]),e[0]-1);return i.min.set(x,g,u),i.max.set(M,v,d),!0}class Gr extends wn{constructor(t,e,n){super(t);const i=this;this._onLightingGroupDispose=function t(e){const n=e.target,r=i.get(n);n.removeEventListener("dispose",t),r.clustered&&r.clustered.dispose(),i.delete(n)},this._capabilities=e,this._textures=n}setLightingGroup(t,e,n,i){const r=this.get(t);if(r.pass===e.count)return r;if(r.pass=e.count,void 0===r.state&&(t.addEventListener("dispose",this._onLightingGroupDispose),r.state=new Hr,r.uploadVersion=0),0===t.totalNum)return r;const s=n.clustered,a=s.enabled;let o=!1;if(r.lightingVersion!==t.version||r.clusteredEnabled!==a){r.state.update(t,a),r.uploadVersion++;const e=r.state._factor[10]>0;r.lightingVersion=t.version,r.clusteredEnabled=a,r.hasClusteredLights=e,o=e,e&&!r.clustered?(r.clustered=new Cr(s),r.clusteredOptionVersion=s.version):!a&&r.clustered&&(r.clustered.dispose(),delete r.clustered)}if(r.hasClusteredLights){r.clusteredOptionVersion!==s.version&&(r.clustered.setOptions(s),r.clusteredOptionVersion=s.version,o=!0);let e=!1;r.cameraId===i.id&&r.cameraVersion===i.version||(r.cameraId=i.id,r.cameraVersion=i.version,e=!0),(o||e)&&r.clustered.update(t,i,o)}return r}uploadUniforms(t,e,n){const i=this.get(e);let r=!1;t.lightId===e.id&&t.lightVersion===i.uploadVersion||(r=!0,t.lightId=e.id,t.lightVersion=i.uploadVersion);const s=t.getUniforms(),a=this._capabilities,o=this._textures,l=i.state._factor;if(l[0]&&r&&s.set("u_AmbientLightColor",e.ambient),l[1]&&r&&s.set("u_SphericalHarmonicsLightData",e.sh),l[2]>0&&r&&s.set("u_Hemi",e.hemisphere),l[3]>0&&(r&&s.set("u_Directional",e.directional),l[7]>0&&(r&&s.set("u_DirectionalShadow",e.directionalShadow),s.has("directionalShadowMap")&&(a.version>=2&&!n?s.set("directionalShadowMap",e.directionalShadowDepthMap,o):s.set("directionalShadowMap",e.directionalShadowMap,o),s.set("directionalShadowMatrix",e.directionalShadowMatrix)),s.has("directionalDepthMap")&&s.set("directionalDepthMap",e.directionalShadowMap,o))),l[4]>0&&(r&&s.set("u_Point",e.point),l[8]>0&&(r&&s.set("u_PointShadow",e.pointShadow),s.has("pointShadowMap")&&(s.set("pointShadowMap",e.pointShadowMap,o),s.set("pointShadowMatrix",e.pointShadowMatrix)))),l[5]>0&&(r&&s.set("u_Spot",e.spot),l[9]>0&&(r&&s.set("u_SpotShadow",e.spotShadow),s.has("spotShadowMap")&&(a.version>=2&&!n?s.set("spotShadowMap",e.spotShadowDepthMap,o):s.set("spotShadowMap",e.spotShadowMap,o),s.set("spotShadowMatrix",e.spotShadowMatrix)),s.has("spotDepthMap")&&s.set("spotDepthMap",e.spotShadowMap,o))),l[6]>0&&(r&&s.set("u_RectArea",e.rectArea),e.LTC1&&e.LTC2?(s.set("ltc_1",e.LTC1,o),s.set("ltc_2",e.LTC2,o)):console.warn("WebGLRenderer: RectAreaLight.LTC1 and LTC2 need to be set before use.")),l[10]>0){const t=i.clustered,e=t.cellsTexture.cellsInfo;s.set("maxLightsPerCell",e.maxLightsPerCell),s.set("cells",e.table),s.set("cellsDotData",e.dotData),s.set("cellsTextureSize",e.textureSize),s.set("cellsTransformFactors",t.cellsTransform.factors),s.set("lightsTexture",t.lightsTexture,o),s.set("cellsTexture",t.cellsTexture,o)}}}class Hr{constructor(){this._factor=new Uint16Array(11),this._totalNum=0,this._shadowsNum=0}update(t,e){const n=this._factor;if(n[0]=t.useAmbient?1:0,n[1]=t.useSphericalHarmonics?1:0,n[2]=t.hemisNum,n[3]=t.directsNum,n[4]=t.pointsNum,n[5]=t.spotsNum,n[6]=t.rectAreaNum,n[7]=t.directShadowNum,n[8]=t.pointShadowNum,n[9]=t.spotShadowNum,n[10]=0,this._totalNum=t.totalNum,this._shadowsNum=t.shadowsNum,e){const t=n[4]-n[8],e=n[5]-n[9];n[4]=n[8],n[5]=n[9],n[10]=t+e>0?1:0}}compare(t){if(!t)return!1;const e=this._factor;for(let n=0,i=t.length;n<i;n++)if(e[n]!==t[n])return!1;return!0}copyTo(t){const e=this._factor;return t||(t=new e.constructor(this._factor.length)),t.set(e),t}hasLight(){return this._totalNum>0}hasShadow(){return this._shadowsNum>0}setProgramProps(t,e){const n=this._factor;t.useAmbientLight=n[0],t.useSphericalHarmonicsLight=n[1],t.hemisphereLightNum=n[2],t.directLightNum=n[3],t.pointLightNum=n[4],t.spotLightNum=n[5],t.rectAreaLightNum=n[6],t.directShadowNum=e?n[7]:0,t.pointShadowNum=e?n[8]:0,t.spotShadowNum=e?n[9]:0,t.useClusteredLights=n[10],t.useShadow=this._shadowsNum>0&&e}}const Vr=new ne,kr=new a,Wr=new WeakMap,Xr=new Float32Array(8),qr={map:null,diffuse:1,specular:1};let jr=new Float32Array([]);function Yr(t){return t.geometry}function Qr(t){return t.material}function Zr(t){return!0}const Kr=new ue;class $r extends Ln{constructor(t){super(t),this.capabilities={},this._textures=null,this._renderBuffers=null,this._renderTargets=null,this._buffers=null,this._geometries=null,this._lights=null,this._programs=null,this._materials=null,this._state=null,this._vertexArrayBindings=null,this._queries=null,this.init(),this._currentMaterial=null}init(){const t=this.context,e=`_gl${this.increaseId()}`,n=new mi(t),i=new sr(t,n),r=new cr(t,n),s=new ur(e,t,r,n,i),a=new Er(e,t,n,i),o=new xr(e,t,r,n,s,a,i),l=new yr(e,t,n),h=new Lr(e,t,n,l),c=new vi(e,t,l,h),u=new Gr(e,n,s),d=new Vi(t,r,n),p=new Rr(e,d,h),f=new rr(e,t,n);this.capabilities=n,this._textures=s,this._renderBuffers=a,this._renderTargets=o,this._buffers=l,this._geometries=c,this._lights=u,this._programs=d,this._materials=p,this._state=r,this._vertexArrayBindings=h,this._queries=f}endRender(){super.endRender(),this._currentMaterial=null;const t=this._state;t.depthBuffer.setTest(!0),t.depthBuffer.setMask(!0),t.colorBuffer.setMask(!0)}clear(t,e,n){const i=this.context;let r=0;(void 0===t||t)&&(r|=i.COLOR_BUFFER_BIT),(void 0===e||e)&&(r|=i.DEPTH_BUFFER_BIT),(void 0===n||n)&&(r|=i.STENCIL_BUFFER_BIT),r>0&&i.clear(r)}setClearColor(t,e,n,i,r){this._state.colorBuffer.setClear(t,e,n,i,r)}getClearColor(){return this._state.colorBuffer.getClear()}setRenderTarget(t){this._renderTargets.setRenderTarget(t)}getRenderTarget(){return this._state.currentRenderTarget}blitRenderTarget(t,e,n=!0,i=!0,r=!0){this._renderTargets.blitRenderTarget(t,e,n,i,r)}readRenderTargetPixels(t,e,n,i,r){return this.asyncReadPixel?this._renderTargets.readRenderTargetPixelsAsync(t,e,n,i,r):(this._renderTargets.readRenderTargetPixels(t,e,n,i,r),Promise.resolve(r))}updateRenderTargetMipmap(t){this._renderTargets.updateRenderTargetMipmap(t)}setTextureExternal(t,e){this._textures.setTextureExternal(t,e)}setRenderBufferExternal(t,e){this._renderBuffers.setRenderBufferExternal(t,e)}setBufferExternal(t,e){this._buffers.setBufferExternal(t,e)}resetVertexArrayBindings(t){this._vertexArrayBindings.reset(t)}resetState(){this._state.reset()}beginQuery(t,e){this._queries.begin(t,e)}endQuery(t){this._queries.end(t)}queryCounter(t){this._queries.counter(t)}isTimerQueryDisjoint(t){return this._queries.isTimerDisjoint(t)}isQueryResultAvailable(t){return this._queries.isResultAvailable(t)}getQueryResult(t){return this._queries.getResult(t)}renderRenderableItem(t,e,n){const i=this._state,r=this.capabilities,s=this._vertexArrayBindings,a=this._textures,o=this._passInfo,l=n.getGeometry||Yr,h=n.getMaterial||Qr,c=n.beforeRender,u=n.afterRender,d=n.ifRender||Zr,p=n.renderInfo,f=e.scene,_=e.camera,m=i.currentRenderTarget;if(!d(t))return;if(!o.enabled)return void console.warn("WebGLRenderer: beginRender must be called before renderRenderableItem.");const g=t.object,v=h.call(this,t),T=l.call(this,t),S=t.group,E=v.fog?f.fog:null,x=function(t,e){if(!e.acceptLight)return Kr;const n=t.getGroup(e.lightingGroup);return n&&n.totalNum>0?n:Kr}(e.lighting,v),M=this._lights.setLightingGroup(x,o,this.lightingOptions,_).state,A=M.hasLight(),y=M.hasShadow()&&g.receiveShadow;qr.map=void 0!==v.envMap?v.envMap||f.environment:null,qr.diffuse=f.envDiffuseIntensity*v.envMapIntensity,qr.specular=f.envSpecularIntensity*v.envMapIntensity;let w=f.clippingPlanesData,R=f.numClippingPlanes;v.clippingPlanes&&v.clippingPlanes.length>0&&(jr.length<4*v.clippingPlanes.length&&(jr=new Float32Array(4*v.clippingPlanes.length)),w=f.setClippingPlanesData(v.clippingPlanes,jr),R=v.clippingPlanes.length),g.onBeforeRender(t,v),c&&c.call(this,t,v);const L=this._materials.setMaterial(v);!1===v.needsUpdate&&(void 0===L.currentProgram||L.fog!==E||L.envMap!==qr.map||L.numClippingPlanes!==R||L.logarithmicDepthBuffer!==f.logarithmicDepthBuffer||e.outputEncoding!==L.outputEncoding||e.gammaFactor!==L.gammaFactor||r.version>1&&f.disableShadowSampler!==L.disableShadowSampler||A!==L.hasLighting?v.needsUpdate=!0:A&&(M.compare(L.lightingFactors)?y!==L.hasShadow?v.needsUpdate=!0:y&&(v.needsUpdate=L.shadowType!==g.shadowType):v.needsUpdate=!0)),v.needsUpdate&&(this._materials.updateProgram(v,g,M,e,this.shaderCompileOptions),L.fog=E,L.envMap=qr.map,L.logarithmicDepthBuffer=f.logarithmicDepthBuffer,L.hasLighting=A,L.lightingFactors=M.copyTo(L.lightingFactors),L.hasShadow=y,L.shadowType=g.shadowType,L.numClippingPlanes=R,L.outputEncoding=e.outputEncoding,L.gammaFactor=e.gammaFactor,L.disableShadowSampler=f.disableShadowSampler,v.needsUpdate=!1);const C=L.currentProgram;if(n.onlyCompile||!C.isReady(r.parallelShaderCompileExt))return;i.setProgram(C),this._geometries.setGeometry(T,o),g.morphTargetInfluences&&this._updateMorphtargets(g,T,C),s.setup(g,T,C);let b=!1;C.cameraId===_.id&&C.cameraVersion===_.version||(b=!0,C.cameraId=_.id,C.cameraVersion=_.version);let P=!1;C.sceneId===f.id&&C.sceneVersion===f.version||(P=!0,C.sceneId=f.id,C.sceneVersion=f.version);let N=!0;v.forceUpdateUniforms||(L.pass!==o.count?L.pass=o.count:N=this._currentMaterial!==v),this._currentMaterial=v;const D=C.getUniforms();A&&this._lights.uploadUniforms(C,x,f.disableShadowSampler),g.isSkinnedMesh&&this._uploadSkeleton(D,g,f);for(let t=0,e=D.seq.length;t<e;t++){const e=D.seq[t],n=e.id,i=e.internalGroup;if(v.uniforms&&void 0!==v.uniforms[n])e.set(v.uniforms[n],a);else if(1!==i)if(2===i&&b)e.internalFun(_);else if(3===i&&P)e.internalFun(f);else if(4===i&&N)e.internalFun(v,a);else if(5!==i)if("u_PointScale"===n){const t=.5*m.height;e.set(t)}else"clippingPlanes"===n&&e.set(w);else e.internalFun(qr,a);else{let t=g.worldMatrix;f.useAnchorMatrix&&(t=kr.copy(t).premultiply(f.anchorMatrixInverse)),e.set(t.elements)}}const F=g.worldMatrix.determinant()<0;i.setMaterial(v,F);const I=Vr.set(m.width,m.height,m.width,m.height).multiply(_.rect);I.z-=I.x,I.w-=I.y,i.viewport(I.round()),this._draw(T,v,S,p),a.resetTextureUnits(),u&&u.call(this,t),g.onAfterRender(t)}_uploadSkeleton(t,e,n){if(e.skeleton&&e.skeleton.bones.length>0){const i=e.skeleton,r=this.capabilities;r.maxVertexTextures>0&&(r.getExtension("OES_texture_float")||r.version>=2)?(void 0===i.boneTexture&&i.generateBoneTexture(r.version>=2),t.set("boneTexture",i.boneTexture,this._textures),t.set("boneTextureSize",i.boneTexture.image.width)):t.set("boneMatrices",i.boneMatrices),t.set("bindMatrix",e.bindMatrix.elements),kr.copy(e.bindMatrixInverse),n.useAnchorMatrix&&kr.multiply(n.anchorMatrix),t.set("bindMatrixInverse",kr.elements)}}_updateMorphtargets(t,e,n){const i=t.morphTargetInfluences;Wr.has(e)||Wr.set(e,i.slice(0));const r=e.morphAttributes.position,s=e.morphAttributes.normal,a=Wr.get(e);for(let t=0;t<a.length;t++){0!==a[t]&&(r&&e.removeAttribute("morphTarget"+t),s&&e.removeAttribute("morphNormal"+t))}for(let t=0;t<i.length;t++)a[t]=i[t];a.length=i.length;let o=0;for(let t=0;t<a.length;t++){const n=a[t];n>0&&(r&&e.addAttribute("morphTarget"+o,r[t]),s&&e.addAttribute("morphNormal"+o,s[t]),Xr[o]=n,o++)}for(;o<8;o++)Xr[o]=0;n.getUniforms().set("morphTargetInfluences",Xr)}_draw(t,e,n,i){const r=this.context,s=this.capabilities,a=this._buffers,o=t.instanceCount,l=o>=0,h=!!n,c=h&&void 0!==n.multiDrawCount,u=null!==t.index;let d=0,p=1/0;if(!c){const e=t.getAttribute("a_Position");if(u?p=t.index.buffer.count:e&&(p=e.buffer.count),h&&(d=Math.max(d,n.start),p=Math.min(p,n.count)),p<0||p===1/0)return}if(u){const i=a.get(t.index.buffer),h=i.bytesPerElement,u=i.type;if(u===r.UNSIGNED_INT&&s.version<2&&!s.getExtension("OES_element_index_uint")&&console.warn("WebGLRenderer: draw elements type not support UNSIGNED_INT!"),l){if(o<=0)return;if(s.version>=2)r.drawElementsInstanced(e.drawMode,p,u,d*h,o);else{if(!s.getExtension("ANGLE_instanced_arrays"))return void console.warn("WebGLRenderer: using instanced draw but hardware does not support.");s.getExtension("ANGLE_instanced_arrays").drawElementsInstancedANGLE(e.drawMode,p,u,d*h,o)}}else if(c){if(n.multiDrawCount<=0)return;const t=s.getExtension("WEBGL_multi_draw");if(!t)return void console.warn("WebGLRenderer: using multi draw but hardware does not support extension WEBGL_multi_draw.");t.multiDrawElementsWEBGL(e.drawMode,n.multiDrawCounts,0,u,n.multiDrawStarts,0,n.multiDrawCount)}else r.drawElements(e.drawMode,p,u,d*h)}else if(l){if(o<=0)return;if(s.version>=2)r.drawArraysInstanced(e.drawMode,d,p,o);else{if(!s.getExtension("ANGLE_instanced_arrays"))return void console.warn("WebGLRenderer: using instanced draw but hardware does not support.");s.getExtension("ANGLE_instanced_arrays").drawArraysInstancedANGLE(e.drawMode,d,p,o)}}else if(c){if(n.multiDrawCount<=0)return;const t=s.getExtension("WEBGL_multi_draw");if(!t)return void console.warn("WebGLRenderer: using multi draw but hardware does not support extension WEBGL_multi_draw.");t.multiDrawArraysWEBGL(e.drawMode,n.multiDrawStarts,0,n.multiDrawCounts,0,n.multiDrawCount)}else r.drawArrays(e.drawMode,d,p);if(i){if(c){p=0;for(let t=0;t<n.multiDrawCount;t++)p+=n.multiDrawCounts[t]}i.update(p,e.drawMode,o<0?1:o)}}}class Jr extends oe{constructor(){super(),console.warn("Group has been deprecated, use Object3D instead.")}}Jr.prototype.isGroup=!0,Object.defineProperties($r.prototype,{gl:{configurable:!0,get:function(){return console.warn("WebGLRenderer: .gl has been deprecated, use .context instead."),this.context}}}),$r.prototype.render=function(t,e,n){console.warn("WebGLRenderer: .render() has been renamed to .renderRenderableItem()."),this.renderRenderableItem(t,e,n)};Object.defineProperties(Be.prototype,{environmentLightIntensity:{configurable:!0,get:function(){return console.warn("Scene: .environmentLightIntensity has been deprecated, use .envDiffuseIntensity instead."),this.envDiffuseIntensity},set:function(t){console.warn("Scene: .environmentLightIntensity has been deprecated, use .envDiffuseIntensity instead."),this.envDiffuseIntensity=t}},_lightData:{configurable:!0,get:function(){return console.warn("Scene: ._lightData has been deprecated since v0.4.0, use ._lightingData.getGroup(0) instead."),this._lightingData.getGroup(0)}}}),Object.defineProperties(Ue.prototype,{lights:{configurable:!0,get:function(){return console.warn("RenderStates: .lights has been deprecated since v0.4.0, use .lighting.getGroup(0) instead."),this.lighting.getGroup(0)}}});const ts=e.generateUUID,es=e.isPowerOfTwo,ns=e.nearestPowerOfTwo,is=e.nextPowerOfTwo;t.ATTACHMENT=W,t.AmbientLight=Yn,t.AnimationAction=class extends j{constructor(t){super(),this.clip=t,this.weight=0,this.time=0,this.blendMode=R.NORMAL}update(t){this.time+=t;const e=this.clip.duration;0!==e?(this.time>e&&(this.time=this.time%e),this.time<0&&(this.time=this.time%e+e)):this.time=0}},t.AnimationMixer=class{constructor(){this._actions=[],this._bindings={}}addAction(t){if(-1!==this._actions.indexOf(t))return void console.warn("AnimationMixer.addAction(): already has the action, clip name is <"+t.clip.name+">.");this._actions.push(t);const e=t.clip.tracks;for(let t=0;t<e.length;t++){const n=e[t],i=n.name;if(!this._bindings[i]){const t=new Y(n.target,n.propertyPath,n.valueTypeName,n.valueSize);this._bindings[i]={binding:t,referenceCount:0,active:!1,cachedActive:!1}}this._bindings[i].referenceCount++}}removeAction(t){const e=this._actions.indexOf(t);if(-1===e)return void console.warn("AnimationMixer.removeAction(): action not found in this mixer, clip name is <"+t.clip.name+">.");if(t.weight>0)return void console.warn("AnimationMixer.removeAction(): make sure action's weight is zero before removing it.");this._actions.splice(e,1);const n=t.clip.tracks;for(let t=0;t<n.length;t++){const e=n[t].name,i=this._bindings[e];i&&--i.referenceCount<=0&&(i.cachedActive&&i.binding.restoreOriginalState(),delete this._bindings[e])}}hasAction(t){return this._actions.indexOf(t)>-1}getActions(){return this._actions}update(t){for(const t in this._bindings)this._bindings[t].active=!1;for(let e=0,n=this._actions.length;e<n;e++){const n=this._actions[e];if(n.weight>0){n.update(t);const e=n.clip.tracks;for(let t=0,i=e.length;t<i;t++){const i=e[t],r=this._bindings[i.name],s=r.binding;r.active=!0,r.cachedActive||(r.binding.saveOriginalState(),r.cachedActive=!0),i.getValue(n.time,s.buffer),n.blendMode===R.ADD?s.accumulateAdditive(n.weight):s.accumulate(n.weight)}}}for(const t in this._bindings){const e=this._bindings[t];e.active?e.binding.apply():e.cachedActive&&(e.binding.restoreOriginalState(),e.cachedActive=!1)}}},t.Attribute=sn,t.BLEND_EQUATION=L,t.BLEND_FACTOR=C,t.BLEND_TYPE=R,t.BUFFER_USAGE=X,t.BasicMaterial=class extends mn{constructor(){super(),this.type=w.BASIC}},t.Bone=ri,t.BooleanKeyframeTrack=S,t.Box2=ht,t.Box3=ct,t.BoxGeometry=Pn,t.Buffer=an,t.COMPARE_FUNC=U,t.CULL_FACE_TYPE=b,t.Camera=Ge,t.Color3=At,t.Color4=Lt,t.ColorKeyframeTrack=E,t.CubeGeometry=class extends Pn{constructor(t,e,n,i,r,s){super(t,e,n,i,r,s),console.warn("CubeGeometry has been deprecated, use BoxGeometry instead.")}},t.CubicSplineInterpolant=g,t.CylinderGeometry=class extends pn{constructor(t=1,e=1,n=1,i=8,s=1,a=!1,o=0,l=2*Math.PI){super();const h=this;i=Math.floor(i),s=Math.floor(s);const c=[],u=[],d=[],p=[];let f=0;const _=[],m=n/2;let g=0;function v(n){const s=f,a=new lt,_=new r;let v,T=0;const S=!0===n?t:e,E=!0===n?1:-1;for(v=1;v<=i;v++)u.push(0,m*E,0),d.push(0,E,0),p.push(.5,.5),f++;const x=f;for(v=0;v<=i;v++){const t=v/i*l+o,e=Math.cos(t),n=Math.sin(t);_.x=S*n,_.y=m*E,_.z=S*e,u.push(_.x,_.y,_.z),d.push(0,E,0),a.x=.5*e+.5,a.y=.5*n*E+.5,p.push(a.x,a.y),f++}for(v=0;v<i;v++){const t=s+v,e=x+v;!0===n?c.push(e,e+1,t):c.push(e+1,e,t),T+=3}h.addGroup(g,T,!0===n?1:2),g+=T}!function(){const a=new r,v=new r;let T,S,E=0;const x=(e-t)/n;for(S=0;S<=s;S++){const r=[],h=S/s,c=h*(e-t)+t;for(T=0;T<=i;T++){const t=T/i,e=t*l+o,s=Math.sin(e),_=Math.cos(e);v.x=c*s,v.y=-h*n+m,v.z=c*_,u.push(v.x,v.y,v.z),a.set(s,x,_).normalize(),d.push(a.x,a.y,a.z),p.push(t,1-h),r.push(f++)}_.push(r)}for(T=0;T<i;T++)for(S=0;S<s;S++){const n=_[S][T],i=_[S+1][T],r=_[S+1][T+1],a=_[S][T+1];(t>0||0!==S)&&(c.push(n,i,a),E+=3),(e>0||S!==s-1)&&(c.push(i,r,a),E+=3)}h.addGroup(g,E,0),g+=E}(),!1===a&&(t>0&&v(!0),e>0&&v(!1)),this.setIndex(new sn(new an(u.length/3>65536?new Uint32Array(c):new Uint16Array(c),1))),this.addAttribute("a_Position",new sn(new an(new Float32Array(u),3))),this.addAttribute("a_Normal",new sn(new an(new Float32Array(d),3))),this.addAttribute("a_Uv",new sn(new an(new Float32Array(p),2))),this.computeBoundingBox(),this.computeBoundingSphere()}},t.DRAW_MODE=V,t.DRAW_SIDE=P,t.DefaultLoadingManager=st,t.DepthMaterial=vn,t.DirectionalLight=Kn,t.DirectionalLightShadow=Zn,t.DistanceMaterial=Tn,t.ENVMAP_COMBINE_TYPE=H,t.Euler=bt,t.EventDispatcher=j,t.FileLoader=class extends at{constructor(t){super(t),this.responseType="",this.mimeType=""}load(t,e,n,i){void 0===t&&(t=""),null!=this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),s=this.mimeType,a=this.responseType;fetch(r).then((t=>{if(200===t.status||0===t.status){if(0===t.status&&console.warn("FileLoader: HTTP Status 0 received."),"undefined"==typeof ReadableStream||void 0===t.body||void 0===t.body.getReader)return t;const e=t.body.getReader(),i=t.headers.get("X-File-Size")||t.headers.get("Content-Length"),r=i?parseInt(i):0,s=0!==r;let a=0;const o=new ReadableStream({start(t){!function i(){e.read().then((({done:e,value:o})=>{if(e)t.close();else{a+=o.byteLength;const e=new ProgressEvent("progress",{lengthComputable:s,loaded:a,total:r});n&&n(e),t.enqueue(o),i()}}),(e=>{t.error(e)}))}()}});return new Response(o)}throw new ot(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,t)})).then((t=>{switch(a){case"arraybuffer":return t.arrayBuffer();case"blob":return t.blob();case"document":return t.text().then((t=>(new DOMParser).parseFromString(t,s)));case"json":return t.json();default:if(""===s)return t.text();{const e=/charset="?([^;"\s]*)"?/i.exec(s),n=e&&e[1]?e[1].toLowerCase():void 0,i=new TextDecoder(n);return t.arrayBuffer().then((t=>i.decode(t)))}}})).then((t=>{e&&e(t)})).catch((e=>{i&&i(e),this.manager.itemError(t)})).finally((()=>{this.manager.itemEnd(t)})),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}},t.Fog=Cn,t.FogExp2=bn,t.Frustum=Bt,t.Geometry=pn,t.Group=Jr,t.HemisphereLight=$n,t.ImageLoader=class extends at{constructor(t){super(t)}load(t,e,n,i){void 0===t&&(t=""),void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,s=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){l(),e&&e(this),r.manager.itemEnd(t)}function o(e){l(),i&&i(e),r.manager.itemError(t),r.manager.itemEnd(t)}function l(){s.removeEventListener("load",a,!1),s.removeEventListener("error",o,!1)}return s.addEventListener("load",a,!1),s.addEventListener("error",o,!1),"data:"!==t.slice(0,5)&&void 0!==this.crossOrigin&&(s.crossOrigin=this.crossOrigin),r.manager.itemStart(t),s.src=t,s}},t.KeyframeClip=class{constructor(t="",e=[],n=-1){this.name=t,this.tracks=e,this.duration=n,this.duration<0&&this.resetDuration()}resetDuration(){const t=this.tracks;let e=0;for(let n=0,i=t.length;n<i;n++){const i=t[n];e=Math.max(e,i.times[i.times.length-1])}return this.duration=e,this}},t.KeyframeInterpolant=p,t.KeyframeTrack=T,t.LambertMaterial=class extends mn{constructor(){super(),this.type=w.LAMBERT,this.acceptLight=!0}},t.Light=le,t.LightShadow=Qn,t.LineMaterial=class extends mn{constructor(){super(),this.type=w.LINE,this.lineWidth=1,this.drawMode=V.LINES}copy(t){return super.copy(t),this.lineWidth=t.lineWidth,this}},t.LinearInterpolant=_,t.Loader=at,t.LoadingManager=rt,t.MATERIAL_TYPE=w,t.Material=mn,t.MathUtils=e,t.Matrix3=Pt,t.Matrix4=a,t.Mesh=nn,t.NumberKeyframeTrack=x,t.OPERATION=B,t.Object3D=oe,t.PBR2Material=class extends mn{constructor(){super(),this.type=w.PBR2,this.specular=new At(1118481),this.glossiness=.5,this.specularMap=null,this.glossinessMap=null,this.acceptLight=!0}copy(t){return super.copy(t),this.specular=t.specular,this.glossiness=t.glossiness,this.specularMap=t.specularMap,this.glossinessMap=t.glossinessMap,this}},t.PBRMaterial=class extends mn{constructor(){super(),this.type=w.PBR,this.roughness=.5,this.metalness=.5,this.roughnessMap=null,this.metalnessMap=null,this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new lt(1,1),this.clearcoatNormalMap=null,this.acceptLight=!0}copy(t){return super.copy(t),this.roughness=t.roughness,this.metalness=t.metalness,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this}},t.PIXEL_FORMAT=D,t.PIXEL_TYPE=F,t.PhongMaterial=class extends mn{constructor(){super(),this.type=w.PHONG,this.shininess=30,this.specular=new At(1118481),this.specularMap=null,this.acceptLight=!0}copy(t){return super.copy(t),this.shininess=t.shininess,this.specular.copy(t.specular),this.specularMap=t.specularMap,this}},t.Plane=It,t.PlaneGeometry=class extends pn{constructor(t=1,e=1,n=1,i=1){super();const r=t/2,s=e/2,a=Math.floor(n),o=Math.floor(i),l=a+1,h=o+1,c=t/a,u=e/o;let d,p;const f=[],_=[],m=[],g=[];for(p=0;p<h;p++){const t=p*u-s;for(d=0;d<l;d++){const e=d*c-r;_.push(e,0,t),m.push(0,1,0),g.push(d/a),g.push(1-p/o)}}for(p=0;p<o;p++)for(d=0;d<a;d++){const t=d+l*p,e=d+l*(p+1),n=d+1+l*(p+1),i=d+1+l*p;f.push(t,e,i),f.push(e,n,i)}this.setIndex(new sn(new an(_.length/3>65536?new Uint32Array(f):new Uint16Array(f),1))),this.addAttribute("a_Position",new sn(new an(new Float32Array(_),3))),this.addAttribute("a_Normal",new sn(new an(new Float32Array(m),3))),this.addAttribute("a_Uv",new sn(new an(new Float32Array(g),2))),this.computeBoundingBox(),this.computeBoundingSphere()}},t.PointLight=ti,t.PointLightShadow=Jn,t.PointsMaterial=class extends mn{constructor(){super(),this.type=w.POINT,this.size=1,this.sizeAttenuation=!0,this.drawMode=V.POINTS}copy(t){return super.copy(t),this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}},t.PropertyBindingMixer=Y,t.PropertyMap=wn,t.QUERY_TYPE=q,t.Quaternion=d,t.QuaternionCubicSplineInterpolant=class extends g{static interpolate(t,e,n,i){const r=super.interpolate(t,e,n,i);return v.fromArray(r).normalize().toArray(r),r}},t.QuaternionKeyframeTrack=M,t.QuaternionLinearInterpolant=m,t.Query=class extends j{constructor(){super(),this.id=Xn++}dispose(){this.dispatchEvent({type:"dispose"})}},t.Ray=Wt,t.RectAreaLight=ce,t.RenderBuffer=Dn,t.RenderInfo=class{constructor(){const t={calls:0,triangles:0,lines:0,points:0},e=[function(e,n){t.points+=e*n},function(e,n){t.lines+=e*(n/2)},function(e,n){t.lines+=e*n},function(e,n){t.lines+=e*(n-1)},function(e,n){t.triangles+=e*(n/3)},function(e,n){t.triangles+=e*(n-2)},function(e,n){t.triangles+=e*(n-2)}];this.update=function(n,i,r){t.calls++,e[i](r,n)},this.reset=function(){t.calls=0,t.triangles=0,t.lines=0,t.points=0},this.render=t}},t.RenderQueue=be,t.RenderQueueLayer=ye,t.RenderStates=Ue,t.RenderTarget2D=Un,t.RenderTarget2DArray=zn,t.RenderTarget3D=Hn,t.RenderTargetBack=Vn,t.RenderTargetBase=Nn,t.RenderTargetCube=Wn,t.Renderer=class extends $r{get renderPass(){return console.warn("Renderer: .renderPass has been deprecated, use WebGLRenderer instead."),this}},t.SHADING_TYPE=N,t.SHADOW_TYPE=z,t.Scene=Be,t.SceneData=Ie,t.ShaderChunk=di,t.ShaderLib=fi,t.ShaderMaterial=gn,t.ShaderPostPass=class{constructor(t){const e=new Be,n=this.camera=new Ge;n.frustumCulled=!1,n.position.set(0,0,1),n.lookAt(new r(0,0,0),new r(0,1,0)),n.setOrtho(-1,1,-1,1,.1,2),e.add(n);const i=this.geometry=new pn;i.addAttribute("a_Position",new sn(new an(new Float32Array([-1,3,0,-1,-1,0,3,-1,0]),3))),i.addAttribute("a_Uv",new sn(new an(new Float32Array([0,2,0,0,2,0]),2)));const s=this.material=new gn(t);this.uniforms=s.uniforms;const a=new nn(i,s);a.frustumCulled=!1,e.add(a),e.updateMatrix(),this.renderStates=e.updateRenderStates(n);const o=e.updateRenderQueue(n,!1,!1);this.renderQueueLayer=o.layerList[0],this.renderConfig={}}render(t){t.beginRender(),t.renderRenderableList(this.renderQueueLayer.opaque,this.renderStates,this.renderConfig),t.endRender()}dispose(){this.geometry.dispose(),this.material.dispose()}},t.ShadowMapPass=class{constructor(){this.getDepthMaterial=An,this.getDistanceMaterial=yn,this.shadowLayers=null,this.transparentShadow=!1;const t={isPointLight:!1,light:null};this._state=t;const e=this;this._renderOptions={getGeometry:null,getMaterial:function(n){return t.isPointLight?e.getDistanceMaterial(n,t.light):e.getDepthMaterial(n,t.light)},ifRender:function(t){return t.object.castShadow}}}set getGeometry(t){t?this._renderOptions.getGeometry=t:delete this._renderOptions.getGeometry}get getGeometry(){return this._renderOptions.getGeometry}set ifRender(t){t?this._renderOptions.ifRender=t:delete this._renderOptions.ifRender}get ifRender(){return this._renderOptions.ifRender}render(t,e){Sn.copy(t.getClearColor()),t.setClearColor(1,1,1,1);const n=e._lightingData.lightsArray,i=e._lightingData.shadowsNum;for(let r=0;r<i;r++){const i=n[r],s=i.shadow;if(!1===s.autoUpdate&&!1===s.needsUpdate)continue;const a=s.camera,o=s.renderTarget,l=i.isPointLight,h=l?6:1;this._state.isPointLight=l,this._state.light=i;const c=this._renderOptions;s.prepareDepthMap(!e.disableShadowSampler,t.capabilities);for(let n=0;n<h;n++){l&&(s.update(i,n),o.activeCubeFace=n),t.setRenderTarget(o),t.clear(!0,!0);const r=e.updateRenderStates(a,0===n),h=e.updateRenderQueue(a,!1,!1);t.beginRender();for(let e=0;e<h.layerList.length;e++){const n=h.layerList[e];null!==this.shadowLayers&&-1===this.shadowLayers.indexOf(n.id)||(t.renderRenderableList(n.opaque,r,c),this.transparentShadow&&t.renderRenderableList(n.transparent,r,c))}t.endRender()}s.needsUpdate=!1}t.setClearColor(Sn.x,Sn.y,Sn.z,Sn.w)}},t.Skeleton=jn,t.SkinnedMesh=si,t.Sphere=Yt,t.SphereGeometry=class extends pn{constructor(t=1,e=8,n=6,i=0,s=2*Math.PI,a=0,o=Math.PI){super(),e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const l=a+o;let h,c,u=0;const d=[],p=new r,f=new r,_=[],m=[],g=[],v=[];for(c=0;c<=n;c++){const r=[],_=c/n;let T=0;for(0==c&&0==a?T=.5/e:c==n&&l==Math.PI&&(T=-.5/e),h=0;h<=e;h++){const n=h/e;p.x=-t*Math.cos(i+n*s)*Math.sin(a+_*o),p.y=t*Math.cos(a+_*o),p.z=t*Math.sin(i+n*s)*Math.sin(a+_*o),m.push(p.x,p.y,p.z),f.copy(p).normalize(),g.push(f.x,f.y,f.z),v.push(n+T,1-_),r.push(u++)}d.push(r)}for(c=0;c<n;c++)for(h=0;h<e;h++){const t=d[c][h+1],e=d[c][h],i=d[c+1][h],r=d[c+1][h+1];(0!==c||a>0)&&_.push(t,e,r),(c!==n-1||l<Math.PI)&&_.push(e,i,r)}this.setIndex(new sn(new an(m.length/3>65536?new Uint32Array(_):new Uint16Array(_),1))),this.addAttribute("a_Position",new sn(new an(new Float32Array(m),3))),this.addAttribute("a_Normal",new sn(new an(new Float32Array(g),3))),this.addAttribute("a_Uv",new sn(new an(new Float32Array(v),2))),this.computeBoundingBox(),this.computeBoundingSphere()}},t.Spherical=Qt,t.SphericalHarmonics3=Zt,t.SphericalHarmonicsLight=ei,t.SpotLight=ii,t.SpotLightShadow=ni,t.StepInterpolant=f,t.StringKeyframeTrack=A,t.TEXEL_ENCODING_TYPE=G,t.TEXTURE_FILTER=I,t.TEXTURE_WRAP=O,t.Texture2D=On,t.Texture2DArray=Bn,t.Texture3D=Gn,t.TextureBase=In,t.TextureCube=kn,t.ThinRenderer=Ln,t.TorusKnotGeometry=class extends pn{constructor(t=1,e=.4,n=64,i=8,s=2,a=3){super(),n=Math.floor(n),i=Math.floor(i);const o=[],l=[],h=[],c=[];let u,d;const p=new r,f=new r,_=new r,m=new r,g=new r,v=new r,T=new r;for(u=0;u<=n;++u){const r=u/n*s*Math.PI*2;for(S(r,s,a,t,_),S(r+.01,s,a,t,m),v.subVectors(m,_),T.addVectors(m,_),g.crossVectors(v,T),T.crossVectors(g,v),g.normalize(),T.normalize(),d=0;d<=i;++d){const t=d/i*Math.PI*2,r=-e*Math.cos(t),s=e*Math.sin(t);p.x=_.x+(r*T.x+s*g.x),p.y=_.y+(r*T.y+s*g.y),p.z=_.z+(r*T.z+s*g.z),l.push(p.x,p.y,p.z),f.subVectors(p,_).normalize(),h.push(f.x,f.y,f.z),c.push(u/n),c.push(d/i)}}for(d=1;d<=n;d++)for(u=1;u<=i;u++){const t=(i+1)*(d-1)+(u-1),e=(i+1)*d+(u-1),n=(i+1)*d+u,r=(i+1)*(d-1)+u;o.push(t,e,r),o.push(e,n,r)}function S(t,e,n,i,r){const s=Math.cos(t),a=Math.sin(t),o=n/e*t,l=Math.cos(o);r.x=i*(2+l)*.5*s,r.y=i*(2+l)*a*.5,r.z=i*Math.sin(o)*.5}this.setIndex(new sn(new an(l.length/3>65536?new Uint32Array(o):new Uint16Array(o),1))),this.addAttribute("a_Position",new sn(new an(new Float32Array(l),3))),this.addAttribute("a_Normal",new sn(new an(new Float32Array(h),3))),this.addAttribute("a_Uv",new sn(new an(new Float32Array(c),2))),this.computeBoundingBox(),this.computeBoundingSphere()}},t.TransformUV=fn,t.Triangle=ee,t.VERTEX_COLOR=k,t.Vector2=lt,t.Vector3=r,t.Vector4=ne,t.VectorKeyframeTrack=y,t.WebGLAttribute=_i,t.WebGLCapabilities=mi,t.WebGLGeometries=vi,t.WebGLProgram=zi,t.WebGLPrograms=Vi,t.WebGLQueries=rr,t.WebGLRenderBuffers=Er,t.WebGLRenderer=$r,t.WebGLState=cr,t.WebGLTextures=ur,t.WebGLUniforms=Ui,t.cloneJson=re,t.cloneUniforms=ie,t.generateUUID=ts,t.isPowerOfTwo=es,t.nearestPowerOfTwo=ns,t.nextPowerOfTwo=is}));
