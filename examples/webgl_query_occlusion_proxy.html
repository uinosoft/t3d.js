<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>t3d - occlusion query proxy</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
    <div id="info">
        <a href="" target="_blank">t3d</a> - occlusion query proxy<br />  
        The sprite becomes translucent when it is occluded.<br />
		Only available in WebGL2.0.<br />
        <div id="notSupported" style="display:none">
            Your browser does not support WebGL2.0,
            but the occlusion query feature can only be used in WebGL2.0
        </div>
    </div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="./libs/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "t3d": "../build/t3d.module.js",
                "t3d/addons/": "./jsm/"
            }
        }
    </script>

	<script type="module">
		import * as t3d from 't3d';
		import { OrbitControls } from 't3d/addons/controls/OrbitControls.js';
		import { Texture2DLoader } from 't3d/addons/loaders/Texture2DLoader.js';
		import { Sprite } from 't3d/addons/objects/Sprite.js';
		import { PolyhedronBuilder } from 't3d/addons/geometries/builders/PolyhedronBuilder.js';
		import { OcclusionProxyManager, OcclusionProxy, OcclusionRenderOptions } from 't3d/addons/misc/OcclusionProxyManager.js';
		import TWEEN from './libs/tween.module.js';
		import { GUI } from './libs/lil-gui.esm.min.js';

		let width = window.innerWidth || 2;
		let height = window.innerHeight || 2;

		const canvas = document.createElement('canvas');
		canvas.width = width;
		canvas.height = height;
		document.body.appendChild(canvas);

		const contextParams = { antialias: true, alpha: false };
		const gl = canvas.getContext('webgl2', contextParams);

		if (!gl) {
			document.getElementById('notSupported').style.display = '';
		}

		const renderer = new t3d.WebGLRenderer(gl);
		renderer.setClearColor(0.1, 0.1, 0.1, 1);
		const backRenderTarget = new t3d.RenderTargetBack(canvas);

		const scene = new t3d.Scene();

		// camera

		const camera = new t3d.Camera();
		camera.outputEncoding = t3d.TEXEL_ENCODING_TYPE.SRGB;
		camera.position.set(-15, 10, -15);
		camera.lookAt(new t3d.Vector3(0, 0, 0), new t3d.Vector3(0, 1, 0));
		camera.setPerspective(45 / 180 * Math.PI, width / height, 1, 800);
		scene.add(camera);

		const controller = new OrbitControls(camera, canvas);

		// lights

		const ambientLight = new t3d.AmbientLight(0x88aaff, 0.4);
		scene.add(ambientLight);

		const directionalLight = new t3d.DirectionalLight(0xffffff, 1);
		directionalLight.position.set(-3, 4, 5);
		directionalLight.lookAt(new t3d.Vector3(), new t3d.Vector3(0, 1, 0));
		scene.add(directionalLight);

		// sphere

		const sphereGeometry = new t3d.SphereGeometry(5, 32, 32);
		const sphereMaterial = new t3d.PBRMaterial();
		sphereMaterial.roughness = 1;
		const sphere = new t3d.Mesh(sphereGeometry, sphereMaterial);
		scene.add(sphere);

		// create sprites with occlusion proxies

		const proxyGeometryData = PolyhedronBuilder.getTetrahedronGeometryData(1);
		const tetrahedronGeometry = new t3d.Geometry();
		tetrahedronGeometry.addAttribute('a_Position', new t3d.Attribute(new t3d.Buffer(new Float32Array(proxyGeometryData.positions), 3)));
		tetrahedronGeometry.computeBoundingSphere();

		const proxyMaterial = new t3d.BasicMaterial();
		proxyMaterial.depthWrite = false;
		proxyMaterial.colorWrite = false;
		proxyMaterial.diffuse.setHex(0xff00ff);

		const spriteTexture = new Texture2DLoader().load('./resources/sprites/sprite0.png');

		const sprites = new t3d.Object3D();
		scene.add(sprites);

		const tweenGroup = new TWEEN.Group();

		const occlusionManager = new OcclusionProxyManager(150);

		for (let i = 0; i < 150; i++) {
			const radius = 5 + Math.random() * 5;
			const theta = Math.random() * Math.PI;
			const phi = Math.random() * Math.PI * 2;

			const sprite = createSprite(
				radius * Math.sin(theta) * Math.cos(phi),
				radius * Math.sin(theta) * Math.sin(phi),
				radius * Math.cos(theta)
			);
			sprite.add(createProxy(sprite));
			sprites.add(sprite);
		}

		function createSprite(x, y, z) {
			const sprite = new Sprite();
			sprite.position.set(x, y, z);

			sprite.renderLayer = 2;
			sprite.__occluded = false;
		
			sprite.material.diffuseMap = spriteTexture;
			sprite.material.transparent = true;

			return sprite;
		}

		function createProxy(sprite) {
			const proxy = new OcclusionProxy(tetrahedronGeometry, proxyMaterial);
			proxy.scale.setScalar(0.5); // fit the sprite size
			proxy.onOcclusionChange = function(occluded) {
				styleChange(sprite, occluded);
			};
			occlusionManager.addProxy(proxy);
			return proxy;
		}

		function styleChange(sprite, occluded) {
			if (sprite.__occluded === occluded) return;
			sprite.__occluded = occluded;

			if (sprite.__tween && sprite.__tween.isPlaying) {
				sprite.__tween.stop();
			}

			sprite.__tween = new TWEEN.Tween(sprite, tweenGroup)
				.to({ rotation: occluded ? Math.PI : 0 }, 200)
				.easing(TWEEN.Easing.Quadratic.Out)
				.start();

			sprite.material.diffuse.setHex(occluded ? 0x4D99FF : 0xFFFFFF);
			sprite.material.opacity = occluded ? 0.3 : 1;
		}

		// gui

		const params = { enableOcclusionQuery: true, debug: false };
		const gui = new GUI();
		gui.add(params, 'enableOcclusionQuery').name('Occlusion Enabled').onChange(function(value) {
			// reset all sprites to front style
			sprites.children.forEach(sprite => {
				if (value) {
					occlusionManager.addProxy(sprite.children[0]);
				} else {
					occlusionManager.removeProxy(sprite.children[0]);
					styleChange(sprite, false);
				}
			});
		});
		gui.add(params, 'debug').name('Proxy Debug').onChange(function(value) {
			// show or hide occlusion proxy
			proxyMaterial.colorWrite = value;

			// show or hide sprites
			sprites.children.forEach(sprite => {
				sprite.renderable = !value;
			});
		});

		//

		const renderOption = {};

		function loop(count) {
			requestAnimationFrame(loop);

			controller.update();
			tweenGroup.update();

			scene.updateMatrix();
			const renderStates = scene.updateRenderStates(camera);
			const renderQueue = scene.updateRenderQueue(camera);

			// Main layer

			renderer.setRenderTarget(backRenderTarget);
			renderer.clear(true, true, false);

			const mainLayer = renderQueue.getLayer(0);
			renderer.beginRender();
			renderer.renderRenderableList(mainLayer.opaque, renderStates, renderOption);
			renderer.renderRenderableList(mainLayer.transparent, renderStates, renderOption);
			renderer.endRender();

			// Occlusion layer

			const occlusionLayer = renderQueue.getLayer(1);
			if (occlusionLayer && occlusionLayer.opaqueCount > 0) {
				renderer.setRenderTarget(backRenderTarget);
				if (params.enableOcclusionQuery) {
					renderer.setOcclusionQuerySet(occlusionManager.querySet);
				}
		
				renderer.beginRender();
				renderer.renderRenderableList(occlusionLayer.opaque, renderStates, OcclusionRenderOptions);
				renderer.endRender();
			}

			// Overlay layer

			const overlayLayer = renderQueue.getLayer(2);
			if (overlayLayer && (overlayLayer.opaqueCount + overlayLayer.transparentCount) > 0) {
				renderer.setRenderTarget(backRenderTarget);
				renderer.clear(false, true, false);

				renderer.beginRender();
				renderer.renderRenderableList(overlayLayer.opaque, renderStates, renderOption);
				renderer.renderRenderableList(overlayLayer.transparent, renderStates, renderOption);
				renderer.endRender();
			}

			// Occlusion result sync

			if (params.enableOcclusionQuery) {
				occlusionManager.update(renderer);
			}
		}
		requestAnimationFrame(loop);

		function onWindowResize() {
			width = window.innerWidth || 2;
			height = window.innerHeight || 2;

			camera.setPerspective(45 / 180 * Math.PI, width / height, 1, 800);

			backRenderTarget.resize(width, height);
		}
		window.addEventListener('resize', onWindowResize, false);
	</script>
</body>

</html>